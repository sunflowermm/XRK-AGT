# 事件监听器开发指南

本文档说明如何为框架注册新的事件监听器，以支持新的适配器或事件类型。

## 概述

事件监听器负责监听特定类型的事件，并将这些事件分发给插件系统处理。框架目前支持三种适配器：
- **OneBot**: 监听 `onebot.*` 事件
- **Device**: 监听 `device.*` 事件  
- **Stdin**: 监听 `stdin.*` 事件

## 事件字段责任边界（必须声明 vs 自动补全）

开发者在「注册监听器 + 适配器」时需要显式提供**基础字段**，其余由 `PluginsLoader` 自动补全：

- 开发者必须提供（进入 `PluginsLoader.deal` 前就应存在）
  - `adapter`：适配器标识（建议小写），如 `onebot` / `device` / `stdin` / 自定义
  - `post_type`：`message` | `notice` | `request` | `device` | `command` | 其他自定义
  - `message`：标准消息段数组（至少给 text 段），或 `raw_message` 文本
  - `detail` 字段：`message_type` / `notice_type` / `request_type` / `detail_type`（用于事件匹配）
  - `sub_type`：子类型（可选）
  - `user_id`（消息/请求类必填），`group_id`（群事件需提供），`device_id`（设备事件需提供）
  - `time`：秒级时间戳（缺省会由适配器/事件源赋值）
- 加载器自动补全
  - `self_id`：若缺省则使用 `device_id`、`stdin` 或 `Bot.uin[0]`
  - `bot`：通过事件确定对应的 Bot 实例并以只读属性挂载
  - `event_id`：若缺省则生成 `adapter_postType_timestamp_random`
  - `isDevice` / `isStdin` / `logText` / 基础 `sender.nickname/card`
  - `reply` 包装：统一的发送兜底（不要在适配器里覆盖 `reply`，只提供最原始的发送方法）
  - 工具方法：`getSendableMedia`、`throttle`、`getEventHistory` 等

## 创建事件监听器

### 1. 文件位置

在 `core/events/` 目录下创建新的监听器文件，例如 `myadapter.js`。

### 2. 基本结构

```javascript
import PluginsLoader from '../../src/infrastructure/plugins/loader.js'

/**
 * 自定义适配器事件监听器
 * 监听所有 myadapter.* 事件并分发给插件系统
 */
export default class MyAdapterEvent {
  constructor() {
    this.plugins = PluginsLoader
    this.processedEvents = new Set() // 用于去重，避免重复处理
  }

  /**
   * 初始化监听器
   * 通过 Bot.on 注册事件监听
   */
  async init() {
    // 监听基础事件
    Bot.on('myadapter.message', (e) => this.handleEvent(e, 'myadapter.message'))
    Bot.on('myadapter.notice', (e) => this.handleEvent(e, 'myadapter.notice'))
    Bot.on('myadapter.request', (e) => this.handleEvent(e, 'myadapter.request'))
  }

  /**
   * 处理事件
   * @param {Object} e - 事件对象
   * @param {string} eventType - 事件类型
   */
  async handleEvent(e, eventType) {
    try {
      // 使用事件ID去重，避免重复处理
      const eventId = e.event_id || `${eventType}_${Date.now()}_${Math.random()}`
      if (this.processedEvents.has(eventId)) {
        return
      }
      this.processedEvents.add(eventId)
      
      // 清理旧的事件ID（保留最近1000个）
      if (this.processedEvents.size > 1000) {
        const ids = Array.from(this.processedEvents)
        ids.slice(0, ids.length - 1000).forEach(id => this.processedEvents.delete(id))
      }
      
      // 设置事件来源标识（基础属性）
      e.adapter = 'myadapter'
      e.isMyAdapter = true // 可选：设置特定标识
      
      // 可选：转换事件格式为标准格式（只设置通用字段）
      if (e.custom_field && !e.post_type) {
        e.post_type = 'message'
        e.raw_message = e.custom_field
        e.msg = e.custom_field
        if (!e.message) {
          e.message = [{ type: 'text', text: e.custom_field }]
        }
      }
      
      // 注意：适配器特定的属性（如isGroup/isPrivate/friend/group等）应由增强插件处理
      // 这里只设置基础字段，不设置适配器特定属性
      
      // 分发给插件系统处理
      // Bot.em 会自动调用 Bot.prepareEvent 设置通用属性
      // 适配器增强插件会通过 accept 方法挂载适配器特定属性
      await this.plugins.deal(e)
    } catch (error) {
      Bot.makeLog('error', `MyAdapter事件处理错误: ${error.message}`, e.self_id, error)
    }
  }
}
```

### 3. 关键要点

#### 事件去重
使用 `processedEvents` Set 来避免重复处理同一事件。这对于防止 `Bot.em` 递归触发导致重复处理很重要。

#### 事件标识
在 `handleEvent` 中设置：
- `e.adapter = 'myadapter'` - 适配器类型
- `e.isMyAdapter = true` - 可选：特定适配器标识

#### 事件格式标准化
如果适配器的事件格式与标准格式不同，可以在 `handleEvent` 中进行转换：

```javascript
// 示例：将自定义格式转换为标准格式
if (e.custom_message && !e.message) {
  e.post_type = 'message'
  e.message_type = 'private'
  e.raw_message = e.custom_message
  e.msg = e.custom_message
  e.message = [{ type: 'text', text: e.custom_message }]
}
```

### 4. 事件命名规范

事件名称应遵循以下格式：
- 基础事件：`{adapter}.{event_type}`
  - 例如：`myadapter.message`, `myadapter.notice`, `myadapter.request`
- 具体事件：`{adapter}.{event_type}.{sub_type}`
  - 例如：`myadapter.message.private`, `myadapter.message.group`

### 5. 在适配器中触发事件

在适配器代码中，使用 `Bot.em()` 触发事件：

```javascript
// 触发基础事件
Bot.em('myadapter.message', {
  event_id: 'unique_event_id',
  user_id: '123456',
  message: [{ type: 'text', text: 'Hello' }],
  // ... 其他字段
})

// 触发具体事件（会自动触发父级事件）
Bot.em('myadapter.message.private', {
  // ... 事件数据
})
```

## 插件中的事件监听

插件可以通过以下方式监听事件：

### 1. 监听特定适配器的事件

```javascript
// plugin 是全局对象，无需 import
export class MyPlugin extends plugin {
  constructor() {
    super({
      name: 'MyPlugin',
      event: 'myadapter.message', // 只监听 myadapter 的 message 事件
      rule: [{ reg: '^#test$', fnc: 'test' }]
    })
  }
}
```

### 2. 监听所有适配器的通用事件（跨平台）

```javascript
export class CrossPlatformPlugin extends plugin {
  constructor() {
    super({
      name: 'CrossPlatformPlugin',
      event: 'message', // 匹配所有适配器的 message 事件
      rule: [{ reg: '^#test$', fnc: 'test' }]
    })
  }
}
```

### 3. 使用通配符

```javascript
export class AllMyAdapterPlugin extends plugin {
  constructor() {
    super({
      name: 'AllMyAdapterPlugin',
      event: 'myadapter.*', // 匹配所有 myadapter 事件
      rule: [{ reg: '.*', fnc: 'handle' }]
    })
  }
}
```

## 事件匹配规则

插件的事件匹配遵循以下规则（按优先级）：

1. **完全匹配**: `plugin.event === actualEvent`
2. **通配符匹配**: 支持 `*` 通配符
3. **通用事件匹配**: 如果插件监听的是通用事件名（如 `message`），会匹配所有适配器的对应事件
4. **前缀匹配**: `myadapter.*` 匹配所有 `myadapter.` 开头的事件

## 示例：完整流程

### 1. 创建事件监听器

`core/events/myadapter.js`:
```javascript
import PluginsLoader from '../../src/infrastructure/plugins/loader.js'

export default class MyAdapterEvent {
  constructor() {
    this.plugins = PluginsLoader
    this.processedEvents = new Set()
  }

  async init() {
    Bot.on('myadapter.message', (e) => this.handleEvent(e, 'myadapter.message'))
  }

  async handleEvent(e, eventType) {
    const eventId = e.event_id || `${eventType}_${Date.now()}_${Math.random()}`
    if (this.processedEvents.has(eventId)) return
    this.processedEvents.add(eventId)
    
    if (this.processedEvents.size > 1000) {
      const ids = Array.from(this.processedEvents)
      ids.slice(0, ids.length - 1000).forEach(id => this.processedEvents.delete(id))
    }
    
    e.adapter = 'myadapter'
    await this.plugins.deal(e)
  }
}
```

### 2. 在适配器中触发事件

`core/adapter/MyAdapter.js`:
```javascript
// 当收到消息时
Bot.em('myadapter.message', {
  event_id: `myadapter_${Date.now()}_${Math.random()}`,
  user_id: '123456',
  message: [{ type: 'text', text: 'Hello World' }],
  post_type: 'message',
  message_type: 'private'
})
```

### 3. 在插件中监听事件

`core/plugin/example/MyAdapter示例.js`:
```javascript
export class MyAdapterExample extends plugin {
  constructor() {
    super({
      name: 'MyAdapter示例',
      event: 'myadapter.message',
      rule: [{ reg: '^#test$', fnc: 'test' }]
    })
  }

  async test(e) {
    await e.reply(`收到MyAdapter消息: ${e.msg}`)
    return true
  }
}
```

## 注意事项

1. **事件去重**: 必须实现事件去重机制，避免重复处理
2. **事件标识**: 设置 `e.adapter` 以便插件系统识别事件来源
3. **只设置基础属性**: 事件监听器只应设置通用基础属性，适配器特定的属性（如`isGroup`、`friend`、`group`等）应由增强插件处理
4. **错误处理**: 在 `handleEvent` 中使用 try-catch 捕获错误
5. **事件格式**: 尽量将事件转换为标准格式，以便插件统一处理
6. **性能考虑**: 定期清理 `processedEvents`，避免内存泄漏
7. **增强插件**: 如果需要挂载适配器特定属性，应创建对应的增强插件（参考`OneBotEnhancer`）

## 参考实现

可以参考以下现有实现：
- `core/events/onebot.js` - OneBot事件监听器
- `core/events/device.js` - 设备事件监听器
- `core/events/stdin.js` - 标准输入事件监听器

## 总结

创建新的事件监听器需要：
1. 在 `core/events/` 创建监听器文件
2. 实现 `init()` 方法注册事件监听
3. 实现 `handleEvent()` 方法处理事件
4. 设置事件标识和格式标准化
5. 在适配器中使用 `Bot.em()` 触发事件
6. 插件可以通过 `event` 字段监听事件

遵循这些规范，可以轻松为框架添加新的适配器支持。

