# 事件系统标准化文档

## 概述

本框架采用标准化的事件系统，支持多平台适配器（OneBot、Device、Stdin）。所有事件都通过统一的事件总线进行分发，插件可以通过标准化的事件名称来监听和处理事件。

## 事件命名规范

### 标准事件格式

事件名称采用分层结构：`{适配器}.{事件类型}.{子类型}`

- **适配器前缀**：`onebot`、`device`、`stdin`
- **事件类型**：`message`、`notice`、`request` 等
- **子类型**：适配器特定的子类型（可选）

### 事件匹配规则

#### 1. 完全匹配
```javascript
event: 'onebot.message.group.normal'  // 只匹配 OneBot 群聊普通消息
```

#### 2. 通配符匹配
```javascript
event: 'onebot.message.*'  // 匹配所有 OneBot 消息事件
event: 'onebot.*'          // 匹配所有 OneBot 事件
```

#### 3. 通用事件匹配（跨适配器）
```javascript
event: 'message'  // 匹配所有适配器的 message 事件
                  // 等同于: onebot.message, device.message, stdin.command
```

#### 4. 适配器级别匹配
```javascript
event: 'device'   // 匹配所有设备事件
event: 'stdin'    // 匹配所有标准输入事件
```

## 插件事件监听

### 基本用法

```javascript
// plugin 是全局对象，无需 import
export default class MyPlugin extends plugin {
  constructor() {
    super({
      name: '我的插件',
      dsc: '插件描述',
      event: 'message',  // 监听所有适配器的消息事件
      priority: 5000,
      rule: [
        {
          reg: '^#测试$',
          fnc: 'handleTest'
        }
      ]
    })
  }

  async handleTest(e) {
    await this.reply('测试成功')
  }
}
```

### 监听特定适配器

```javascript
// 只监听 OneBot 的消息
event: 'onebot.message'

// 只监听设备的消息
event: 'device.message'

// 只监听标准输入的命令
event: 'stdin.command'
```

### 监听所有事件

```javascript
// 监听所有 OneBot 事件
event: 'onebot.*'

// 监听所有设备事件
event: 'device.*'

// 监听所有标准输入事件
event: 'stdin.*'
```

## 注册新的事件监听器

### 方式一：在适配器中注册

如果你正在开发一个新的适配器，需要在适配器中触发事件：

```javascript
// Bot 是全局对象，无需 import
// 触发事件（使用适配器前缀）
Bot.em('myadapter.message', eventData)
Bot.em('myadapter.notice', noticeData)
Bot.em('myadapter.request', requestData)
```

### 方式二：创建事件监听器类

在 `core/events/` 目录下创建新的事件监听器：

```javascript
// core/events/myadapter.js
import PluginsLoader from '../../src/infrastructure/plugins/loader.js'

export default class MyAdapterEvent {
  constructor() {
    this.plugins = PluginsLoader
    this.processedEvents = new Set()
  }

  async init() {
    // 监听适配器事件
    Bot.on('myadapter.message', (e) => this.handleEvent(e, 'myadapter.message'))
    Bot.on('myadapter.notice', (e) => this.handleEvent(e, 'myadapter.notice'))
    Bot.on('myadapter.request', (e) => this.handleEvent(e, 'myadapter.request'))
  }

  async handleEvent(e, eventType) {
    try {
      // 事件去重
      const eventId = e.event_id || `${eventType}_${Date.now()}_${Math.random()}`
      if (this.processedEvents.has(eventId)) {
        return
      }
      this.processedEvents.add(eventId)

      // 限制去重集合大小
      if (this.processedEvents.size > 1000) {
        const ids = Array.from(this.processedEvents)
        ids.slice(0, ids.length - 1000).forEach(id => this.processedEvents.delete(id))
      }

      // 设置适配器标识
      e.adapter = 'myadapter'
      e.isMyAdapter = true  // 可选：添加特定标识

      // 交给插件系统处理
      await this.plugins.deal(e)
    } catch (error) {
      Bot.makeLog('error', `MyAdapter事件处理错误: ${error.message}`, e.self_id, error)
    }
  }
}
```

### 方式三：在插件加载器中注册

事件监听器会自动从 `core/events/` 目录加载，确保你的监听器文件：

1. 位于 `core/events/` 目录
2. 导出默认类
3. 类有 `init()` 方法
4. 在 `init()` 中注册事件监听

## 事件对象标准化

### 必需字段

所有事件对象应包含以下字段：

```javascript
{
  adapter: 'onebot' | 'device' | 'stdin' | 'myadapter',  // 适配器类型
  event_id: 'unique_event_id',                          // 唯一事件ID
  self_id: 'bot_id',                                     // Bot ID
  bot: BotInstance,                                      // Bot 实例
  post_type: 'message' | 'notice' | 'request',            // 事件类型
  time: 1234567890,                                      // 时间戳
}
```

### OneBot 事件字段

```javascript
{
  post_type: 'message',
  message_type: 'group' | 'private',
  sub_type: 'normal' | 'anonymous' | ...,
  user_id: 123456,
  group_id: 789012,
  message: [...],  // 消息段数组
  raw_message: '消息文本',
  // ... 其他 OneBot 字段
}
```

### Device 事件字段

```javascript
{
  post_type: 'device',
  event_type: 'message' | 'notice' | 'request',
  device_id: 'device_001',
  device_type: 'esp32' | 'web' | ...,
  device_name: '设备名称',
  event_data: {...},  // 事件数据
  // ... 其他设备字段
}
```

### Stdin 事件字段

```javascript
{
  adapter: 'stdin',
  command: '用户输入的命令',
  post_type: 'message',
  message_type: 'private',
  raw_message: '命令文本',
  message: [{ type: 'text', text: '命令文本' }],
  // ... 其他 stdin 字段
}
```

## 插件前置检查（accept 方法）

### 默认实现

插件基类提供了默认的 `accept` 方法，实现了系统配置的黑白名单检查：

```javascript
// 默认会检查：
// - QQ黑名单 (cfg.other.blackQQ)
// - 设备黑名单 (cfg.other.blackDevice)
// - QQ白名单 (cfg.other.whiteQQ)
// - 群组黑白名单 (cfg.other.blackGroup / whiteGroup)
```

### 自定义实现

插件可以重写 `accept` 方法来实现自定义的前置检查：

```javascript
export default class MyPlugin extends plugin {
  constructor() {
    super({
      name: '我的插件',
      event: 'message',
      rule: [{ reg: '^#测试$', fnc: 'test' }]
    })
  }

  async accept(e) {
    // 调用父类的默认实现（黑白名单检查）
    const baseResult = await super.accept(e)
    if (baseResult === false) return false

    // 自定义检查：只允许特定用户
    const allowedUsers = [123456, 789012]
    if (!allowedUsers.includes(e.user_id)) {
      return false
    }

    // 返回 true 表示通过检查
    return true
  }

  async test(e) {
    await this.reply('测试成功')
  }
}
```

### accept 方法返回值

- `true`: 通过检查，继续处理
- `false`: 拒绝处理，跳过当前插件
- `'return'`: 停止处理，不再执行后续插件
- 其他值: 继续处理，可用于传递状态

## 事件处理流程

```
1. 适配器触发事件
   ↓
2. 事件监听器接收 (core/events/*.js)
   ↓
3. 事件去重和标准化
   ↓
4. 插件加载器处理 (PluginsLoader.deal)
   ↓
5. 初始化事件对象 (initEvent)
   ↓
6. 前置检查 (preCheck)
   ↓
7. 初始化插件列表 (initPlugins)
   ↓
8. 执行 accept 方法（每个插件）
   ↓
9. 处理上下文 (handleContext)
   ↓
10. 执行插件规则 (processRules)
    ↓
11. 调用插件方法
```

## 最佳实践

### 1. 事件命名

- 使用清晰、描述性的名称
- 遵循 `适配器.类型.子类型` 格式
- 避免使用特殊字符

### 2. 事件去重

- 在事件监听器中实现去重逻辑
- 使用 `event_id` 或生成唯一ID
- 限制去重集合大小（建议 1000）

### 3. 错误处理

- 使用 try-catch 包裹事件处理逻辑
- 记录错误日志
- 避免事件处理错误影响其他插件

### 4. 性能优化

- 尽早返回，避免不必要的处理
- 使用事件去重避免重复处理
- 合理使用优先级（priority）

### 5. 兼容性

- 支持通用事件名（如 `message`）以兼容多平台
- 提供适配器特定的选项
- 保持事件对象结构的一致性

## 示例

### 示例 1：跨平台消息插件

```javascript
export default class CrossPlatformPlugin extends plugin {
  constructor() {
    super({
      name: '跨平台插件',
      event: 'message',  // 匹配所有适配器的消息
      rule: [{ reg: '^#hello$', fnc: 'sayHello' }]
    })
  }

  async sayHello(e) {
    // 根据适配器类型做不同处理
    if (e.isOneBot) {
      await this.reply('OneBot: Hello!')
    } else if (e.isDevice) {
      await this.reply('Device: Hello!')
    } else if (e.isStdin) {
      await this.reply('Stdin: Hello!')
    }
  }
}
```

### 示例 2：OneBot 特定插件

```javascript
export default class OneBotOnlyPlugin extends plugin {
  constructor() {
    super({
      name: 'OneBot专用插件',
      event: 'onebot.message.group.normal',  // 只匹配群聊普通消息
      rule: [{ reg: '^#群聊测试$', fnc: 'test' }]
    })
  }

  async test(e) {
    await this.reply(`收到群聊消息: ${e.msg}`)
  }
}
```

### 示例 3：自定义 accept 检查

```javascript
export default class CustomCheckPlugin extends plugin {
  constructor() {
    super({
      name: '自定义检查插件',
      event: 'message',
      rule: [{ reg: '^#admin$', fnc: 'admin' }]
    })
  }

  async accept(e) {
    // 先执行默认检查
    const baseResult = await super.accept(e)
    if (baseResult === false) return false

    // 自定义：只允许管理员
    if (!e.isMaster && !e.member?.is_admin) {
      return false
    }

    return true
  }

  async admin(e) {
    await this.reply('管理员命令执行成功')
  }
}
```

## 常见问题

### Q: 如何让插件同时支持多个适配器？

A: 使用通用事件名，如 `event: 'message'`，这样会匹配所有适配器的对应事件。

### Q: accept 方法什么时候被调用？

A: 在插件规则匹配之前，所有匹配事件的插件都会先执行 `accept` 方法。

### Q: 如何阻止其他插件处理事件？

A: 在 `accept` 方法中返回 `'return'`，这会停止后续插件的处理。

### Q: 事件去重是如何工作的？

A: 每个事件监听器维护一个 `processedEvents` Set，通过 `event_id` 进行去重。

### Q: 如何添加新的适配器？

A: 
1. 在适配器中触发事件（使用适配器前缀）
2. 创建事件监听器类（`core/events/myadapter.js`）
3. 在监听器中注册事件并调用 `PluginsLoader.deal(e)`

---

## 相关文档

- **[事件监听器开发指南](事件监听器开发指南.md)** - 如何创建新的事件监听器
- **[插件基类](plugin-base.md)** - 插件基类的详细说明
- **[插件加载器](plugins-loader.md)** - 插件加载和处理机制

