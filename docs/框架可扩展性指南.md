# XRK-AGT 框架可扩展性指南

> **本文档全面介绍XRK-AGT框架的可扩展性设计，帮助开发者充分利用框架的扩展能力，快速构建自定义功能。**

## 📚 目录

- [可扩展性概述](#可扩展性概述)
- [核心扩展点](#核心扩展点)
- [插件系统扩展](#插件系统扩展)
- [工作流系统扩展](#工作流系统扩展)
- [Tasker扩展](#tasker扩展)
- [事件系统扩展](#事件系统扩展)
- [HTTP/API扩展](#httpapi扩展)
- [渲染器扩展](#渲染器扩展)
- [配置系统扩展](#配置系统扩展)
- [加载器扩展](#加载器扩展)
- [最佳实践](#最佳实践)

---

## 可扩展性概述

XRK-AGT框架采用**分层架构 + 基类设计 + 加载器机制**，实现了高度的可扩展性：

### 核心设计原则

1. **基础设施与业务分离**：基础设施层提供通用能力，业务层专注具体实现
2. **基类抽象**：所有功能都基于基类，通过继承快速扩展
3. **自动加载**：通过加载器自动发现和加载扩展
4. **标准化接口**：统一的接口规范，易于集成和维护
5. **无特化逻辑**：底层代码不包含任何针对特定业务场景的硬编码

### 扩展能力矩阵

```mermaid
flowchart TB
    subgraph Extension["🔧 扩展能力层"]
        A["🔌 插件扩展<br/>plugin基类"]
        B["🌊 工作流扩展<br/>AIStream基类"]
        C["📡 Tasker扩展<br/>协议适配器"]
        D["📢 事件监听器扩展<br/>EventListenerBase基类"]
        E["🌐 HTTP API扩展<br/>HttpApi基类"]
        F["🎨 渲染器扩展<br/>Renderer基类"]
        G["⚙️ 配置扩展<br/>ConfigBase基类"]
    end
    
    subgraph Infrastructure["🏗️ 基础设施层"]
        I["📦 基类库"]
        J["📚 加载器<br/>自动发现与加载"]
        K["🛠️ 工具类"]
    end
    
    Extension --> Infrastructure
    Infrastructure --> Extension
    
    style Extension fill:#E3F2FD,stroke:#1976D2,stroke-width:2px
    style Infrastructure fill:#E8F5E9,stroke:#388E3C,stroke-width:2px
    style A fill:#F3E5F5,stroke:#7B1FA2,stroke-width:2px
    style B fill:#E8F5E9,stroke:#388E3C,stroke-width:2px
    style C fill:#E1F5FE,stroke:#0277BD,stroke-width:2px
    style D fill:#FCE4EC,stroke:#C2185B,stroke-width:2px
    style E fill:#FFF3E0,stroke:#F57C00,stroke-width:2px
    style F fill:#E0F2F1,stroke:#00695C,stroke-width:2px
    style G fill:#F1F8E9,stroke:#558B2F,stroke-width:2px
```

---

## Core 模块开发

> **Core开发时代**：现在所有业务都在 `core/` 目录下开发，每个 core 是一个独立的业务模块。core 根目录不再直接写业务代码，而是通过业务目录（如 `plugin/`、`tasker/` 等）来组织代码，方便业务分割和集成。

### Core 模块的核心概念

**什么是 Core 模块？**
- Core 模块是框架的业务单元，每个 core 代表一个独立的功能模块
- 所有业务代码都放在 `core/{coreName}/` 目录下，通过业务目录组织
- 框架会自动扫描所有 core 目录，统一加载所有资源
- 不同 core 的资源可以相互使用（如 core A 的 plugin 可以使用 core B 的 tasker）

**为什么使用 Core 模块？**
- ✅ **业务分割**：每个 core 专注于特定业务领域，代码组织清晰
- ✅ **独立依赖**：每个 core 可以有自己的 `package.json`，管理独立依赖
- ✅ **易于集成**：新功能可以作为新 core 开发，不影响现有代码
- ✅ **便于维护**：业务逻辑集中在 core 目录，易于定位和修改

### 创建 Core 模块的完整流程

#### 1. 创建 Core 目录结构

```
core/
└── my-core/              # 你的 core 模块名称
    ├── plugin/           # 业务插件目录（可选）
    │   └── my-plugin.js  # 插件文件
    ├── tasker/           # 任务层目录（可选）
    │   └── MyTasker.js   # Tasker文件
    ├── events/           # 事件监听器目录（可选）
    │   └── my-listener.js
    ├── http/             # HTTP API目录（可选）
    │   └── my-api.js
    ├── stream/           # AI 工作流目录（可选）
    │   └── my-workflow.js
    ├── commonconfig/     # 配置管理目录（可选，仅当需要配置文件时使用）
    │   └── my-config.js   # 继承ConfigBase的配置类
    ├── www/              # 静态资源目录（可选）
    │   └── my-app/       # ⚠️ 必须创建子目录，挂载到 /my-app/*
    │       ├── index.html
    │       └── app.js
    └── package.json      # 该 core 的依赖配置（可选）
```

#### 2. 业务目录说明

| 目录 | 用途 | 基类 | 是否必需 | 说明 |
|------|------|------|---------|------|
| `plugin/` | 业务插件 | `plugin.js` | 可选 | 处理消息事件、定时任务等 |
| `tasker/` | 任务层 | - | 可选 | 协议适配器，生成统一事件 |
| `events/` | 事件监听器 | `EventListenerBase`（`listener/base.js`） | 可选 | 监听事件，去重后分发到插件 |
| `http/` | HTTP API | `http.js`（`HttpApi`） | 可选 | REST API 和 WebSocket |
| `stream/` | AI 工作流 | `AIStream.js` | 可选 | AI 工作流实现 |
| `commonconfig/` | 配置管理 | `ConfigBase` | 可选 | ⚠️ 仅当需要配置文件时使用 |
| `www/` | 静态资源 | - | 可选 | ⚠️ 必须创建子目录，避免路径冲突 |

#### 3. 关键注意事项

**www 目录规则**：
- ⚠️ **必须创建子目录**：不要在 `www/` 下直接放置文件
- 子目录自动挂载到 `/<目录名>/*`（如 `www/my-app/` 挂载到 `/my-app/*`）
- 避免与根目录 `www/` 和系统保留路径（`/api`、`/core`、`/media` 等）冲突

**Core 下子客户端 / 子服务端项目存放约定（重要）**：
- 每个 `core/{coreName}/` 是一个业务单元容器，除了 `plugin/`、`http/`、`stream/` 等框架约定目录外，可以在该 core 下维护与本 core 业务强相关的**子客户端 / 子服务端项目**，例如：
  - `core/my-core/www/xrk/`：通过 XRK-AGT 内置 Web 服务直接挂载的 Web 客户端（推荐用于需要由 AGT 直接提供静态资源的场景）
  - `core/my-core/miniprogram/`：与本 core 业务相关、但独立于 AGT Web 服务的微信小程序项目
  - `core/my-core/desktop-client/`、`core/my-core/electron-app/` 等：桌面端 / Electron 客户端代码
- **`www/` 不是唯一合法客户端目录**：
  - `www/` 仅用于“需要由 XRK-AGT 进程直接托管的静态资源”
  - 其他类型的客户端（如小程序、独立 Web 项目、桌面客户端等）可以放在 Core 自己约定的子目录下，只要不与框架保留目录（`plugin/`、`stream/`、`events/`、`tasker/`、`commonconfig/` 等）冲突即可
- 对于这类**独立子项目**，推荐做法：
  - 子项目自身可以是一个完整工程（自带 `package.json`、`project.config.json` 等），但默认不会被 XRK-AGT 当作 Node 包自动加载
  - 建议在子项目根目录添加独立 `.gitignore`，忽略：
    - 构建产物目录（如 `dist/`、`build/` 等）
    - 依赖目录（如 `node_modules/`、`miniprogram_npm/` 等）
    - IDE / 工具缓存（如 `.vscode/`、`.idea/` 等）
  - 这样既能保证 **Core 业务与子项目逻辑同仓管理**，又不会把不必要的构建/依赖文件提交到 XRK-AGT 主仓库

**commonconfig 使用规则**：
- ⚠️ **仅当需要配置文件时使用**：不是所有 core 都需要配置
- 配置类必须继承 `ConfigBase` 基类
- 配置文件存储在 `data/server_bots/{port}/` 目录

**导入路径规范（简化规则）**：
- 对于 **不自带 `package.json` 的 core 模块**（如 `system-Core`）：推荐使用根包定义的 `#` 别名，代码更简洁：
  - 可用别名：`#infrastructure/*`、`#utils/*`、`#factory/*`、`#config/*`、`#data/*`、`#core/*`
- 对于 **自带 `package.json` 的独立 core 包**：必须使用 **相对路径** 访问 `src/*` 等其他包内代码，避免出现 `ERR_PACKAGE_IMPORT_NOT_DEFINED`，详细示例请参考《导入路径迁移指南》。

#### 4. package.json 支持（可选）

每个 core 目录可以有自己的 `package.json` 来管理独立依赖：

```json
{
  "name": "my-core",
  "version": "1.0.0",
  "private": true,
  "dependencies": {
    "my-special-package": "^1.0.0"
  }
}
```

**特性**：
- ✅ 在项目根目录执行 `pnpm install` 时，会自动安装所有 core 的依赖
- ✅ 框架使用 pnpm workspace，core 目录已自动加入 workspace
- ✅ 每个 core 的依赖相互独立，互不影响
- ✅ 如果 core 没有 `package.json`，则不会处理依赖安装

#### 5. 跨 Core 资源共享

所有 core 的资源都可以被其他 core 使用：
- core A 的 plugin 可以使用 core B 的 tasker
- core C 的 http API 可以调用 core D 的 stream
- 框架会自动扫描所有 core 目录，统一加载所有资源

**示例**：
```javascript
// core/my-core/plugin/my-plugin.js
// 可以使用其他 core 的资源
import StreamLoader from '#infrastructure/aistream/loader.js';

// 获取其他 core 的工作流
const chatStream = StreamLoader.getStream('chat'); // 来自 system-Core
await chatStream.process(e, question);
```

### Core 开发最佳实践

#### 1. 业务分割原则

- **单一职责**：每个 core 专注于一个业务领域
- **独立开发**：core 之间尽量解耦，通过标准接口交互
- **可复用性**：公共功能放在 `system-Core`，业务功能放在自己的 core

#### 2. 目录组织建议

```
core/
├── system-Core/          # 系统核心功能（框架自带）
├── business-Core/        # 业务功能 core
├── integration-Core/     # 第三方集成 core
└── custom-Core/          # 自定义功能 core
```

#### 3. 开发新 Core 的完整流程

**步骤1：确定 Core 的业务范围**
- 明确这个 core 要解决什么问题（例如：用户管理、数据分析、第三方集成等）
- 确定需要哪些业务目录（`plugin/`、`http/`、`stream/` 等）
- 考虑是否需要配置文件（决定是否创建 `commonconfig/`）

**步骤2：创建 Core 目录结构**
```bash
# 创建 core 目录
mkdir -p core/my-business-core

# 根据需求创建业务目录
mkdir -p core/my-business-core/plugin
mkdir -p core/my-business-core/http
# ... 其他业务目录
```

**步骤3：编写业务代码**
- 继承对应基类（`plugin`、`HttpApi`、`AIStream` 等）
- 使用别名路径（`#` 前缀）导入框架模块
- 实现业务逻辑

**步骤4：配置依赖**（可选）
- 如果需要特殊依赖，创建 `package.json`
- 执行 `pnpm install` 安装依赖

**步骤5：测试验证**
- 重启服务，框架会自动加载新 core
- 验证功能是否正常

#### 4. Core 开发示例：创建一个完整的业务 Core

**场景**：创建一个"用户管理"业务 Core

**目录结构**：
```
core/user-management-core/
├── plugin/
│   ├── user-plugin.js      # 用户相关插件
│   └── admin-plugin.js     # 管理员插件
├── http/
│   └── user-api.js         # 用户管理API
├── stream/
│   └── user-chat.js        # 用户聊天工作流
├── commonconfig/
│   └── user-config.js      # 用户配置（继承ConfigBase）
└── package.json            # 依赖配置
```

**代码示例**：
```javascript
// core/user-management-core/plugin/user-plugin.js
import plugin from '#infrastructure/plugins/plugin.js';

export default class UserPlugin extends plugin {
  constructor() {
    super({
      name: '用户管理插件',
      event: 'message',
      priority: 5000,
      rule: [
        { reg: '^#用户信息$', fnc: 'getUserInfo' }
      ]
    });
  }

  async getUserInfo(e) {
    // 业务逻辑
    await this.reply('用户信息...');
  }
}
```

#### 5. AI 开发新 Core 时的关键理解点

**对于 AI 开发者，理解以下要点很重要**：

1. **Core 是业务单元**：每个 core 代表一个独立的业务领域（如用户管理、数据分析、第三方集成），不是技术模块。按业务领域划分，不是按技术类型。

2. **业务目录组织**：core 根目录下通过业务目录（`plugin/`、`http/`、`stream/` 等）组织代码。每个业务目录对应一种扩展类型，所有同类型的扩展都放在同一个目录下。

3. **基类继承模式**：所有业务代码都继承对应基类：
   - `plugin/` → 继承 `plugin` 基类
   - `http/` → 继承 `HttpApi` 基类
   - `stream/` → 继承 `AIStream` 基类
   - `events/` → 继承 `EventListenerBase` 基类（`#infrastructure/listener/base.js`）
   - `commonconfig/` → 继承 `ConfigBase` 基类

4. **自动加载机制**：框架自动扫描所有 `core/*/业务目录/` 下的文件，无需手动注册。只要文件放在正确位置，就会被自动加载。

5. **跨 Core 资源共享**：不同 core 的资源可以相互使用。例如：
   - core A 的 plugin 可以调用 core B 的 stream
   - core C 的 http API 可以使用 core D 的 tasker
   - 通过加载器（如 `StreamLoader.getStream()`）获取其他 core 的资源

6. **独立依赖管理**：每个 core 可以有自己的 `package.json`，管理独立依赖。执行 `pnpm install` 时自动安装所有 core 的依赖。

7. **配置管理规则**：只有需要配置文件的 core 才创建 `commonconfig/` 目录。配置类必须继承 `ConfigBase` 基类。

8. **静态资源规则**：`www/` 目录必须创建子目录（如 `www/my-app/`），子目录自动挂载到 `/<目录名>/*`。不要在 `www/` 下直接放置文件，避免与根目录 `www/` 冲突。

9. **导入路径规范（统一口径）**：根包通过 `package.json.imports` 提供 `#infrastructure/*`、`#utils/*` 等别名，供不带 `package.json` 的 core 直接使用；自带 `package.json` 的独立 core 则必须使用相对路径访问 `src/*` 等其他包内代码，更多示例见《导入路径迁移指南》。

10. **开发流程**：确定业务范围 → 创建目录结构 → 继承基类编写代码 → 配置依赖（可选） → 测试验证

#### 导入路径规范

在 **不自带 `package.json` 的 core 模块** 中，推荐使用根包提供的 `#` 别名来导入框架模块，代码更清晰：

**✅ 推荐示例**：
```javascript
import ConfigBase from '#infrastructure/commonconfig/commonconfig.js';
import BotUtil from '#utils/botutil.js';
import StreamLoader from '#infrastructure/aistream/loader.js';
import { HttpResponse } from '#utils/http-utils.js';
```

在 **自带 `package.json` 的独立 core 包** 中，由于 Node 解析 `imports` 只在当前包生效，访问 `src/*` 等主包代码时必须使用相对路径（否则会报 `ERR_PACKAGE_IMPORT_NOT_DEFINED`），具体写法请直接参考《导入路径迁移指南》中的相对路径示例。

---

## 核心扩展点

### 1. 插件系统扩展

**基类位置**: `src/infrastructure/plugins/plugin.js`

**扩展能力**:
- ✅ 消息处理（规则匹配、权限控制）
- ✅ 定时任务（cron表达式）
- ✅ 事件订阅（跨平台事件监听）
- ✅ 上下文管理（会话状态）
- ✅ 工作流集成（AIStream调用）

**扩展流程图**:

```mermaid
flowchart TB
    A["创建插件类<br/>继承plugin"] --> B["定义构造函数<br/>配置name/event/priority"]
    B --> C["实现accept方法<br/>前置检查"]
    C --> D["定义rule规则<br/>消息匹配"]
    D --> E["实现处理方法<br/>业务逻辑"]
    E --> F["可选：定时任务<br/>task配置"]
    F --> G["可选：事件订阅<br/>eventSubscribe"]
    G --> H["放置到core/*/plugin/<br/>自动加载"]
    
    style A fill:#E6F3FF
    style H fill:#90EE90
```

**关键扩展点**:

1. **规则匹配系统**
   ```javascript
   // 支持多种规则格式
   rule: [
     { reg: '^#测试$', fnc: 'test' },           // 正则匹配
     { reg: /^#命令$/, fnc: 'command' },       // 正则对象
     { reg: '^#复杂', fnc: 'complex', priority: 100 }  // 带优先级
   ]
   ```

2. **事件订阅系统**
   ```javascript
   // 跨平台事件监听
   eventSubscribe: [
     { eventType: 'message', handler: this.handleMessage },
     { eventType: 'onebot.*', handler: this.handleOneBot },
     { eventType: 'device.notice', handler: this.handleDevice }
   ]
   ```

3. **上下文管理**
   ```javascript
   // 设置上下文
   this.setContext('type', isGroup, time);
   
   // 获取上下文
   const ctx = this.getContext('type', isGroup);
   
   // 结束上下文
   this.finish('type', isGroup);
   ```

### 2. 工作流系统扩展

**基类位置**: `src/infrastructure/aistream/aistream.js`

**扩展能力**:
- ✅ 自定义工作流（继承AIStream）
- ✅ 函数注册（Function Calling）
- ✅ Embedding提供商扩展
- ✅ 工作流合并（功能组合）
- ✅ 动态Prompt生成

**扩展流程图**:

```mermaid
flowchart TB
    A["创建AIStream子类"] --> B["配置基础信息<br/>name/description/priority"]
    B --> C["配置AI参数<br/>temperature/maxTokens"]
    C --> D["配置Embedding<br/>enabled（mode自动从cfg读取）"]
    D --> E["实现init方法<br/>注册函数"]
    E --> F["可选：实现buildSystemPrompt<br/>构建系统提示"]
    F --> G["可选：实现buildChatContext<br/>构建上下文"]
    G --> H["注册MCP工具<br/>registerMCPTool"]
    H --> I["放置到core/*/stream/<br/>自动加载"]
    
    style A fill:#E6F3FF
    style I fill:#90EE90
```

**关键扩展点**:

1. **MCP工具注册系统**
   ```javascript
   // 统一使用registerMCPTool注册，所有工具都返回标准JSON格式
   this.registerMCPTool('my_function', {
     description: '功能描述',
     inputSchema: {
       type: 'object',
       properties: {
         param1: { type: 'string', description: '参数1' }
       },
       required: ['param1']
     },
     handler: async (args = {}, context = {}) => {
       // 执行逻辑
       return { success: true, data: { result: '...' } };
     },
     enabled: true
   });
   ```

2. **Embedding提供商扩展**
   ```javascript
   // 支持多种提供商
   embedding: {
     enabled: true,
     // embedding 配置自动从 cfg 读取，无需手动指定
   }
   ```

3. **工作流合并**
   ```javascript
   // 自动合并辅助工作流
   await stream.process(e, question, {
     mergeStreams: ['desktop', 'memory'],
     // 复杂多步任务请使用 Python 子服务端（LangChain/LangGraph）
     enableMemory: true
   });
   ```

### 3. Tasker扩展

**扩展位置**: `core/*/tasker/`

> **注意**：框架支持多 core 模块架构，每个 core 是一个独立的模块。所有 core 目录下的资源都会被自动扫描和加载，并且可以跨 core 使用。

**扩展能力**:
- ✅ 协议适配器（新平台接入）
- ✅ 事件生成（统一事件模型）
- ✅ 对象封装（平台特定对象）

**扩展流程图**:

```mermaid
flowchart TB
    A["创建Tasker类"] --> B["定义基础属性<br/>id/name/path"]
    B --> C["实现load方法<br/>初始化连接"]
    C --> D["实现消息处理<br/>handleMessage"]
    D --> E["转换平台消息<br/>统一事件格式"]
    E --> F["触发Bot.em事件<br/>事件标准化"]
    F --> G["注册到Bot.tasker<br/>自动加载"]
    
    style A fill:#E6F3FF
    style G fill:#90EE90
```

**关键扩展点**:

1. **事件生成**
   ```javascript
   // 通过Bot.em触发标准化事件
   Bot.em('tasker.message', {
     event_id: `tasker_${Date.now()}`,
     tasker: 'mytasker',
     user_id: data.user_id,
     message: [{ type: 'text', text: data.text }]
   });
   ```

2. **对象封装**
   ```javascript
   // 通过增强插件挂载平台特定对象
   // 在enhancer插件中
   e.friend = Bot[self_id].pickFriend(user_id);
   e.group = Bot[self_id].pickGroup(group_id);
   ```

### 4. 事件监听器扩展

**基类位置**: `src/infrastructure/listener/base.js`（`EventListenerBase`）

**扩展能力**:
- ✅ 事件监听（跨平台事件）
- ✅ 事件预处理（去重、标记）
- ✅ 事件分发（调用PluginsLoader）

**扩展流程图**:

```mermaid
flowchart TB
    A["创建EventListenerBase子类"] --> B["定义监听事件<br/>eventTypes"]
    B --> C["实现handle方法<br/>事件处理"]
    C --> D["事件去重<br/>避免重复处理"]
    D --> E["事件标记<br/>添加元数据"]
    E --> F["调用PluginsLoader<br/>分发到插件"]
    F --> G["放置到core/*/events/<br/>自动加载"]
    
    style A fill:#E6F3FF
    style G fill:#90EE90
```

### 5. HTTP/API扩展

**基类位置**: `src/infrastructure/http/http.js`（`HttpApi` 基类）

**扩展能力**:
- ✅ REST API（路由注册）
- ✅ WebSocket（实时通信）
- ✅ 中间件（认证、日志等）

**扩展流程图**:

```mermaid
flowchart TB
    A["创建HttpApi子类"] --> B["定义路由<br/>registerRoutes"]
    B --> C["实现处理方法<br/>业务逻辑"]
    C --> D["注册WebSocket<br/>实时通信"]
    D --> E["配置中间件<br/>认证/日志"]
    E --> F["放置到core/*/http/<br/>自动加载"]
    
    style A fill:#E6F3FF
    style F fill:#90EE90
```

### 6. 渲染器扩展

**基类位置**: `src/infrastructure/renderer/Renderer.js`

**扩展能力**:
- ✅ 模板渲染（HTML模板）
- ✅ 图片生成（Puppeteer/Playwright）
- ✅ 文件监听（自动重载）

**扩展流程图**:

```mermaid
flowchart TB
    A["创建Renderer子类"] --> B["配置渲染器<br/>id/type/render"]
    B --> C["实现渲染方法<br/>renderImage/renderHTML"]
    C --> D["模板处理<br/>dealTpl"]
    D --> E["文件监听<br/>watch"]
    E --> F["注册到Bot.renderer<br/>自动加载"]
    
    style A fill:#E6F3FF
    style F fill:#90EE90
```

### 7. 配置系统扩展

**基类位置**: `src/infrastructure/commonconfig/commonconfig.js`（`ConfigBase` 基类）

**扩展目录**: `core/*/commonconfig/`（存放继承 `ConfigBase` 的配置类）

**重要说明**：
- ⚠️ **仅当需要配置文件时使用**：只有需要配置文件的 core 才创建 `commonconfig/` 目录，不是所有 core 都需要
- `commonconfig` 是目录名，用于存放配置管理类
- 真正的基类是 `ConfigBase`（位于 `src/infrastructure/commonconfig/commonconfig.js`）
- 配置类需要继承 `ConfigBase` 并实现配置元数据

**扩展能力**:
- ✅ 配置文件管理（YAML/JSON）
- ✅ 动态路径（函数式路径）
- ✅ 配置验证（Schema验证）
- ✅ 配置备份（自动备份）
- ✅ 多文件配置（一个配置包含多个子文件）

**扩展流程图**:

```mermaid
flowchart TB
    A["创建ConfigBase子类"] --> B["定义配置元数据<br/>name/displayName"]
    B --> C["定义文件路径<br/>filePath静态或动态"]
    C --> D["定义Schema<br/>配置结构验证"]
    D --> E["实现read/write<br/>读写配置"]
    E --> F["自动验证<br/>Schema校验"]
    
    style A fill:#E6F3FF
    style F fill:#90EE90
```

---

## 插件系统扩展

**详细文档**：参考 [`docs/plugin-base.md`](plugin-base.md) 和 [`docs/plugins-loader.md`](plugins-loader.md)

### 快速示例

#### 1. 规则匹配系统

支持多种规则格式，灵活匹配消息：

```javascript
rule: [
  // 字符串正则
  { reg: '^#测试$', fnc: 'test' },
  
  // 正则对象
  { reg: /^#命令\d+$/, fnc: 'command' },
  
  // 带优先级
  { reg: '^#重要', fnc: 'important', priority: 1 },
  
  // 带权限检查
  { reg: '^#管理员', fnc: 'admin', permission: 'master' }
]
```

#### 2. 上下文管理

支持会话状态管理：

```javascript
// 设置上下文（30秒有效）
this.setContext('waiting_input', e.isGroup, 30);

// 获取上下文
const ctx = this.getContext('waiting_input', e.isGroup);
if (ctx) {
  // 处理上下文相关逻辑
  this.finish('waiting_input', e.isGroup);
}
```

#### 3. 工作流集成

插件可以无缝调用工作流：

```javascript
// 获取工作流
const stream = StreamLoader.getStream('chat');

// 调用工作流
await stream.process(e, question, {
  mergeStreams: ['desktop'],
  enableMemory: true,
  enableDatabase: true
});
```

---

## 工作流系统扩展

### 完整扩展示例

```javascript
import AIStream from '#infrastructure/aistream/aistream.js';
import BotUtil from '#utils/botutil.js';

export default class MyWorkflow extends AIStream {
  constructor() {
    super({
      name: 'my-workflow',
      description: '我的自定义工作流',
      version: '1.0.0',
      author: 'YourName',
      priority: 100,
      
      // AI配置
      config: {
        enabled: true,
        temperature: 0.7,
        maxTokens: 4000
      },
      
      // Embedding配置
      embedding: {
        enabled: true
        // embedding 配置自动从 cfg 读取，无需手动指定
        // 注意：initEmbedding() 会在 StreamLoader 统一调用，无需在 init() 中手动调用
      }
    });
  }

  async init() {
    await super.init();
    // 注意：initEmbedding() 会在 StreamLoader 统一调用，无需手动调用
    this.registerAllFunctions();
    BotUtil.makeLog('info', `[${this.name}] 工作流已初始化`, 'MyWorkflow');
  }

  registerAllFunctions() {
    // 注册MCP工具（统一工具注册方式）
    this.registerMCPTool('my_function', {
      description: '我的功能',
      inputSchema: {
        type: 'object',
        properties: {
          param: {
            type: 'string',
            description: '功能参数'
          }
        },
        required: ['param']
      },
      handler: async (args = {}, context = {}) => {
        const { param } = args;
        // 处理逻辑
        const result = await this.doMyFunction(param);
        return { success: true, data: { result } };
      },
      enabled: true
    });
  }

  // 可选实现：构建系统提示词（如果未实现，基类返回空字符串）
  buildSystemPrompt(context) {
    return `【人设】
你是一个智能助手。

【工具说明】
所有功能都通过MCP工具调用协议提供，包括：my_function等。

【执行规则】
1. 规则1
2. 规则2`;
  }

  // 可选实现：构建聊天上下文（如果未实现，基类返回空数组）
  async buildChatContext(e, question) {
    const messages = [];
    
    // 添加系统提示词
    const systemPrompt = this.buildSystemPrompt({ e, question });
    if (systemPrompt) {
      messages.push({
        role: 'system',
        content: systemPrompt
      });
    }
    
    // 添加用户消息
    const questionText = typeof question === 'string' 
      ? question 
      : (question?.content || question?.text || '');
    
    messages.push({
      role: 'user',
      content: questionText
    });
    
    return messages;
  }

  getDynamicInfo() {
    // 动态获取信息
    return '实时信息';
  }
}
```

### 扩展点详解

#### 1. Embedding配置

Embedding 配置自动从 `cfg.aistream.embedding` 读取，工作流只需设置 `enabled`：

```javascript
// Embedding 配置
embedding: {
  enabled: true,  // 是否启用向量检索
  maxContexts: 5  // 最大上下文条数（工作流级别配置）
  // 注意：向量服务统一由子服务端提供，向量模型、维度等配置在子服务端配置文件中设置
  // 子服务端配置：data/subserver/config.yaml
}

// 注意：向量服务通过子服务端提供，无需在 init() 中手动初始化
```

#### 2. 工作流合并机制

支持工作流功能合并，通过 `process` 方法的 `options` 参数控制：

```javascript
// 主工作流
const mainStream = StreamLoader.getStream('chat');

// 合并辅助工作流（推荐方式）
await mainStream.process(e, question, {
  mergeStreams: ['desktop', 'tools'],  // 合并指定工作流
  enableMemory: true,                   // 启用记忆系统（自动合并memory stream）
  enableDatabase: true                 // 启用知识库（自动合并database stream）
});

// 合并后的工作流：
// - 包含所有工作流的函数（副工作流函数自动加前缀）
// - 保留主工作流的人设和上下文（buildSystemPrompt、buildChatContext）
// - 使用合并后的名称作为记忆键（如 chat-desktop-tools）
```

**自动合并机制**：
- `enableMemory: true` 会自动合并 `memory` stream
- `enableDatabase: true` 会自动合并 `database` stream
- 合并后的工作流有独立的记忆系统（使用合并后的名称）

---

## Tasker扩展

**详细文档**：参考 [`docs/tasker-base-spec.md`](tasker-base-spec.md)、[`docs/tasker-loader.md`](tasker-loader.md)

### 快速示例

#### 1. 事件生成

Tasker需要将平台消息转换为统一事件格式：

```javascript
Bot.em('tasker.message', {
  // 基础字段（必填）
  event_id: string,      // 事件ID
  tasker: string,        // Tasker类型
  tasker_id: string,     // Tasker ID
  tasker_name: string,   // Tasker名称
  user_id: string,       // 用户ID
  message: Array,        // 消息数组
  raw_message: string,   // 原始消息
  time: number,          // 时间戳
  bot: BotInstance,      // Bot实例
  reply: Function,       // 回复方法
  
  // 可选字段
  sender: Object,        // 发送者信息
  group_id: string,     // 群组ID（群消息时）
  // ... 其他平台特定字段
});
```

#### 2. 增强插件

平台特定对象通过增强插件挂载：

```javascript
// core/my-core/plugin/MyTaskerEnhancer.js
export default class MyTaskerEnhancer extends plugin {
  constructor() {
    super({
      name: 'MyTasker增强插件',
      event: 'mytasker.message',
      priority: 1
    });
  }

  async accept(e) {
    // 挂载平台特定对象
    e.friend = this.getFriend(e.user_id);
    e.group = this.getGroup(e.group_id);
    e.isGroup = !!e.group_id;
    e.isPrivate = !e.isGroup;
    
    return true;
  }
}
```

---

## 事件系统扩展

### 完整扩展示例

```javascript
import EventListenerBase from '#infrastructure/listener/base.js';

export default class MyEventListener extends EventListenerBase {
  constructor() {
    super({
      name: 'MyEventListener',
      eventTypes: ['mytasker.message', 'mytasker.notice']
    });
  }

  async handle(e) {
    // 事件去重
    if (this.isDuplicate(e)) {
      return;
    }

    // 事件标记
    e.processed = true;
    e.processedBy = this.name;

    // 分发到插件
    await PluginsLoader.deal(e);
  }

  isDuplicate(e) {
    // 实现去重逻辑
    const key = `${e.tasker}_${e.event_id}`;
    if (this.processedEvents.has(key)) {
      return true;
    }
    this.processedEvents.set(key, Date.now());
    return false;
  }
}
```

---

## HTTP/API扩展

**详细文档**：参考 [`docs/http-api.md`](http-api.md)、[`docs/api-loader.md`](api-loader.md)

### 快速示例

---

## 渲染器扩展

### 完整扩展示例

```javascript
import Renderer from '#infrastructure/renderer/Renderer.js';

export default class MyRenderer extends Renderer {
  constructor() {
    super({
      id: 'my-renderer',
      type: 'image',
      render: 'renderImage'
    });
  }

  async renderImage(data) {
    // 处理模板
    const htmlPath = await this.dealTpl('my-template', {
      tplFile: 'resources/html/my-template.html',
      data: data
    });

    // 使用Puppeteer/Playwright渲染
    const imagePath = await this.renderWithPuppeteer(htmlPath);
    
    return imagePath;
  }
}
```

---

## 配置系统扩展

**详细文档**：参考 [`docs/config-base.md`](config-base.md)

### 快速示例

### 多文件配置（高级特性）

当配置需要按类型拆分为多个文件时（如渲染器配置包含 puppeteer 和 playwright），可以使用 `multiFile` 特性。详细说明请参考 [`docs/config-base.md`](config-base.md)。

---

---

## 最佳实践

> 本节提供扩展开发的最佳实践和代码质量规范，帮助开发者编写高质量、易维护的扩展代码。

### 1. 核心设计原则

#### 基础设施与业务分离

**原则**：基础设施层提供通用能力，业务层专注具体实现。

**实践**：
- ✅ 所有业务代码放在 `core/*/` 目录下
- ✅ 基础设施代码放在 `src/infrastructure/` 目录下
- ❌ 不要在 `src/` 下写业务逻辑

#### 基类抽象

**原则**：所有功能都基于基类，通过继承快速扩展。

**实践**：
- ✅ 继承对应的基类（`plugin`、`AIStream`、`HttpApi` 等）
- ✅ 实现必要的方法
- ❌ 不要直接修改基类代码

#### 自动加载机制

**原则**：通过加载器自动发现和加载扩展。

**实践**：
- ✅ 放置到约定目录即可自动加载
- ✅ 遵循命名规范
- ❌ 不要手动注册扩展

#### 标准化接口

**原则**：统一的接口规范，易于集成和维护。

**实践**：
- ✅ 遵循基类定义的接口
- ✅ 使用统一的命名规范
- ❌ 不要创建自定义接口

#### 无特化逻辑

**原则**：底层代码不包含任何针对特定业务场景的硬编码。

**实践**：
- ✅ 使用配置和参数化
- ✅ 通过扩展点实现特化逻辑
- ❌ 不要在基础设施层写业务逻辑

### 2. 扩展开发流程

```mermaid
flowchart TB
    A["确定扩展类型"] --> B["选择对应基类"]
    B --> C["阅读基类文档"]
    C --> D["实现必要方法"]
    D --> E["测试扩展功能"]
    E --> F["放置到对应目录"]
    F --> G["自动加载生效"]
    
    style A fill:#E6F3FF
    style G fill:#90EE90
```

### 3. 代码质量规范

#### 命名规范

- **插件/工作流/Tasker**：使用 PascalCase（如 `MyPlugin`）
- **HTTP API**：使用 kebab-case（如 `my-api.js`）
- **配置文件**：使用 kebab-case（如 `my-config.yaml`）

#### 错误处理

```javascript
// ✅ 正确：使用 try-catch
async test(e) {
  try {
    const result = await someAsyncOperation();
    this.reply(result, false, e);
  } catch (error) {
    Bot.makeLog('error', `插件执行失败: ${error.message}`);
  }
}

// ❌ 错误：不处理错误
async test(e) {
  const result = await someAsyncOperation(); // 可能抛出错误
  this.reply(result, false, e);
}
```

#### 状态管理

```javascript
// ✅ 正确：使用模块级变量或 init() 方法
let state = {}; // 模块级变量

export default class MyPlugin extends plugin {
  async init() {
    // 在 init() 中初始化状态
    this.state = {};
  }
}

// ❌ 错误：在 constructor 中定义状态变量
export default class MyPlugin extends plugin {
  constructor() {
    super({...});
    this.state = {}; // 会被刷新
  }
}
```

#### 依赖管理

```javascript
// ✅ 正确：使用 # 别名导入
import BotUtil from '#utils/botutil.js';
import AIStream from '#infrastructure/aistream/aistream.js';

// ❌ 错误：使用相对路径（在根目录代码中）
import BotUtil from '../../../src/utils/botutil.js';
```

#### 性能优化

- ✅ 使用缓存避免重复计算
- ✅ 使用批量操作减少 I/O
- ✅ 避免不必要的异步操作
- ❌ 不要在循环中进行异步操作

### 4. 扩展命名规范

> **注意**：框架支持多 core 模块架构。每个 core 是一个独立的模块，可以包含所有类型的扩展。

- **插件**: `core/{coreName}/plugin/my-plugin.js` (如 `core/my-core/plugin/my-plugin.js`)
- **工作流**: `core/{coreName}/stream/my-workflow.js`
- **Tasker**: `core/{coreName}/tasker/MyTasker.js`
- **事件监听器**: `core/{coreName}/events/my-listener.js`
- **HTTP API**: `core/{coreName}/http/my-api.js`
- **配置**: `core/{coreName}/commonconfig/my-config.js`（继承 `ConfigBase` 基类，仅当需要配置文件时使用）
- **静态资源**: `core/{coreName}/www/` 
  - ⚠️ **必须创建子目录**：不要在 `www/` 下直接放置文件，必须创建子目录（如 `www/xrk/`）
  - 子目录自动挂载到 `/<目录名>/*`（如 `www/xrk/` 挂载到 `/xrk/*`），避免与根目录 `www/` 冲突
- **渲染器**: `src/renderers/my-renderer.js` (渲染器仍在 `src/renderers/`)

### 5. 扩展优先级

- **插件**: `priority` 越小越先执行
- **工作流**: `priority` 越大优先级越高
- **规则匹配**: `priority` 越小越先匹配

### 6. 扩展测试

```javascript
// 测试插件
const plugin = new MyPlugin();
await plugin.init();
const result = await plugin.test(e);

// 测试工作流
const stream = StreamLoader.getStream('my-workflow');
const response = await stream.process(e, '测试消息');

// 测试API
const api = new MyAPI();
await api.registerRoutes(app);
```

### 7. 扩展调试

- 使用 `BotUtil.makeLog()` 记录日志
- 查看加载器统计信息
- 检查扩展是否正确注册
- 验证扩展方法是否被调用

---

## 扩展示例

### 示例1：完整插件扩展

```javascript
import plugin from '#infrastructure/plugins/plugin.js';
import StreamLoader from '#infrastructure/aistream/loader.js';

export default class CompletePlugin extends plugin {
  constructor() {
    super({
      name: '完整插件示例',
      event: 'message',
      priority: 5000,
      rule: [
        { reg: '^#测试$', fnc: 'test' },
        { reg: '^#工作流', fnc: 'workflow' }
      ],
      task: [
        {
          name: '定时任务',
          cron: '0 0 * * *',
          fnc: 'scheduledTask'
        }
      ],
      eventSubscribe: [
        { eventType: 'onebot.notice', handler: this.handleNotice }
      ]
    });
  }

  async accept(e) {
    // 权限检查
    if (e.user_id !== 'admin') {
      return false;
    }
    return true;
  }

  async test(e) {
    await this.reply('测试成功');
  }

  async workflow(e) {
    const stream = StreamLoader.getStream('chat');
    await stream.process(e, e.msg, {
      // 复杂多步任务请使用 Python 子服务端（LangChain/LangGraph）
    });
  }

  async scheduledTask() {
    BotUtil.makeLog('info', '定时任务执行', 'CompletePlugin');
  }

  async handleNotice(e) {
    // 处理通知事件
  }
}
```

### 示例2：完整工作流扩展

```javascript
import AIStream from '#infrastructure/aistream/aistream.js';

export default class CompleteWorkflow extends AIStream {
  constructor() {
    super({
      name: 'complete-workflow',
      description: '完整工作流示例',
      version: '1.0.0',
      priority: 100,
      config: {
        temperature: 0.7,
        maxTokens: 4000
      },
      embedding: {
        enabled: true
        // mode 和其他配置自动从 cfg.aistream.embedding 读取
        // 无需手动指定 mode、apiUrl、apiKey 等
        // 注意：initEmbedding() 会在 StreamLoader 统一调用，无需在 init() 中手动调用
      }
    });
  }

  async init() {
    await super.init();
    // 注意：initEmbedding() 会在 StreamLoader 统一调用，无需手动调用
    this.registerAllFunctions();
  }

  registerAllFunctions() {
    // 注册多个函数
    this.registerMCPTool('function1', { 
      description: '功能1',
      inputSchema: { type: 'object', properties: {}, required: [] },
      handler: async (args, context) => ({ success: true, data: {} })
    });
    this.registerMCPTool('function2', { 
      description: '功能2',
      inputSchema: { type: 'object', properties: {}, required: [] },
      handler: async (args, context) => ({ success: true, data: {} })
    });
  }

  buildSystemPrompt(context) {
    return `【人设】
你是一个智能助手。

【可用功能】
`;
  }

  async buildChatContext(e, question) {
    // 构建上下文
    return messages;
  }
}
```

---

## 扩展能力总结

### 扩展能力矩阵

| 扩展类型 | 基类位置 | 扩展目录 | 自动加载 | 优先级支持 | 热重载 |
|---------|---------|---------|---------|-----------|--------|
| 插件 | `plugin.js` | `core/*/plugin/` | ✅ | ✅ | ✅ |
| 工作流 | `aistream.js` | `core/*/stream/` | ✅ | ✅ | ✅ |
| Tasker | - | `core/*/tasker/` | ✅ | - | ✅ |
| 事件监听器 | `EventListenerBase`（`listener/base.js`） | `core/*/events/` | ✅ | ✅ | ✅ |
| HTTP API | `http.js`（`HttpApi`） | `core/*/http/` | ✅ | ✅ | ✅ |
| 配置 | `ConfigBase`（`commonconfig.js`） | `core/*/commonconfig/` | ✅ | - | ✅ |
| 静态资源 | - | `core/*/www/` | ✅ | - | - |
| 渲染器 | `Renderer.js` | `src/renderers/` | ✅ | - | ✅ |

> **注意**：`core/*/` 表示所有 core 目录。例如，`core/system-Core/plugin/` 和 `core/my-core/plugin/` 中的插件都会被自动加载。

### 扩展优势

1. **零配置扩展**：放置到对应目录即可自动加载
2. **标准化接口**：统一的基类和接口规范
3. **灵活组合**：支持功能合并和组合
4. **热重载支持**：修改代码后自动重载
5. **完整生命周期**：提供init、cleanup等生命周期钩子

---

## 相关文档

- **[AIStream 文档](aistream.md)** - AIStream基类完整API（Node 侧单次对话 + MCP 工具调用，复杂多步在 Python 子服务端）
- **[插件基类文档](plugin-base.md)** - 插件基类完整API
- **[项目概览](../PROJECT_OVERVIEW.md)** - 项目整体架构

---

## 总结

XRK-AGT框架通过**分层架构 + 基类设计 + 加载器机制**，实现了极高的可扩展性：

- ✅ **7大扩展点**：插件、工作流、Tasker、事件监听器、HTTP API、渲染器、配置
- ✅ **标准化接口**：统一的基类和接口规范
- ✅ **自动加载**：放置到对应目录即可自动加载
- ✅ **灵活组合**：支持功能合并和组合
- ✅ **完整生命周期**：提供init、cleanup等生命周期钩子

开发者可以通过继承基类、实现必要方法，快速扩展框架功能，无需修改底层代码。

### 常见问题

#### Q: 如何确保扩展的可维护性？

A: 
1. 遵循命名规范
2. 添加清晰的注释
3. 使用类型提示（JSDoc）
4. 编写测试用例
5. 遵循单一职责原则

#### Q: 如何提高扩展的性能？

A:
1. 使用缓存避免重复计算
2. 批量处理数据
3. 避免不必要的异步操作
4. 使用索引和优化查询

#### Q: 如何处理扩展之间的依赖？

A:
1. 使用事件系统进行解耦
2. 通过配置管理依赖关系
3. 使用依赖注入模式
4. 避免循环依赖
