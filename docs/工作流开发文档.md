# 工作流开发文档

> **注意**：本文档是工作流开发的补充文档，主要关注开发细节和代码示例。  
> **完整文档**：请参考 **[工作流系统完整文档](工作流系统完整文档.md)** - 包含系统概述、架构设计、执行流程等完整内容。

## 概述

工作流系统是一个智能化的多步骤任务执行框架，通过AI决策和执行，实现复杂任务的自动化处理。

### 核心概念

- **核心工作流**：提供主要功能（如 `desktop.js`、`chat.js`）
- **辅助工作流**：专门提供功能给其他工作流合并使用（如 `memory.js`、`database.js`、`todo.js`）

## 工作流原理

### 1. 架构设计

```
用户请求
  ↓
核心工作流 (desktop.js/chat.js)
  ↓
自动合并辅助工作流 (memory.js/database.js/todo.js)
  ↓
函数注册 (registerFunction)
  ↓
Prompt构建 (buildSystemPrompt + buildFunctionsPrompt)
  ↓
AI决策和执行
```

### 2. 合并机制

#### 2.1 函数合并

辅助工作流通过 `registerFunction` 注册功能，主工作流通过 `merge()` 方法合并：

```javascript
// 辅助工作流注册函数
this.registerFunction('save_knowledge', {
  prompt: () => `[保存知识:知识库名:内容] - 保存知识${getKnowledgePrompt()}`,
  handler: async (params, context) => { /* ... */ }
});

// 主工作流自动合并
stream.merge(auxiliaryStream);
```

#### 2.2 Prompt合并

- **buildSystemPrompt()**：只有主工作流的会被调用，构建系统提示词
- **buildFunctionsPrompt()**：收集所有已合并函数的 `prompt` 字段

**重要**：
- `buildSystemPrompt()` 和 `buildChatContext()` 是可选实现，如果未实现，基类会提供默认实现（不会抛出错误）
- 辅助工作流的 `buildSystemPrompt()` 在合并时不会被调用，只有函数的 `prompt` 字段会被合并

### 3. 动态Prompt机制

`registerFunction` 支持 `prompt` 为函数类型，用于动态生成包含实时信息的提示：

```javascript
// 静态prompt
prompt: `[保存知识:知识库名:内容] - 保存知识`

// 动态prompt（推荐）
prompt: () => {
  const databases = this.getDatabasesSync();
  return `[保存知识:知识库名:内容] - 保存知识\n可用知识库：${databases.join('、')}`;
}
```

### 4. 执行流程

#### 4.1 单步任务流程

```
1. 用户请求 → 核心工作流
2. 构建基础上下文：buildChatContext(e, question)
3. 增强上下文：buildEnhancedContext(e, question, baseMessages)
   - 检索历史对话（使用Embedding相似度）
   - 检索知识库（自动集成database stream）
   - 使用注意力机制优化上下文选择
4. 构建Prompt（buildSystemPrompt + buildFunctionsPrompt + 增强上下文）
5. AI决策 → 输出命令（如 [回桌面]）
6. 解析命令 → parseFunctions(response)
7. 执行函数 → executeFunctionsWithReAct（ReAct模式）
8. 存储到记忆系统 → storeMessageWithEmbedding
9. 返回结果 → 用户
```

#### 4.2 多步任务流程（TODO工作流）

```
1. 用户请求 → 核心工作流
2. AI判断是否需要多步 → 输出 [启动工作流:目标]
3. 任务分析助手 → 生成TODO列表
4. 工作流执行助手 → 逐步执行
   - 第1步：执行命令 → 记录笔记
   - 第2步：执行命令 → 记录笔记
   - ...
5. 完成 → 总结
```

## 模拟流程示例

### 场景1：简单任务（查询股票）

```
用户: "帮我查一下688270的股票"

流程:
1. desktop.js 接收请求
2. buildSystemPrompt() 构建系统提示
3. buildFunctionsPrompt() 收集所有函数prompt
4. AI输出: "[股票:688270]好的，我来帮你查询688270的股票行情"
5. 解析命令 → 执行股票查询函数
6. 返回结果给用户
```

### 场景2：复杂任务（查询股票并生成表格）

```
用户: "帮我查一下688270的股票，然后分析生成表格在桌面"

流程:
1. desktop.js 接收请求
2. AI输出: "[启动工作流:查询688270股票并生成表格]好的，我来帮你完成这个任务"
3. 任务分析助手分析任务 → 生成TODO列表
   - TODO 1: 查询688270股票的实时行情数据
   - TODO 2: 分析查询到的数据
   - TODO 3: 将分析后的数据生成Excel表格并保存到桌面
4. 工作流执行助手逐步执行
   - 执行第1步: [股票:688270] → 记录笔记
   - 执行第2步: 分析数据 → 记录笔记
   - 执行第3步: [生成Excel:股票分析.xlsx:数据] → 记录笔记
5. 完成 → 总结
```

### 场景3：使用知识库和记忆

```
用户: "帮我查询技术文档中关于JavaScript的内容，然后保存到记忆"

流程:
1. desktop.js 接收请求，自动合并 database.js 和 memory.js
2. buildFunctionsPrompt() 收集函数prompt，包含：
   - [查询知识:技术文档:JavaScript] - 可用知识库：技术文档、产品文档
   - [长期记忆:内容] - 当前记忆：#1: 用户喜欢TypeScript...
3. AI输出: "[查询知识:技术文档:JavaScript][长期记忆:JavaScript是一种编程语言]"
4. 执行查询知识库 → 执行保存记忆
5. 返回结果
```

## 开发文档

### 快速开始

#### 1. 调用工作流（简化方式）

```javascript
// xxx.js 示例
await stream.process(this.e, question, {
  mergeStreams: ['desktop'],
  enableTodo: true,        // 启用TODO工作流
  enableMemory: true,      // 启用记忆系统
  enableDatabase: true,    // 启用知识库
  // apiConfig 可选，会与 this.config 合并
  temperature: 0.8,
  maxTokens: 6000
});

// godai.js 示例
await chatStream.process(e, question, {
  enableMemory: true,      // 启用记忆系统
  enableDatabase: true,    // 启用知识库
  enableTodo: false        // 聊天场景不需要TODO工作流
});
```

#### 2. 参数说明

##### process 方法参数

**签名**：`async process(e, question, options = {})`

**参数**：
- `e`: 事件对象
- `question`: 用户问题（字符串或对象 `{content: string, text: string}`）
- `options`: 处理选项对象
  - `mergeStreams`: `Array<string>` - 要合并的工作流名称列表（如 `['desktop', 'tools']`）
  - `enableTodo`: `boolean` - 是否启用TODO智能决策（默认 `false`）
  - `enableMemory`: `boolean` - 是否启用记忆系统（默认 `false`）
  - `enableDatabase`: `boolean` - 是否启用知识库系统（默认 `false`）
  - `apiConfig`: `Object` - LLM配置（可选，会与 `this.config` 合并）
    - `temperature`: 温度参数
    - `maxTokens`: 最大token数
    - `provider`: LLM提供商（如 `'gptgod'`, `'volcengine'`）
    - 其他LLM参数

**返回值**：`Promise<string|null>` - AI回复文本

**执行流程**：
1. 自动合并辅助工作流（如果启用 `enableMemory` 或 `enableDatabase`）
2. 合并指定工作流（如果提供 `mergeStreams`）
3. 调用 `execute(e, question, apiConfig)` 执行工作流
4. 检查是否需要启动TODO工作流（如果启用 `enableTodo` 且AI输出了工作流命令）

##### execute 方法（底层方法）

**签名**：`async execute(e, question, config)`

**参数**：
- `e`: 事件对象（可选）
- `question`: 用户问题（字符串或对象）
- `config`: LLM配置对象（可选，会与 `this.config` 合并）

**执行流程**：
1. 构建基础上下文：`buildChatContext(e, question)`
2. 增强上下文：`buildEnhancedContext(e, question, baseMessages)` - 自动检索历史对话和知识库
3. 调用AI：`callAI(messages, config)`
4. 解析函数：`parseFunctions(response, context)`
5. 发送自然语言回复（如果有）
6. 执行函数：`executeFunctionsWithReAct(functions, context, question)` - 使用ReAct模式
7. 存储到记忆系统：`storeMessageWithEmbedding(groupId, message)`
8. 返回清洗后的文本 `cleanText`

**返回值**：`Promise<string|null>` - 清洗后的AI回复文本

### 创建新的辅助工作流

#### 步骤1：创建文件

```javascript
// core/stream/my-auxiliary.js
import AIStream from '#infrastructure/aistream/aistream.js';
import BotUtil from '#utils/botutil.js';

export default class MyAuxiliaryStream extends AIStream {
  constructor() {
    super({
      name: 'my-auxiliary',
      description: '我的辅助工作流',
      version: '1.0.0',
      author: 'XRK',
      priority: 1,  // 辅助工作流优先级较低
      config: {
        enabled: true,
        temperature: 0.7,
        maxTokens: 4000
      },
      embedding: { enabled: false }
    });
  }

  async init() {
    await super.init();
    this.registerAllFunctions();
    BotUtil.makeLog('info', `[${this.name}] 已初始化`, 'MyAuxiliaryStream');
  }

  registerAllFunctions() {
    // 动态获取辅助信息
    const getAuxiliaryInfo = () => {
      const info = this.getSomeInfo();
      return info ? `\n当前信息：${info}` : '';
    };

    // 注册函数（使用动态prompt）
    this.registerFunction('my_function', {
      description: '我的功能',
      prompt: () => `[我的功能:参数] - 功能描述${getAuxiliaryInfo()}`,
      parser: (text, context) => {
        const match = text.match(/\[我的功能:([^\]]+)\]/);
        if (!match) {
          return { functions: [], cleanText: text };
        }
        return {
          functions: [{ type: 'my_function', params: { param: match[1] } }],
          cleanText: text.replace(/\[我的功能:[^\]]+\]/g, '').trim()
        };
      },
      handler: async (params, context) => {
        const { param } = params || {};
        // 处理逻辑
        BotUtil.makeLog('info', `[${this.name}] 执行功能: ${param}`, 'MyAuxiliaryStream');
      },
      enabled: true
    });
  }

  /**
   * 构建系统提示（可选实现，辅助工作流合并时不会被调用）
   * 只有主工作流的buildSystemPrompt会被使用
   * 如果未实现，基类会返回空字符串
   */
  buildSystemPrompt(context) {
    return '我的辅助工作流插件，为其他工作流提供功能。';
  }

  /**
   * 构建聊天上下文（可选实现）
   * 如果未实现，基类会返回空数组
   */
  async buildChatContext(e, question) {
    return [];
  }

  async cleanup() {
    await super.cleanup();
  }
}
```

#### 步骤2：在主工作流中合并

```javascript
// core/plugin/example/xxx.js
async autoMergeAuxiliaryStreams() {
  const auxiliaryStreams = ['memory', 'database', 'todo', 'my-auxiliary'];
  
  for (const streamName of auxiliaryStreams) {
    try {
      const StreamClass = await this.loadAuxiliaryStreamClass(streamName);
      if (StreamClass) {
        const auxiliaryStream = new StreamClass();
        await auxiliaryStream.init();
        this.stream.merge(auxiliaryStream);
        BotUtil.makeLog('info', `[${this.name}] 已合并辅助工作流: ${streamName}`, 'Plugin');
      }
    } catch (error) {
      BotUtil.makeLog('error', `[${this.name}] 合并辅助工作流失败: ${streamName}`, 'Plugin');
    }
  }
}
```

### 创建新的核心工作流

```javascript
// core/stream/my-core.js
import AIStream from '#infrastructure/aistream/aistream.js';

export default class MyCoreStream extends AIStream {
  constructor() {
    super({
      name: 'my-core',
      description: '我的核心工作流',
      priority: 100,  // 核心工作流优先级较高
      config: {
        enabled: true,
        temperature: 0.8,
        maxTokens: 6000
      }
    });
  }

  async init() {
    await super.init();
    this.registerAllFunctions();
  }

  registerAllFunctions() {
    // 注册核心功能
    this.registerFunction('core_function', {
      description: '核心功能',
      prompt: `[核心功能:参数] - 核心功能描述`,
      // ...
    });
  }

  buildSystemPrompt(context) {
    // 构建系统提示词（主工作流）
    return `【人设】
你是一个智能助手。

【核心功能】
- [核心功能:参数] - 核心功能描述
`;
  }

  buildFunctionsPrompt() {
    // 收集所有函数的prompt（包括合并的辅助工作流）
    const enabledFuncs = this.getEnabledFunctions();
    const prompts = enabledFuncs
      .filter(f => f.prompt)
      .map(f => typeof f.prompt === 'function' ? f.prompt() : f.prompt);
    
    return `【可执行命令列表】
${prompts.join('\n')}`;
  }
}
```

## 业务逻辑

### 辅助工作流功能列表

#### 记忆系统 (memory.js)

- `[长期记忆:内容]` - 保存长期记忆
- `[查询记忆:关键词]` - 查询记忆
- `[删除记忆:序号]` - 删除记忆
- `[列出记忆]` - 列出所有记忆

**特性**：
- 支持按用户和场景分区
- 持久化存储到JSON文件
- 支持相似度搜索

#### 知识库系统 (database.js)

- `[保存知识:知识库名:内容]` - 保存知识到知识库
- `[查询知识:知识库名:关键词]` - 从知识库查询知识
- `[列出知识库]` - 列出所有知识库
- `[删除知识:知识库名:ID或条件]` - 从知识库删除知识

**特性**：
- 自动判断格式（文本/JSON）
- 关键词搜索
- 灵活删除（ID/条件）

#### TODO工作流 (todo.js)

通过 `enableTodo: true` 启用，系统会自动：
1. 判断任务是否需要多步工作流
2. 生成TODO列表
3. 逐步执行任务
4. 智能判断完成度

### 核心工作流功能

#### Desktop工作流 (desktop.js)

提供桌面操作、文件管理、系统操作等功能。

#### Chat工作流 (chat.js)

提供聊天互动、表情包、群管理等功能。

## 底层架构

### 自动合并机制

底层会自动处理辅助工作流的合并：

1. **自动加载**：如果辅助工作流不存在，会自动创建
2. **自动合并**：自动合并功能到主工作流
3. **动态Prompt**：支持函数类型的prompt，动态生成包含实时信息的提示

### 核心方法

#### `registerFunction(name, options)`

注册函数，支持动态prompt：

```javascript
this.registerFunction('my_func', {
  prompt: () => `动态生成的prompt`,  // 支持函数类型
  handler: async (params, context) => { /* ... */ }
});
```

#### `merge(stream, options)`

合并另一个工作流的函数到当前工作流。

#### `buildSystemPrompt(context)`

构建系统提示词（可选实现，只有主工作流的会被调用）。
- 如果未实现，基类返回空字符串
- 辅助工作流的此方法在合并时不会被调用

#### `buildFunctionsPrompt()`

收集所有已合并函数的 `prompt` 字段，支持动态解析。

## 最佳实践

1. **使用动态Prompt**：在注册函数时使用函数类型的 `prompt`，动态包含实时信息
2. **简化调用**：使用 `process()` 方法，通过参数控制功能
3. **自动合并**：让底层自动处理辅助工作流的合并
4. **功能分离**：将辅助功能放在辅助工作流中，核心功能放在核心工作流中
5. **删除冗余**：辅助工作流的 `buildSystemPrompt()` 不会被调用，保持简洁
6. **可选实现**：`buildSystemPrompt()` 和 `buildChatContext()` 是可选的，如果不需要可以省略

## 注意事项

1. **优先级设置**：
   - 辅助工作流：`priority: 1-10`
   - 核心工作流：`priority: 100+`

2. **Prompt设计**：
   - 使用动态prompt包含实时信息（如知识库列表、记忆列表）
   - 保持prompt清晰，便于AI理解

3. **函数注册**：
   - `prompt` 字段支持字符串和函数类型
   - 函数类型会在 `buildFunctionsPrompt()` 时动态解析

4. **代码简洁**：
   - 删除冗余代码
   - 辅助工作流的 `buildSystemPrompt()` 保持简洁（不会被调用）
   - 使用动态prompt机制，避免在 `buildFunctionsPrompt()` 中额外处理

## 扩展性

### 添加新的辅助工作流

1. 创建新的辅助工作流文件
2. 在主工作流的 `autoMergeAuxiliaryStreams()` 中添加
3. 使用动态prompt机制展示实时信息

### 添加新的核心工作流

1. 创建新的核心工作流文件
2. 可选实现 `buildSystemPrompt()` 和 `buildChatContext()`
3. 注册需要的函数
3. 可以通过 `process()` 方法合并辅助工作流

## 总结

工作流系统通过清晰的架构设计，实现了：
- **模块化**：核心工作流和辅助工作流分离
- **可扩展**：易于添加新功能
- **智能化**：AI自动决策和执行
- **动态化**：支持动态prompt，包含实时信息

通过 `registerFunction` 的 `prompt` 字段（支持函数类型），实现了信息的动态展示，让AI能够更好地理解和使用系统功能。
