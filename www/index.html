<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XRK-AGT | å¤šè¯­è¨€ã€å¤šé€‚é…å™¨ã€å·¥ä½œæµé©±åŠ¨å‹æ™ºèƒ½ä½“å¹³å°</title>
    <!-- ç›´æ¥åŠ è½½è„šæœ¬ï¼Œé¿å…åŠ¨æ€åŠ è½½å¯¼è‡´çš„å»¶è¿Ÿ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script>
        // æ£€æµ‹æ˜¯å¦ä¸ºæœ¬åœ°è®¿é—®
        window.isLocalhost = window.location.hostname === 'localhost' || 
                             window.location.hostname === '127.0.0.1' || 
                             window.location.hostname === '[::1]' ||
                             window.location.hostname === '' ||
                             window.location.protocol === 'file:';
    </script>
    <style>
        :root {
            --bg-primary: #0a0a0f;
            --bg-secondary: #13131f;
            --accent-primary: #6366f1;
            --accent-secondary: #8b5cf6;
            --accent-gold: #fbbf24;
            --text-primary: #f8fafc;
            --text-secondary: #94a3b8;
            --glass-bg: rgba(255, 255, 255, 0.03);
            --glass-border: rgba(255, 255, 255, 0.08);
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
        }
        .bg-gradient {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 0;
            background: radial-gradient(ellipse at top, rgba(99, 102, 241, 0.15) 0%, transparent 50%),
                        radial-gradient(ellipse at bottom, rgba(139, 92, 246, 0.1) 0%, transparent 50%);
        }
        .mesh-gradient {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; opacity: 0.3;
            background: radial-gradient(at 40% 20%, rgba(99, 102, 241, 0.25) 0px, transparent 50%),
                        radial-gradient(at 80% 0%, rgba(139, 92, 246, 0.25) 0px, transparent 50%),
                        radial-gradient(at 0% 50%, rgba(251, 191, 36, 0.15) 0px, transparent 50%);
            filter: blur(80px);
            animation: mesh-move 20s ease-in-out infinite;
            will-change: transform; /* æ€§èƒ½ä¼˜åŒ– */
        }
        @keyframes mesh-move {
            0%, 100% { transform: scale(1) translateY(0); }
            50% { transform: scale(1.1) translateY(-20px); }
        }
        nav {
            position: fixed; top: 0; width: 100%; z-index: 1000;
            backdrop-filter: blur(20px) saturate(180%);
            background: rgba(10, 10, 15, 0.7);
            border-bottom: 1px solid var(--glass-border);
        }
        .nav-container {
            max-width: 1400px; margin: 0 auto; padding: 1.2rem 2rem;
            display: flex; justify-content: space-between; align-items: center;
        }
        .logo {
            display: flex; align-items: center; gap: 0.8rem;
            font-size: 1.3rem; font-weight: 700;
            background: linear-gradient(135deg, var(--accent-gold), var(--accent-primary));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }
        .nav-links { display: flex; gap: 2rem; list-style: none; }
        .nav-links a {
            color: var(--text-secondary); text-decoration: none;
            font-weight: 500; transition: color 0.3s; position: relative;
        }
        .nav-links a:hover { color: var(--text-primary); }
        .container { position: relative; z-index: 1; max-width: 1400px; margin: 0 auto; padding: 0 2rem; width: 100%; }
        .hero {
            min-height: 100vh; display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            text-align: center; padding: 8rem 0 4rem;
            max-width: 1200px; margin: 0 auto;
        }
        .sunflower-icon { font-size: 5rem; margin-bottom: 2rem; animation: float 3s ease-in-out infinite; }
        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }
        .hero h1 {
            font-size: clamp(3rem, 8vw, 6rem); font-weight: 800; margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff, var(--accent-gold), var(--accent-primary));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }
        .hero p { font-size: 1.5rem; color: var(--text-secondary); margin-bottom: 3rem; max-width: 600px; }
        .badges { display: flex; gap: 1rem; flex-wrap: wrap; justify-content: center; margin-bottom: 3rem; }
        .badge {
            padding: 0.6rem 1.5rem; background: var(--glass-bg); border: 1px solid var(--glass-border);
            border-radius: 2rem; backdrop-filter: blur(10px); font-size: 0.9rem; color: var(--text-secondary);
            transition: all 0.3s;
        }
        .badge:hover { background: rgba(99, 102, 241, 0.1); border-color: var(--accent-primary); color: var(--text-primary); transform: translateY(-2px); }
        .cta-buttons { display: flex; gap: 1rem; flex-wrap: wrap; justify-content: center; }
        .btn {
            padding: 1rem 2.5rem; border-radius: 1rem; font-weight: 600; text-decoration: none;
            transition: all 0.15s ease; display: inline-flex; align-items: center; gap: 0.5rem;
            border: none; cursor: pointer; font-size: 1rem; user-select: none;
        }
        .btn-primary {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            color: white; box-shadow: 0 10px 30px rgba(99, 102, 241, 0.3);
        }
        .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 15px 40px rgba(99, 102, 241, 0.4); }
        .btn-primary:active { transform: translateY(1px) scale(0.98); }
        .btn-secondary {
            background: var(--glass-bg); color: var(--text-primary);
            border: 1px solid var(--glass-border); backdrop-filter: blur(10px);
        }
        .btn-secondary:hover { background: rgba(255, 255, 255, 0.08); transform: translateY(-2px); }
        .btn-secondary:active { transform: translateY(1px) scale(0.98); }
        .game-section { padding: 6rem 0; min-height: 100vh; display: flex; flex-direction: column; align-items: center; }
        .section-title { font-size: 2.5rem; font-weight: 700; text-align: center; margin-bottom: 2rem; }
        .docs-section { padding: 6rem 0; max-width: 1200px; margin: 0 auto; width: 100%; box-sizing: border-box; }
        .docs-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 2rem; margin-top: 3rem; padding: 0 2rem; }
        .docs-card {
            background: var(--glass-bg); border: 1px solid var(--glass-border); border-radius: 1.5rem;
            padding: 2rem; transition: all 0.3s; backdrop-filter: blur(10px);
            will-change: transform; /* æ€§èƒ½ä¼˜åŒ– */
        }
        .docs-card:hover { transform: translateY(-5px); border-color: var(--accent-primary); background: rgba(99, 102, 241, 0.1); }
        .docs-card h3 { font-size: 1.5rem; margin-bottom: 1rem; color: var(--accent-gold); 
                        background: linear-gradient(135deg, var(--accent-gold), var(--accent-primary));
                        -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .docs-card ul { list-style: none; padding: 0; margin: 0; }
        .docs-card li { padding: 0.5rem 0; color: var(--text-secondary); line-height: 1.6; }
        .docs-card li:before { content: "â–¸ "; color: var(--accent-primary); margin-right: 0.5rem; font-weight: bold; }
        .game-selector {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem; max-width: 1200px; margin: 0 auto 3rem; padding: 0 2rem;
            width: 100%;
        }
        .game-option {
            background: var(--glass-bg); border: 2px solid var(--glass-border); border-radius: 1.5rem;
            padding: 2rem; cursor: pointer; transition: all 0.3s; text-align: center; 
            position: relative; overflow: hidden; will-change: transform; /* æ€§èƒ½ä¼˜åŒ– */
        }
        .game-option::before {
            content: ''; position: absolute; top: 0; left: 0; right: 0; height: 3px;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
            transform: scaleX(0); transition: transform 0.3s;
        }
        .game-option:hover { transform: translateY(-5px); border-color: var(--accent-primary); background: rgba(99, 102, 241, 0.1); }
        .game-option:hover::before { transform: scaleX(1); }
        .game-option.active { border-color: var(--accent-gold); background: rgba(251, 191, 36, 0.1); box-shadow: 0 0 30px rgba(251, 191, 36, 0.3); }
        .game-option-icon { font-size: 4rem; margin-bottom: 1rem; display: block; }
        .game-option h3 { font-size: 1.3rem; margin-bottom: 0.5rem; }
        .game-option p { color: var(--text-secondary); font-size: 0.9rem; }
        .game-container {
            width: 95%; max-width: 1600px; height: 80vh; min-height: 600px; 
            margin: 0 auto; position: relative; background: var(--bg-secondary); 
            border: 3px solid var(--glass-border); border-radius: 2rem; 
            overflow: hidden; box-shadow: 0 30px 80px rgba(0, 0, 0, 0.6);
        }
        #threeContainer, #gameCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        .video-feed {
            position: absolute; bottom: 20px; left: 20px; width: 160px; height: 120px;
            border-radius: 12px; border: 2px solid var(--glass-border); opacity: 0.7;
            z-index: 10; transform: scaleX(-1); transition: opacity 0.3s; background: #000;
        }
        .video-feed:hover { opacity: 1; }
        .game-hud {
            position: absolute; top: 20px; left: 0; right: 0; padding: 0 2rem;
            display: flex; justify-content: space-between; align-items: flex-start;
            pointer-events: none; z-index: 10;
        }
        .hud-panel {
            background: rgba(0, 0, 0, 0.7); padding: 1.5rem 2rem; border-radius: 1.5rem;
            backdrop-filter: blur(20px); border: 2px solid rgba(255, 255, 255, 0.1); min-width: 180px;
        }
        .hud-title { font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 0.5rem; text-transform: uppercase; letter-spacing: 1px; }
        .hud-value {
            font-size: 2rem; font-weight: 700;
            background: linear-gradient(135deg, var(--accent-gold), var(--accent-primary));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }
        .status-badge { display: inline-flex; align-items: center; gap: 6px; padding: 6px 12px; border-radius: 20px; font-size: 0.8rem; background: rgba(255, 255, 255, 0.05); margin-top: 0.5rem; }
        .status-dot { width: 8px; height: 8px; border-radius: 50%; background: #ef4444; transition: background 0.3s; }
        .status-dot.active { background: #22c55e; box-shadow: 0 0 10px #22c55e; }
        .hand-indicator {
            display: flex; gap: 8px; margin-top: 8px; font-size: 0.75rem;
        }
        .hand-indicator-item {
            display: flex; align-items: center; gap: 4px; padding: 4px 8px;
            background: rgba(255, 255, 255, 0.05); border-radius: 12px;
        }
        .hand-dot {
            width: 6px; height: 6px; border-radius: 50%; background: #64748b;
            transition: all 0.3s;
        }
        .hand-dot.active { box-shadow: 0 0 8px currentColor; }
        .hand-dot.left.active { background: #3b82f6; color: #3b82f6; }
        .hand-dot.right.active { background: #f59e0b; color: #f59e0b; }
        .particle-controls {
            position: absolute; top: 20px; right: 20px; width: 280px;
            background: rgba(15, 15, 20, 0.85); backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border); border-radius: 20px; padding: 20px; z-index: 100; pointer-events: auto;
        }
        .control-group { margin-bottom: 15px; }
        .control-label { font-size: 0.85rem; color: #94a3b8; margin-bottom: 8px; display: block; }
        .shape-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; }
        .shape-btn {
            background: var(--glass-bg); border: 1px solid var(--glass-border); color: var(--text-primary);
            padding: 8px; border-radius: 8px; cursor: pointer; font-size: 0.8rem; transition: all 0.3s;
        }
        .shape-btn:hover, .shape-btn.active { background: var(--accent-primary); border-color: var(--accent-primary); box-shadow: 0 0 15px rgba(99, 102, 241, 0.4); }
        .color-picker-wrapper { display: flex; align-items: center; gap: 10px; background: var(--glass-bg); padding: 8px; border-radius: 8px; }
        input[type="color"] { -webkit-appearance: none; border: none; width: 30px; height: 30px; border-radius: 50%; overflow: hidden; cursor: pointer; background: none; }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: none; border-radius: 50%; border: 2px solid rgba(255, 255, 255, 0.2); }
        .hand-tracker {
            position: absolute; width: 80px; height: 80px; border: 4px solid var(--accent-gold);
            border-radius: 50%; box-shadow: 0 0 30px rgba(251, 191, 36, 0.6);
            pointer-events: none; z-index: 20; transition: all 0.08s linear; display: none;
        }
        .hand-tracker.active { display: block; }
        .hand-tracker.closed { border-color: #ef4444; box-shadow: 0 0 40px rgba(239, 68, 68, 0.8); }
        .game-controls { display: flex; gap: 1rem; margin-top: 2rem; flex-wrap: wrap; justify-content: center; }
        .game-message {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 3rem; font-weight: 700; color: white; text-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            opacity: 0; pointer-events: none; z-index: 30; transition: opacity 0.3s; text-align: center; padding: 2rem;
        }
        .game-message.show { opacity: 1; }
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(10, 10, 15, 0.95); z-index: 9999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 0.5s;
        }
        #loader.hidden { opacity: 0; pointer-events: none; }
        .spinner { width: 50px; height: 50px; border: 4px solid var(--accent-primary); border-top-color: transparent; border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px; }
        @keyframes spin { to { transform: rotate(360deg); } }
        footer { padding: 4rem 0 2rem; text-align: center; border-top: 1px solid var(--glass-border); max-width: 1200px; margin: 0 auto; }
        .scroll-top {
            position: fixed; bottom: 2rem; right: 2rem; width: 3rem; height: 3rem;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            border-radius: 50%; display: flex; align-items: center; justify-content: center;
            cursor: pointer; opacity: 0; transition: all 0.3s; z-index: 100; border: none; color: white; font-size: 1.2rem;
        }
        .scroll-top.show { opacity: 1; }
        .scroll-top:hover { transform: translateY(-5px); }
        @media (max-width: 768px) {
            .nav-links { display: none; }
            .hero h1 { font-size: 3rem; }
            .game-container { width: 98%; height: 60vh; }
            .game-hud { flex-direction: column; padding: 1rem; }
            .hud-panel { min-width: auto; padding: 1rem 1.5rem; }
            .particle-controls { width: 220px; padding: 15px; top: auto; bottom: 150px; right: 10px; }
            .game-selector { grid-template-columns: 1fr; }
            .docs-grid { grid-template-columns: 1fr; }
            .docs-section { padding: 3rem 1rem; }
            .container { padding: 0 1rem; }
        }
    </style>
</head>
<body>
    <div class="bg-gradient"></div>
    <div class="mesh-gradient"></div>
    <nav>
        <div class="nav-container">
            <div class="logo"><span>ğŸŒ»</span><span>XRK-AGT</span></div>
            <ul class="nav-links">
                <li><a href="#home">é¦–é¡µ</a></li>
                <li><a href="#docs">æ–‡æ¡£</a></li>
                <li id="gameNavItem" style="display:none;"><a href="#game">äº¤äº’æ¸¸æˆ</a></li>
                <li><a href="https://gitcode.com/Xrkseek/XRK-AGT" target="_blank">é¡¹ç›®ä»“åº“</a></li>
            </ul>
        </div>
    </nav>
    <div class="container">
        <section id="home" class="hero">
            <div class="sunflower-icon">ğŸŒ»</div>
            <h1>XRK-AGT</h1>
            <p>å¤šè¯­è¨€ã€å¤šé€‚é…å™¨ã€å·¥ä½œæµé©±åŠ¨å‹æ™ºèƒ½ä½“å¹³å°</p>
            <div class="badges">
                <span class="badge">âš¡ å¤šå¹³å°æ¥å…¥</span>
                <span class="badge">ğŸ”Œ æ’ä»¶å·¥ä½œæµ</span>
                <span class="badge">ğŸŒ Webæ§åˆ¶å°</span>
                <span class="badge">ğŸ¤– AIå·¥ä½œæµ</span>
                <span class="badge">ğŸ¨ æ¸²æŸ“æˆªå›¾</span>
            </div>
            <div class="cta-buttons">
                <a href="#docs" class="btn btn-primary"><span>æŸ¥çœ‹æ–‡æ¡£</span><span>â†’</span></a>
                <a href="https://gitcode.com/Xrkseek/XRK-AGT" target="_blank" class="btn btn-secondary"><span>æŸ¥çœ‹æºç </span></a>
            </div>
        </section>
    </div>
    <section id="docs" class="docs-section">
        <h2 class="section-title">ğŸ“š é¡¹ç›®æ–‡æ¡£</h2>
        <div class="docs-grid">
            <div class="docs-card">
                <h3>ğŸš€ å¿«é€Ÿå¼€å§‹</h3>
                <ul>
                    <li>Node.js â‰¥ 18.14.0</li>
                    <li>Redis â‰¥ 5.0.0</li>
                    <li>æ”¯æŒ Windows / Linux</li>
                    <li>éœ€è¦ Chrome/Chromium/Edgeï¼ˆæ¸²æŸ“åŠŸèƒ½ï¼‰</li>
                </ul>
            </div>
            <div class="docs-card">
                <h3>ğŸ”Œ æ ¸å¿ƒç‰¹æ€§</h3>
                <ul>
                    <li>å¤šå¹³å°æ¶ˆæ¯æ¥å…¥ï¼ˆOneBotv11 / ComWeChatï¼‰</li>
                    <li>æ’ä»¶å·¥ä½œæµ + AI å·¥ä½œæµ</li>
                    <li>Web æ§åˆ¶å° + REST API + WebSocket</li>
                    <li>åŸºäº Puppeteer/Playwright çš„æ¸²æŸ“</li>
                </ul>
            </div>
            <div class="docs-card">
                <h3>ğŸ“– æ–‡æ¡£å¯¼èˆª</h3>
                <ul>
                    <li>é¡¹ç›®æ¦‚è§ˆï¼šäº†è§£æ•´ä½“æ¶æ„</li>
                    <li>Bot ä¸»ç±»ï¼šæ ¸å¿ƒè¿è¡Œæ—¶å¯¹è±¡</li>
                    <li>æ’ä»¶ç³»ç»Ÿï¼šè§„åˆ™åŒ¹é…ä¸ä¸Šä¸‹æ–‡ç®¡ç†</li>
                    <li>é€‚é…å™¨ç³»ç»Ÿï¼šå¤šå¹³å°åè®®å¯¹æ¥</li>
                    <li>AI å·¥ä½œæµï¼šChat Completion ä¸ Embedding</li>
                </ul>
            </div>
            <div class="docs-card">
                <h3>ğŸ—ï¸ é¡¹ç›®ç»“æ„</h3>
                <ul>
                    <li>src/ï¼šè¿è¡Œæ ¸å¿ƒä¸åŸºç¡€è®¾æ–½</li>
                    <li>core/ï¼šé€‚é…å™¨ã€APIã€å·¥ä½œæµ</li>
                    <li>config/ï¼šé»˜è®¤é…ç½®ä¸å‘½ä»¤è¡Œå·¥å…·</li>
                    <li>docs/ï¼šå®Œæ•´æ¨¡å—æ–‡æ¡£</li>
                    <li>www/ï¼šå‰ç«¯é™æ€èµ„æº</li>
                </ul>
            </div>
            <div class="docs-card">
                <h3>ğŸ’¡ ä½¿ç”¨åœºæ™¯</h3>
                <ul>
                    <li>æ­å»º QQ æ™ºèƒ½ä½“ï¼ˆèŠå¤©æœºå™¨äººï¼‰</li>
                    <li>ä»»åŠ¡åŠ©æ‰‹ä¸æ•°æ®ç›‘æ§</li>
                    <li>å‚ç›´åœºæ™¯è‡ªåŠ¨åŒ–å·¥ä½œæµ</li>
                    <li>å¯æ‰©å±•çš„ Bot å¹³å°</li>
                </ul>
            </div>
            <div class="docs-card">
                <h3>ğŸ”§ å¼€å‘æŒ‡å—</h3>
                <ul>
                    <li>é˜…è¯» PROJECT_OVERVIEW.md</li>
                    <li>æŸ¥çœ‹ docs/README.md</li>
                    <li>å‚è€ƒ docs/app-dev.md</li>
                    <li>äº†è§£æ’ä»¶ä¸é€‚é…å™¨å¼€å‘</li>
                </ul>
            </div>
        </div>
    </section>
    <section id="game" class="game-section" style="display:none;">
        <h2 class="section-title">ğŸ® é€‰æ‹©ä½ çš„æ¸¸æˆ</h2>
        <div class="game-selector">
            <div class="game-option active" data-game="particles"><span class="game-option-icon">âœ¨</span><h3>3Dç²’å­äº¤äº’</h3><p>æ‰‹åŠ¿æ§åˆ¶ç²’å­å½¢æ€å˜æ¢</p></div>
            <div class="game-option" data-game="sunflower"><span class="game-option-icon">ğŸŒ»</span><h3>å‘æ—¥è‘µæ”¶é›†</h3><p>æŠ“å–å‘æ—¥è‘µå¾—åˆ†</p></div>
            <div class="game-option" data-game="balloon"><span class="game-option-icon">ğŸˆ</span><h3>æ°”çƒæ´¾å¯¹</h3><p>å¿«é€Ÿæ‹æ‰“ä¸Šå‡æ°”çƒ</p></div>
            <div class="game-option" data-game="fruit"><span class="game-option-icon">ğŸ</span><h3>æ°´æœå¿è€…</h3><p>æŒ¥æ‰‹åˆ‡å‰²æ‰è½æ°´æœ</p></div>
        </div>
        <div class="game-container">
            <div id="loader"><div class="spinner"></div><p style="color:#94a3b8;">æ­£åœ¨åˆå§‹åŒ– AI è§†è§‰å¼•æ“...</p><p style="font-size:0.8rem;margin-top:10px;color:#64748b;">è¯·å…è®¸æ‘„åƒå¤´æƒé™</p></div>
            <div id="threeContainer"></div>
            <canvas id="gameCanvas" style="display:none;"></canvas>
            <video id="webcam" class="video-feed" playsinline></video>
            <div class="hand-tracker" id="handTracker"></div>
            <div class="game-hud">
                <div class="hud-panel">
                    <div class="hud-title">æ‰‹åŠ¿çŠ¶æ€</div>
                    <div class="status-badge"><div class="status-dot" id="handStatus"></div><span id="statusText">ç­‰å¾…æ‰‹åŠ¿...</span></div>
                </div>
                <div class="hud-panel" id="scorePanel" style="display:none;">
                    <div class="hud-title">åˆ†æ•°</div>
                    <div class="hud-value" id="scoreValue">0</div>
                </div>
            </div>
            <div class="particle-controls" id="particleControls">
                <div class="control-group">
                    <label class="control-label">ç²’å­å½¢çŠ¶</label>
                    <div class="shape-grid">
                        <button class="shape-btn active" data-shape="heart">â¤ï¸ çˆ±å¿ƒ</button>
                        <button class="shape-btn" data-shape="saturn">ğŸª åœŸæ˜Ÿ</button>
                        <button class="shape-btn" data-shape="flower">ğŸŒ¸ èŠ±æœµ</button>
                        <button class="shape-btn" data-shape="buddha">ğŸ§˜ ä½›åƒ</button>
                        <button class="shape-btn" data-shape="fireworks">ğŸ† çƒŸèŠ±</button>
                        <button class="shape-btn" data-shape="dna">ğŸ§¬ DNA</button>
                    </div>
                </div>
                <div class="control-group">
                    <label class="control-label">ç²’å­é¢œè‰²</label>
                    <div class="color-picker-wrapper">
                        <input type="color" id="colorPicker" value="#6366f1">
                        <span style="font-size:0.9rem;">è‡ªå®šä¹‰é¢œè‰²</span>
                    </div>
                </div>
                <div class="control-group">
                    <label class="control-label">æ“ä½œæç¤º</label>
                    <p style="font-size:0.8rem;color:#94a3b8;line-height:1.5;">
                        ğŸ– <b>å¼ å¼€æ‰‹æŒ</b>ï¼šç²’å­å¤§å¹…æ‰©æ•£ï¼ˆ10å€å·®å¼‚ï¼‰<br>
                        âœŠ <b>æ¡ç´§æ‹³å¤´</b>ï¼šç²’å­å¤§å¹…èšæ‹¢<br>
                        ğŸ‘‹ <b>ç§»åŠ¨æ‰‹æŒ</b>ï¼šæ—‹è½¬è§†è§’<br>
                        ğŸ¤² <b>åŒæ‰‹æ“ä½œ</b>ï¼šæ›´ç²¾ç¡®çš„æ§åˆ¶
                    </p>
                    <div class="hand-indicator" id="handIndicator" style="display: none;">
                        <div class="hand-indicator-item">
                            <div class="hand-dot left" id="leftHandDot"></div>
                            <span>å·¦æ‰‹</span>
                        </div>
                        <div class="hand-indicator-item">
                            <div class="hand-dot right" id="rightHandDot"></div>
                            <span>å³æ‰‹</span>
                        </div>
                    </div>
                </div>
            </div>
            <div class="game-message" id="gameMessage"></div>
        </div>
        <div class="game-controls">
            <button class="btn btn-secondary" id="resetBtn"><span>ğŸ”„</span><span>é‡ç½®æ¸¸æˆ</span></button>
        </div>
    </section>
    <footer>
        <p style="color:var(--text-secondary);">Â© 2024 XRK-AGT | å¤šè¯­è¨€ã€å¤šé€‚é…å™¨ã€å·¥ä½œæµé©±åŠ¨å‹æ™ºèƒ½ä½“å¹³å°</p>
        <p style="color:var(--text-secondary);margin-top:1rem;font-size:0.9rem;">æ°¸è¿œå‘ç€é˜³å…‰ç”Ÿé•¿ ğŸŒ»</p>
    </footer>
    <button class="scroll-top" id="scrollTop">â†‘</button>

    <script>
        // ============ è®¿é—®æ£€æµ‹ ============
        const isLocalhost = window.isLocalhost || (window.location.hostname === 'localhost' || 
                           window.location.hostname === '127.0.0.1' || 
                           window.location.hostname === '[::1]' ||
                           window.location.hostname === '');

        // ============ æ€§èƒ½ç›‘æ§å’Œè‡ªé€‚åº”ç³»ç»Ÿ ============
        const PerformanceMonitor = {
            fps: 60,
            frameCount: 0,
            lastFpsUpdate: 0,
            frameTimes: [],
            targetFPS: 60,
            adaptiveQuality: true,
            
            update(currentTime) {
                this.frameCount++;
                if (currentTime - this.lastFpsUpdate >= 1000) {
                    this.fps = this.frameCount;
                    this.frameCount = 0;
                    this.lastFpsUpdate = currentTime;
                    
                    // è‡ªé€‚åº”è°ƒæ•´
                    if (this.adaptiveQuality) {
                        if (this.fps < 45 && G.particleCount > 2000) {
                            // æ€§èƒ½ä¸è¶³ï¼Œå‡å°‘ç²’å­æ•°
                            this.adjustParticleCount(-500);
                        } else if (this.fps > 55 && G.particleCount < 8000) {
                            // æ€§èƒ½å……è¶³ï¼Œå¢åŠ ç²’å­æ•°
                            this.adjustParticleCount(500);
                        }
                    }
                }
            },
            
            adjustParticleCount(delta) {
                const oldCount = G.particleCount;
                G.particleCount = Math.max(2000, Math.min(10000, G.particleCount + delta));
                if (oldCount !== G.particleCount && G.particles) {
                    // é‡æ–°åˆå§‹åŒ–ç²’å­ç³»ç»Ÿ
                    initThreeJS();
                }
            },
            
            getFrameTime() {
                return 1000 / this.targetFPS;
            }
        };

        // ============ å…¨å±€çŠ¶æ€ ============
        const G = {
            mode: 'particles',
            // åŒæ‰‹æ”¯æŒ
            leftHand: { x: 0.5, y: 0.5, openness: 1.0, detected: false },
            rightHand: { x: 0.5, y: 0.5, openness: 1.0, detected: false },
            // å…¼å®¹æ—§ä»£ç 
            handX: 0.5, handY: 0.5,
            handOpenness: 1.0,
            isHandDetected: false,
            scene: null, camera: null, renderer: null, particles: null,
            particleCount: isLocalhost ? 5000 : 3500, // æ ¹æ®è®¿é—®æ¥æºè°ƒæ•´ç²’å­æ•°
            positions: null, targetPositions: null,
            currentShape: 'heart',
            gameObjects: [], score: 0,
            canvasW: 0, canvasH: 0,
            lastFrameTime: 0,
            targetFPS: 60,
            frameInterval: 1000 / 60,
            // æ€§èƒ½ä¼˜åŒ–æ ‡å¿—
            useOptimizedUpdate: true
        };

        // ============ Three.js ç²’å­ç³»ç»Ÿï¼ˆå‚è€ƒä¼˜åŒ–ç‰ˆæœ¬ï¼‰============
        function initThreeJS() {
            const container = document.getElementById('threeContainer');
            if (!container) return;
            
            G.scene = new THREE.Scene();
            G.scene.fog = new THREE.FogExp2(0x0a0a0f, 0.002);
            
            G.camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            G.camera.position.z = 30;
            
            // ä¼˜åŒ–æ¸²æŸ“å™¨è®¾ç½®ï¼šæ ¹æ®è®¾å¤‡æ€§èƒ½è°ƒæ•´
            const isHighEndDevice = navigator.hardwareConcurrency >= 8 && 
                                   (navigator.deviceMemory || 4) >= 8;
            
            G.renderer = new THREE.WebGLRenderer({ 
                antialias: isHighEndDevice, // é«˜ç«¯è®¾å¤‡å¯ç”¨æŠ—é”¯é½¿
                alpha: true,
                powerPreference: "high-performance",
                precision: "highp", // é«˜ç²¾åº¦
                stencil: false, // ç¦ç”¨æ¨¡æ¿ç¼“å†²
                depth: true,
                logarithmicDepthBuffer: false
            });
            G.renderer.setSize(container.clientWidth, container.clientHeight);
            // æ ¹æ®è®¾å¤‡æ€§èƒ½è°ƒæ•´åƒç´ æ¯”
            const maxPixelRatio = isHighEndDevice ? 2.0 : 1.5;
            G.renderer.setPixelRatio(Math.min(window.devicePixelRatio, maxPixelRatio));
            
            // å¯ç”¨æ¸²æŸ“ä¼˜åŒ–
            G.renderer.shadowMap.enabled = false;
            G.renderer.autoClear = true;
            G.renderer.sortObjects = false; // ç¦ç”¨æ’åºæå‡æ€§èƒ½
            container.appendChild(G.renderer.domElement);

            // ç”Ÿæˆåœ†å½¢çº¹ç†ï¼ˆå¤ç”¨å‡½æ•°ï¼‰
            function getTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 32;
                canvas.height = 32;
                const ctx = canvas.getContext('2d');
                const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
                grad.addColorStop(0, 'rgba(255,255,255,1)');
                grad.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, 32, 32);
                const texture = new THREE.Texture(canvas);
                texture.needsUpdate = true;
                return texture;
            }

            // åˆ›å»ºå‡ ä½•ä½“å’Œæè´¨
            const geometry = new THREE.BufferGeometry();
            G.positions = new Float32Array(G.particleCount * 3);
            G.targetPositions = new Float32Array(G.particleCount * 3);
            
            // åˆå§‹åŒ–éšæœºä½ç½®
            for (let i = 0; i < G.particleCount; i++) {
                G.positions[i * 3] = (Math.random() - 0.5) * 100;
                G.positions[i * 3 + 1] = (Math.random() - 0.5) * 100;
                G.positions[i * 3 + 2] = (Math.random() - 0.5) * 100;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(G.positions, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.5,
                map: getTexture(),
                transparent: true,
                opacity: 0.8,
                vertexColors: false,
                color: new THREE.Color(0x6366f1),
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true,
                // æ€§èƒ½ä¼˜åŒ–ï¼šç¦ç”¨ä¸éœ€è¦çš„åŠŸèƒ½
                fog: false // åœºæ™¯å·²æœ‰fogï¼Œæè´¨ä¸éœ€è¦
            });
            
            G.particles = new THREE.Points(geometry, material);
            G.scene.add(G.particles);
            updateTargetPositions('heart');
        }

        const Shapes = {
            heart: (i) => { const t = Math.random() * Math.PI * 2, r = Math.random(); const x = 16 * Math.pow(Math.sin(t), 3), y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t); return { x: x * 0.5 * r, y: y * 0.5 * r, z: (Math.random() - 0.5) * 4 }; },
            saturn: (i) => { if (Math.random() > 0.6) { const a = Math.random() * Math.PI * 2, rad = 12 + Math.random() * 6; return { x: Math.cos(a) * rad, y: (Math.random()-0.5), z: Math.sin(a) * rad }; } const phi = Math.acos(-1 + 2 * Math.random()), theta = Math.sqrt(G.particleCount * Math.PI) * phi, r = 7; return { x: r * Math.cos(theta) * Math.sin(phi), y: r * Math.sin(theta) * Math.sin(phi), z: r * Math.cos(phi) }; },
            flower: (i) => { const theta = Math.random() * Math.PI * 2, phi = Math.random() * Math.PI, k = 4, r = 10 * Math.sin(k * theta) * Math.sin(phi); return { x: r * Math.sin(phi) * Math.cos(theta), y: r * Math.cos(phi), z: r * Math.sin(phi) * Math.sin(theta) }; },
            buddha: (i) => { const rand = Math.random(); if (rand < 0.2) { const r = 2.5, u = Math.random(), v = Math.random(), theta = 2 * Math.PI * u, phi = Math.acos(2 * v - 1); return { x: r * Math.sin(phi) * Math.cos(theta), y: r * Math.sin(phi) * Math.sin(theta) + 6, z: r * Math.cos(phi) }; } if (rand < 0.7) { const h = Math.random() * 7, theta = Math.random() * Math.PI * 2, coneR = 6 * (1 - h/7); return { x: coneR * Math.cos(theta), y: h - 1, z: coneR * Math.sin(theta) }; } const a = Math.random() * Math.PI * 2, rad = 5 + Math.random() * 4; return { x: Math.cos(a) * rad, y: -2 + Math.random() * 2, z: Math.sin(a) * rad }; },
            fireworks: (i) => { const r = Math.random() * 15, theta = Math.random() * Math.PI * 2, phi = Math.acos(2 * Math.random() - 1); return { x: r * Math.sin(phi) * Math.cos(theta), y: r * Math.sin(phi) * Math.sin(theta), z: r * Math.cos(phi) }; },
            dna: (i) => { const t = (i / G.particleCount) * Math.PI * 20, radius = 5, height = 20, y = (i / G.particleCount) * height - height/2; let x = Math.cos(t) * radius, z = Math.sin(t) * radius; if (i % 2 === 0) { x = Math.cos(t + Math.PI) * radius; z = Math.sin(t + Math.PI) * radius; } if (Math.random() > 0.8) { const r = (Math.random() * 2 - 1) * radius; x = Math.cos(t) * r; z = Math.sin(t) * r; } return { x, y, z }; }
        };

        function updateTargetPositions(name) {
            const func = Shapes[name]; 
            if (!func) return;
            
            // æ€§èƒ½ä¼˜åŒ–ï¼šæ‰¹é‡æ›´æ–°ï¼Œå‡å°‘æ•°ç»„è®¿é—®
            const targetArr = G.targetPositions;
            const count = G.particleCount;
            
            // ä½¿ç”¨æ‰¹é‡å¤„ç†æå‡ç¼“å­˜å‘½ä¸­ç‡
            for (let i = 0; i < count; i++) {
                const pos = func(i);
                const idx = i * 3;
                targetArr[idx] = pos.x;
                targetArr[idx + 1] = pos.y;
                targetArr[idx + 2] = pos.z;
            }
            
            G.currentShape = name;
        }

        function animateParticles(currentTime) {
            // å…ˆæ£€æŸ¥æ¡ä»¶ï¼Œé¿å…ä¸å¿…è¦çš„ requestAnimationFrame è°ƒç”¨
            if (G.mode !== 'particles' || !G.particles) {
                requestAnimationFrame(animateParticles);
                return;
            }
            
            // åˆå§‹åŒ– lastFrameTimeï¼ˆä¿®å¤å¡ä½é—®é¢˜ï¼‰
            if (G.lastFrameTime === 0) {
                G.lastFrameTime = currentTime;
            }
            
            // æ€§èƒ½ä¼˜åŒ–ï¼šä½¿ç”¨å›ºå®šæ—¶é—´æ­¥é•¿ï¼ˆæ›´æµç•…ï¼‰
            const elapsed = currentTime - G.lastFrameTime;
            const deltaTime = Math.min(elapsed, 100); // é™åˆ¶æœ€å¤§deltaTimeé¿å…è·³å¸§
            
            if (elapsed < G.frameInterval) {
                requestAnimationFrame(animateParticles);
                return;
            }
            G.lastFrameTime = currentTime;
            
            const pos = G.particles.geometry.attributes.position.array;
            const targetPos = G.targetPositions;
            
            // åŸºç¡€æ—‹è½¬
            G.particles.rotation.y += 0.002;
            
            // åŒæ‰‹æ§åˆ¶æ—‹è½¬ï¼ˆæ›´æµç•…ï¼‰
            if (G.isHandDetected) {
                let rotY = 0, rotX = 0;
                
                if (G.leftHand.detected && G.rightHand.detected) {
                    // åŒæ‰‹ï¼šä½¿ç”¨åŒæ‰‹ä¸­å¿ƒç‚¹æ§åˆ¶æ—‹è½¬ï¼ŒåŒæ‰‹è·ç¦»æ§åˆ¶ç¼©æ”¾
                    const centerX = (G.leftHand.x + G.rightHand.x) / 2;
                    const centerY = (G.leftHand.y + G.rightHand.y) / 2;
                    rotY = (centerX - 0.5) * 0.05;
                    rotX = (centerY - 0.5) * 0.05;
                } else if (G.rightHand.detected) {
                    rotY = (G.rightHand.x - 0.5) * 0.05;
                    rotX = (G.rightHand.y - 0.5) * 0.05;
                } else if (G.leftHand.detected) {
                    rotY = (G.leftHand.x - 0.5) * 0.05;
                    rotX = (G.leftHand.y - 0.5) * 0.05;
                }
                
                G.particles.rotation.y += rotY;
                G.particles.rotation.x += rotX;
            }
            
            // ä¼˜åŒ–çš„ç¼©æ”¾é€»è¾‘ï¼šå¢å¤§å·®å¼‚ï¼Œè®©å¼ å¼€å’Œæ¡æ‹³åŒºåˆ«æ›´æ˜æ˜¾
            let scaleFactor = 1.0;
            
            if (G.isHandDetected) {
                if (G.leftHand.detected && G.rightHand.detected) {
                    // åŒæ‰‹ï¼šä½¿ç”¨å¹³å‡å¼€åˆåº¦ï¼Œä½†èŒƒå›´æ›´å¤§
                    const avgOpenness = (G.leftHand.openness + G.rightHand.openness) / 2;
                    // èŒƒå›´ï¼š0.2 (å®Œå…¨æ¡æ‹³) åˆ° 2.0 (å®Œå…¨å¼ å¼€) - å·®å¼‚10å€ï¼
                    scaleFactor = 0.2 + (avgOpenness * 1.8);
                } else {
                    // å•æ‰‹ï¼šåŒæ ·ä½¿ç”¨æ›´å¤§çš„èŒƒå›´
                    const openness = G.handOpenness;
                    // èŒƒå›´ï¼š0.2 (å®Œå…¨æ¡æ‹³) åˆ° 2.0 (å®Œå…¨å¼ å¼€)
                    scaleFactor = 0.2 + (openness * 1.8);
                }
                
                // ç‰¹æ®Šå½¢çŠ¶çš„é¢å¤–æ•ˆæœ
                if (G.currentShape === 'fireworks') {
                    scaleFactor *= 1.5; // çƒŸèŠ±æ•ˆæœæ›´æ˜æ˜¾
                } else if (G.currentShape === 'dna') {
                    scaleFactor = 0.3 + (scaleFactor * 0.7); // DNAä¿æŒç´§å‡‘
                }
            } else {
                // æœªæ£€æµ‹åˆ°æ‰‹æ—¶ï¼Œä½¿ç”¨é»˜è®¤å¤§å°
                scaleFactor = 1.0;
            }
            
            const speed = 0.05;
            
            // é«˜æ€§èƒ½æ‰¹é‡æ›´æ–°ï¼šä½¿ç”¨TypedArrayç›´æ¥æ“ä½œï¼Œå‡å°‘å‡½æ•°è°ƒç”¨
            const positionsArr = pos;
            const targetArr = targetPos;
            const count = G.particleCount;
            
            // é¢„è®¡ç®—scaleFactoré¿å…é‡å¤ä¹˜æ³•
            const scaleX = scaleFactor;
            const invSpeed = 1 - speed;
            
            // å±•å¼€å¾ªç¯ï¼Œå‡å°‘åˆ†æ”¯é¢„æµ‹å¤±è´¥ï¼ˆç°ä»£JSå¼•æ“ä¼˜åŒ–ï¼‰
            // ä½¿ç”¨æ‰¹é‡æ“ä½œæå‡ç¼“å­˜å‘½ä¸­ç‡
            let i = 0;
            const batchSize = 8; // æ¯æ¬¡å¤„ç†8ä¸ªç²’å­ï¼Œåˆ©ç”¨CPUç¼“å­˜
            
            // æ‰¹é‡å¤„ç†
            while (i < count - batchSize) {
                // å±•å¼€8æ¬¡è¿­ä»£
                for (let j = 0; j < batchSize; j++) {
                    const idx = (i + j) * 3;
                    const px = idx;
                    const py = idx + 1;
                    const pz = idx + 2;
                    
                    const tx = targetArr[px] * scaleX;
                    const ty = targetArr[py] * scaleX;
                    const tz = targetArr[pz] * scaleX;
                    
                    // ä¼˜åŒ–çš„Lerpï¼špos = pos * (1-speed) + target * speed
                    positionsArr[px] = positionsArr[px] * invSpeed + tx * speed;
                    positionsArr[py] = positionsArr[py] * invSpeed + ty * speed;
                    positionsArr[pz] = positionsArr[pz] * invSpeed + tz * speed;
                }
                i += batchSize;
            }
            
            // å¤„ç†å‰©ä½™ç²’å­
            while (i < count) {
                const idx = i * 3;
                const px = idx;
                const py = idx + 1;
                const pz = idx + 2;
                
                const tx = targetArr[px] * scaleX;
                const ty = targetArr[py] * scaleX;
                const tz = targetArr[pz] * scaleX;
                
                positionsArr[px] = positionsArr[px] * invSpeed + tx * speed;
                positionsArr[py] = positionsArr[py] * invSpeed + ty * speed;
                positionsArr[pz] = positionsArr[pz] * invSpeed + tz * speed;
                i++;
            }
            
            // æ›´æ–°æ€§èƒ½ç›‘æ§
            PerformanceMonitor.update(currentTime);
            
            // åªåœ¨ä½ç½®å˜åŒ–æ—¶æ›´æ–°ï¼ˆæ€§èƒ½ä¼˜åŒ–ï¼‰
            G.particles.geometry.attributes.position.needsUpdate = true;
            
            // ä½¿ç”¨requestAnimationFrameè‡ªåŠ¨åŒæ­¥åˆ·æ–°ç‡
            G.renderer.render(G.scene, G.camera);
            
            // ç»§ç»­åŠ¨ç”»å¾ªç¯
            requestAnimationFrame(animateParticles);
        }

        // ============ 2Dæ¸¸æˆï¼ˆé«˜æ€§èƒ½ä¼˜åŒ–ç‰ˆæœ¬ï¼‰============
        // ä¼˜åŒ–çš„å¯¹è±¡æ± ï¼šä½¿ç”¨æ•°ç»„ç´¢å¼•ä»£æ›¿findï¼ŒO(1)æŸ¥æ‰¾
        const objectPool = {
            pool: [],
            freeIndex: 0,
            get(x, y, type) {
                let obj;
                // ä»freeIndexå¼€å§‹æŸ¥æ‰¾ï¼Œé¿å…é‡å¤æ‰«æ
                if (this.freeIndex < this.pool.length) {
                    obj = this.pool[this.freeIndex];
                    if (!obj.active) {
                        obj.reset(x, y, type);
                        this.freeIndex++;
                        return obj;
                    }
                }
                
                // å¦‚æœfreeIndexæ²¡æœ‰æ‰¾åˆ°ï¼Œä»å¤´æŸ¥æ‰¾
                for (let i = 0; i < this.pool.length; i++) {
                    if (!this.pool[i].active) {
                        obj = this.pool[i];
                        obj.reset(x, y, type);
                        this.freeIndex = i + 1;
                        return obj;
                    }
                }
                
                // æ²¡æœ‰å¯ç”¨å¯¹è±¡ï¼Œåˆ›å»ºæ–°çš„
                obj = new GameObject(x, y, type);
                this.pool.push(obj);
                this.freeIndex = this.pool.length;
                return obj;
            },
            release(obj) {
                obj.active = false;
                // æ›´æ–°freeIndexåˆ°æœ€æ—©çš„ç©ºä½ç½®
                const idx = this.pool.indexOf(obj);
                if (idx !== -1 && idx < this.freeIndex) {
                    this.freeIndex = idx;
                }
            }
        };
        
        // ç©ºé—´åˆ†å‰²ä¼˜åŒ–ï¼šå°†ç”»å¸ƒåˆ†æˆç½‘æ ¼ï¼Œåªæ£€æµ‹é™„è¿‘çš„ç‰©ä½“
        const SpatialGrid = {
            cellSize: 150,
            grid: new Map(),
            
            getCellKey(x, y) {
                const cellX = Math.floor(x / this.cellSize);
                const cellY = Math.floor(y / this.cellSize);
                return `${cellX},${cellY}`;
            },
            
            add(obj) {
                const key = this.getCellKey(obj.x, obj.y);
                if (!this.grid.has(key)) {
                    this.grid.set(key, []);
                }
                this.grid.get(key).push(obj);
            },
            
            getNearby(x, y, radius) {
                const results = [];
                const cellX = Math.floor(x / this.cellSize);
                const cellY = Math.floor(y / this.cellSize);
                const radiusCells = Math.ceil(radius / this.cellSize) + 1;
                
                for (let dx = -radiusCells; dx <= radiusCells; dx++) {
                    for (let dy = -radiusCells; dy <= radiusCells; dy++) {
                        const key = `${cellX + dx},${cellY + dy}`;
                        const cell = this.grid.get(key);
                        if (cell) {
                            results.push(...cell);
                        }
                    }
                }
                return results;
            },
            
            clear() {
                this.grid.clear();
            }
        };

        // ä¼˜åŒ–çš„ä½å›¾ç¼“å­˜ï¼šä½¿ç”¨ç¦»å±Canvaså’Œå°ºå¯¸åˆ†çº§
        const emojiCache = new Map();
        
        function getEmojiImage(emoji, size) {
            // å°ºå¯¸åˆ†çº§ï¼šå‡å°‘ç¼“å­˜æ•°é‡
            const sizeLevel = Math.ceil(size / 10) * 10; // æ¯10pxä¸€ä¸ªçº§åˆ«
            const key = `${emoji}-${sizeLevel}`;
            
            if (emojiCache.has(key)) {
                return emojiCache.get(key);
            }
            
            // ä½¿ç”¨ç¦»å±Canvasé¢„æ¸²æŸ“
            const canvas = document.createElement('canvas');
            canvas.width = sizeLevel * 2;
            canvas.height = sizeLevel * 2;
            const ctx = canvas.getContext('2d', { alpha: true });
            
            // ä¼˜åŒ–å­—ä½“æ¸²æŸ“
            ctx.font = `${sizeLevel}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.fillText(emoji, sizeLevel, sizeLevel);
            
            emojiCache.set(key, canvas);
            
            // é™åˆ¶ç¼“å­˜å¤§å°ï¼ˆé˜²æ­¢å†…å­˜æ³„æ¼ï¼‰
            if (emojiCache.size > 100) {
                const firstKey = emojiCache.keys().next().value;
                emojiCache.delete(firstKey);
            }
            
            return canvas;
        }

        class GameObject {
            constructor(x, y, type) {
                this.reset(x, y, type);
            }
            reset(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.vx = (Math.random() - 0.5) * 4;
                this.vy = type === 'balloon' ? -(2 + Math.random() * 2) : (Math.random() - 0.5) * 2;
                this.size = 50 + Math.random() * 30;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotSpeed = (Math.random() - 0.5) * 0.1;
                this.popped = false;
                this.opacity = 1;
                this.active = true;
                this.emoji = this.getEmoji();
                this.emojiImage = null; // å»¶è¿ŸåŠ è½½
            }
            getEmoji() {
                const emojis = {
                    sunflower: 'ğŸŒ»',
                    balloon: ['ğŸˆ','ğŸ”´','ğŸŸ¡','ğŸŸ¢','ğŸ”µ','ğŸŸ£'][Math.floor(Math.random()*6)],
                    fruit: ['ğŸ','ğŸŠ','ğŸ‹','ğŸ‰','ğŸ‡','ğŸ“','ğŸ¥'][Math.floor(Math.random()*7)]
                };
                return emojis[this.type] || 'ğŸŒ»';
            }
            update(w, h) {
                if (this.popped) { 
                    this.opacity -= 0.1; 
                    return; 
                }
                // æ€§èƒ½ä¼˜åŒ–ï¼šé¢„è®¡ç®—å¸¸ç”¨å€¼ï¼Œå‡å°‘é‡å¤è®¡ç®—
                const now = Date.now();
                const halfSize = this.size / 2;
                
                if (this.type === 'balloon') {
                    this.y += this.vy; 
                    // ç¼“å­˜sinè®¡ç®—ç»“æœ
                    this.x += Math.sin(now / 500 + this.x) * 0.5;
                    if (this.y < -halfSize) { 
                        this.y = h + halfSize; 
                        this.x = Math.random() * w; 
                    }
                } else if (this.type === 'fruit') {
                    this.vy += 0.3;
                    this.y += this.vy; 
                    this.x += this.vx; 
                    this.rotation += this.rotSpeed;
                    if (this.y > h + halfSize) { 
                        this.y = -halfSize; 
                        this.x = Math.random() * w; 
                        this.vy = Math.random() * 2; 
                        this.emoji = this.getEmoji();
                        this.emojiImage = null; // é‡ç½®ç¼“å­˜
                    }
                } else {
                    this.vy += 0.2; 
                    this.x += this.vx; 
                    this.y += this.vy; 
                    this.rotation += this.rotSpeed;
                    if (this.x < halfSize || this.x > w - halfSize) {
                        this.vx *= -0.8;
                    }
                    if (this.y > h - halfSize) { 
                        this.vy *= -0.6; 
                        this.y = h - halfSize; 
                    }
                }
            }
            draw(ctx) {
                if (this.opacity <= 0 || !this.active) return;
                
                // ä½¿ç”¨ä½å›¾ç¼“å­˜æå‡æ€§èƒ½
                if (!this.emojiImage) {
                    this.emojiImage = getEmojiImage(this.emoji, this.size);
                }
                
                // æ€§èƒ½ä¼˜åŒ–ï¼šå‡å°‘save/restoreï¼Œä½¿ç”¨transform
                // åªåœ¨éœ€è¦æ—¶è®¾ç½®alphaï¼ˆé¿å…é‡å¤è®¾ç½®ï¼‰
                if (ctx.globalAlpha !== this.opacity) {
                    ctx.globalAlpha = this.opacity;
                }
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                // ä½¿ç”¨drawImageä»£æ›¿fillTextï¼ˆæ€§èƒ½æå‡10å€+ï¼‰
                const imgSize = this.size * 2;
                ctx.drawImage(this.emojiImage, -imgSize/2, -imgSize/2, imgSize, imgSize);
                ctx.restore();
            }
            hit(x, y, r) { return Math.hypot(this.x - x, this.y - y) < this.size / 2 + r; }
        }

        function initCanvasGame(type) {
            const canvas = document.getElementById('gameCanvas');
            if (!canvas) return;
            G.canvasW = canvas.width;
            G.canvasH = canvas.height;
            G.gameObjects = [];
            G.score = 0;
            const scoreEl = document.getElementById('scoreValue');
            if (scoreEl) scoreEl.textContent = '0';
            
            const count = type === 'balloon' ? 12 : type === 'fruit' ? 15 : 10;
            for (let i = 0; i < count; i++) {
                const x = Math.random() * G.canvasW;
                const y = type === 'balloon' 
                    ? G.canvasH + Math.random() * G.canvasH 
                    : type === 'fruit' 
                        ? -Math.random() * 300 
                        : Math.random() * G.canvasH * 0.5;
                G.gameObjects.push(objectPool.get(x, y, type));
            }
        }

        let lastCanvasFrame = 0;
        let animationId = null;
        
        function animateCanvas(currentTime) {
            // å…ˆæ£€æŸ¥æ¡ä»¶
            if (G.mode === 'particles') {
                animationId = requestAnimationFrame(animateCanvas);
                return;
            }
            
            // åˆå§‹åŒ– lastCanvasFrame
            if (lastCanvasFrame === 0) {
                lastCanvasFrame = currentTime;
            }
            
            // æ€§èƒ½ä¼˜åŒ–ï¼šè‡ªé€‚åº”å¸§ç‡ï¼ˆæ ¹æ®æ€§èƒ½è°ƒæ•´ï¼‰
            const elapsed = currentTime - lastCanvasFrame;
            const deltaTime = Math.min(elapsed, 100);
            lastCanvasFrame = currentTime;
            
            // åŠ¨æ€è°ƒæ•´ç›®æ ‡FPSï¼ˆæ€§èƒ½ä¸è¶³æ—¶é™ä½ï¼‰
            const targetFPS = PerformanceMonitor.fps < 30 ? 30 : 60;
            const fixedDelta = 1000 / targetFPS;
            
            if (elapsed < fixedDelta) {
                animationId = requestAnimationFrame(animateCanvas);
                return;
            }
            
            // æ›´æ–°æ€§èƒ½ç›‘æ§
            PerformanceMonitor.update(currentTime);
            
            const canvas = document.getElementById('gameCanvas');
            if (!canvas) {
                requestAnimationFrame(animateCanvas);
                return;
            }
            const ctx = canvas.getContext('2d', { 
                alpha: true,
                desynchronized: true, // å¯ç”¨å¼‚æ­¥æ¸²æŸ“æå‡æ€§èƒ½
                willReadFrequently: false // ä¸é¢‘ç¹è¯»å–ï¼Œä¼˜åŒ–æ¸²æŸ“
            });
            
            // æ€§èƒ½ä¼˜åŒ–ï¼šä½¿ç”¨fillRectä»£æ›¿clearRectï¼ˆæŸäº›æµè§ˆå™¨æ›´å¿«ï¼‰
            ctx.fillStyle = 'rgba(19, 19, 31, 1)'; // èƒŒæ™¯è‰²
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // æ€§èƒ½ä¼˜åŒ–ï¼šå‡å°‘DOMæ“ä½œï¼Œæ‰¹é‡æ›´æ–°
            const handTracker = document.getElementById('handTracker');
            let hx = 0, hy = 0;
            if (G.isHandDetected) {
                hx = (1 - G.handX) * canvas.width; 
                hy = G.handY * canvas.height;
                
                // æ‰¹é‡æ›´æ–°DOMï¼ˆå‡å°‘é‡æ’ï¼‰
                if (!handTracker.classList.contains('active')) {
                    handTracker.classList.add('active');
                }
                handTracker.style.cssText = `left: ${hx - 40}px; top: ${hy - 40}px;`;
                const isClosed = G.handOpenness < 0.5;
                if (isClosed && !handTracker.classList.contains('closed')) {
                    handTracker.classList.add('closed');
                } else if (!isClosed && handTracker.classList.contains('closed')) {
                    handTracker.classList.remove('closed');
                }
                
                // ç»˜åˆ¶æ‰‹éƒ¨æŒ‡ç¤ºå™¨
                const grad = ctx.createRadialGradient(hx, hy, 0, hx, hy, 80);
                grad.addColorStop(0, 'rgba(251,191,36,0.4)');
                grad.addColorStop(1, 'rgba(251,191,36,0)');
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(hx, hy, 80, 0, Math.PI * 2);
                ctx.fill();
            } else {
                if (handTracker.classList.contains('active')) {
                    handTracker.classList.remove('active');
                }
            }

            // æ€§èƒ½ä¼˜åŒ–ï¼šä½¿ç”¨æ›´é«˜æ•ˆçš„è¿‡æ»¤å’Œæ›´æ–°æ–¹å¼ï¼ˆåŸåœ°è¿‡æ»¤ï¼‰
            let writeIdx = 0;
            for (let i = 0; i < G.gameObjects.length; i++) {
                const obj = G.gameObjects[i];
                if (obj.opacity > 0 && obj.active) {
                    if (writeIdx !== i) {
                        G.gameObjects[writeIdx] = obj;
                    }
                    writeIdx++;
                } else {
                    objectPool.release(obj);
                }
            }
            G.gameObjects.length = writeIdx;
            
            // ä¿æŒå¯¹è±¡æ•°é‡ï¼ˆä½¿ç”¨å¯¹è±¡æ± ï¼‰
            const targetCount = G.mode === 'balloon' ? 12 : G.mode === 'fruit' ? 15 : 10;
            if (G.gameObjects.length < targetCount) {
                const needed = targetCount - G.gameObjects.length;
                for (let i = 0; i < needed; i++) {
                    const x = Math.random() * canvas.width;
                    const y = G.mode === 'balloon' ? canvas.height + 50 : -50;
                    G.gameObjects.push(objectPool.get(x, y, G.mode));
                }
            }
            
            // æ‰¹é‡æ›´æ–°å’Œç»˜åˆ¶ï¼Œå‡å°‘DOMæ“ä½œ
            const scoreEl = document.getElementById('scoreValue');
            let scoreUpdated = false;
            
            // æ€§èƒ½ä¼˜åŒ–ï¼šä½¿ç”¨ç©ºé—´åˆ†å‰²ä¼˜åŒ–ç¢°æ’æ£€æµ‹
            SpatialGrid.clear();
            
            // æ›´æ–°æ‰€æœ‰å¯¹è±¡å¹¶æ„å»ºç©ºé—´ç½‘æ ¼
            for (let i = 0; i < G.gameObjects.length; i++) {
                const obj = G.gameObjects[i];
                obj.update(canvas.width, canvas.height);
                if (!obj.popped && obj.active) {
                    SpatialGrid.add(obj);
                }
            }
            
            // ä¼˜åŒ–çš„ç¢°æ’æ£€æµ‹ï¼šåªæ£€æµ‹æ‰‹éƒ¨é™„è¿‘çš„ç‰©ä½“
            const hitRadius = 50;
            const hitRadiusSq = hitRadius * hitRadius;
            
            if (G.isHandDetected) {
                const nearbyObjects = SpatialGrid.getNearby(hx, hy, hitRadius);
                for (let i = 0; i < nearbyObjects.length; i++) {
                    const obj = nearbyObjects[i];
                    if (!obj.popped && obj.active) {
                        const dx = obj.x - hx;
                        const dy = obj.y - hy;
                        const distSq = dx * dx + dy * dy;
                        if (distSq < hitRadiusSq) {
                            obj.popped = true;
                            G.score += 10;
                            scoreUpdated = true;
                        }
                    }
                }
            }
            
            // æ€§èƒ½ä¼˜åŒ–ï¼šæ‰¹é‡ç»˜åˆ¶ï¼Œå‡å°‘çŠ¶æ€åˆ‡æ¢
            // åˆ†ç¦»ä¸é€æ˜å’ŒåŠé€æ˜å¯¹è±¡ï¼Œå…ˆç»˜åˆ¶ä¸é€æ˜çš„
            const opaqueObjects = [];
            const transparentObjects = [];
            
            for (let i = 0; i < G.gameObjects.length; i++) {
                const obj = G.gameObjects[i];
                if (obj.opacity > 0 && obj.active) {
                    if (obj.opacity >= 0.99) {
                        opaqueObjects.push(obj);
                    } else {
                        transparentObjects.push(obj);
                    }
                }
            }
            
            // å…ˆç»˜åˆ¶ä¸é€æ˜å¯¹è±¡ï¼ˆæ›´å¿«ï¼‰
            for (let i = 0; i < opaqueObjects.length; i++) {
                opaqueObjects[i].draw(ctx);
            }
            
            // å†ç»˜åˆ¶åŠé€æ˜å¯¹è±¡ï¼ˆéœ€è¦alphaæ··åˆï¼‰
            // æŒ‰é€æ˜åº¦é™åºæ’åºï¼Œå‡å°‘alphaæ··åˆå¼€é”€
            transparentObjects.sort((a, b) => b.opacity - a.opacity);
            for (let i = 0; i < transparentObjects.length; i++) {
                transparentObjects[i].draw(ctx);
            }
            
            // åªåœ¨åˆ†æ•°å˜åŒ–æ—¶æ›´æ–°DOMï¼ˆæ€§èƒ½ä¼˜åŒ–ï¼‰
            if (scoreUpdated && scoreEl) {
                scoreEl.textContent = G.score;
                showMessage('âœ¨ +10', 400);
            }
            
            // ç»§ç»­åŠ¨ç”»å¾ªç¯
            animationId = requestAnimationFrame(animateCanvas);
        }
        
        // åˆå§‹åŒ–æ—¶è°ƒç”¨animateCanvasï¼ˆå»¶è¿Ÿå¯åŠ¨ï¼Œç¡®ä¿DOMå·²åŠ è½½ï¼‰
        if (isLocalhost) {
            requestAnimationFrame(() => animateCanvas(performance.now()));
        }

        // ============ MediaPipe Handsï¼ˆå‚è€ƒç¤ºä¾‹ç®€åŒ–ç‰ˆæœ¬ï¼‰============
        function initMediaPipe() {
            if (!isLocalhost) return;
            
            const video = document.getElementById('webcam');
            const loader = document.getElementById('loader');
            const statusDot = document.getElementById('handStatus');
            const statusText = document.getElementById('statusText');

            if (!video || !loader || !statusDot || !statusText) {
                console.error('MediaPipe initialization failed: required elements not found');
                return;
            }

            // æ”¯æŒåŒæ‰‹è¯†åˆ«
            const hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });
            
            hands.setOptions({
                maxNumHands: 2, // æ”¯æŒåŒæ‰‹
                modelComplexity: 1, // ä½¿ç”¨æ ‡å‡†æ¨¡å‹å¹³è¡¡æ€§èƒ½å’Œå‡†ç¡®åº¦
                minDetectionConfidence: 0.7, // æé«˜æ£€æµ‹ç½®ä¿¡åº¦ï¼Œå‡å°‘è¯¯æ£€
                minTrackingConfidence: 0.7 // æé«˜è·Ÿè¸ªç½®ä¿¡åº¦ï¼Œæ›´ç¨³å®š
            });

            // ä¼˜åŒ–çš„åŒæ‰‹è¯†åˆ«å¤„ç†å‡½æ•°
            function calculateHandOpenness(landmarks) {
                const wrist = landmarks[0];
                const tips = [4, 8, 12, 16, 20]; // æ‹‡æŒ‡ã€é£ŸæŒ‡ã€ä¸­æŒ‡ã€æ— åæŒ‡ã€å°æŒ‡
                
                // æ–¹æ³•1ï¼šè®¡ç®—æ‰€æœ‰æŒ‡å°–åˆ°æ‰‹è…•çš„å¹³å‡è·ç¦»
                let totalDist = 0;
                tips.forEach(idx => {
                    const tip = landmarks[idx];
                    const d = Math.sqrt(Math.pow(tip.x - wrist.x, 2) + Math.pow(tip.y - wrist.y, 2));
                    totalDist += d;
                });
                const avgDist = totalDist / 5;
                
                // æ–¹æ³•2ï¼šè®¡ç®—æ‹‡æŒ‡å’Œé£ŸæŒ‡çš„è·ç¦»ï¼ˆæ›´å‡†ç¡®ï¼‰
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const thumbIndexDist = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) + 
                    Math.pow(thumbTip.y - indexTip.y, 2)
                );
                
                // æ–¹æ³•3ï¼šè®¡ç®—ä¸­æŒ‡å’Œæ— åæŒ‡çš„è·ç¦»
                const middleTip = landmarks[12];
                const ringTip = landmarks[16];
                const middleRingDist = Math.sqrt(
                    Math.pow(middleTip.x - ringTip.x, 2) + 
                    Math.pow(middleTip.y - ringTip.y, 2)
                );
                
                // ç»¼åˆä¸‰ä¸ªæŒ‡æ ‡ï¼Œæé«˜å‡†ç¡®åº¦
                const avgDistNormalized = (avgDist - 0.12) / 0.35; // å½’ä¸€åŒ–åˆ°0-1
                const thumbIndexNormalized = (thumbIndexDist - 0.05) / 0.2;
                const middleRingNormalized = (middleRingDist - 0.03) / 0.15;
                
                // åŠ æƒå¹³å‡ï¼ˆæ‹‡æŒ‡é£ŸæŒ‡æƒé‡æœ€é«˜ï¼Œå› ä¸ºæœ€å®¹æ˜“è¯†åˆ«ï¼‰
                const openness = (
                    avgDistNormalized * 0.4 + 
                    thumbIndexNormalized * 0.4 + 
                    middleRingNormalized * 0.2
                );
                
                return Math.max(0, Math.min(1, openness));
            }
            
            function processHand(landmarks, handLabel) {
                const hand = handLabel === 'Left' ? G.leftHand : G.rightHand;
                hand.detected = true;
                
                // ä½¿ç”¨ä¸­æŒ‡æ ¹éƒ¨ï¼ˆlandmark 9ï¼‰ä½œä¸ºæ‰‹éƒ¨ä½ç½®
                hand.x = landmarks[9].x;
                hand.y = landmarks[9].y;
                
                // è®¡ç®—æ‰‹éƒ¨å¼€åˆåº¦ï¼ˆä¼˜åŒ–åçš„ç®—æ³•ï¼‰
                hand.openness = calculateHandOpenness(landmarks);
                
                return hand;
            }
            
            function onResults(results) {
                loader.style.opacity = '0';
                setTimeout(() => loader.style.display = 'none', 500);

                // é‡ç½®åŒæ‰‹çŠ¶æ€
                G.leftHand.detected = false;
                G.rightHand.detected = false;
                G.isHandDetected = false;

                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    G.isHandDetected = true;
                    statusDot.classList.add('active');
                    
                    // å¤„ç†æ£€æµ‹åˆ°çš„æ‰€æœ‰æ‰‹
                    results.multiHandLandmarks.forEach((landmarks, index) => {
                        const handLabel = results.multiHandedness[index]?.label || 'Right';
                        const hand = processHand(landmarks, handLabel);
                        
                        // æ›´æ–°ä¸»æ‰‹çŠ¶æ€ï¼ˆç”¨äºå…¼å®¹æ—§ä»£ç å’Œ2Dæ¸¸æˆï¼‰
                        if (index === 0 || handLabel === 'Right') {
                            G.handX = hand.x;
                            G.handY = hand.y;
                            G.handOpenness = hand.openness;
                        }
                    });
                    
                    // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
                    const handCount = results.multiHandLandmarks.length;
                    const handIndicator = document.getElementById('handIndicator');
                    const leftHandDot = document.getElementById('leftHandDot');
                    const rightHandDot = document.getElementById('rightHandDot');
                    
                    if (handCount === 2) {
                        // æ˜¾ç¤ºåŒæ‰‹æŒ‡ç¤ºå™¨
                        if (handIndicator) handIndicator.style.display = 'flex';
                        if (leftHandDot) {
                            leftHandDot.classList.toggle('active', G.leftHand.detected);
                            leftHandDot.classList.add('left');
                        }
                        if (rightHandDot) {
                            rightHandDot.classList.toggle('active', G.rightHand.detected);
                            rightHandDot.classList.add('right');
                        }
                        
                        const leftStatus = G.leftHand.openness > 0.6 ? 'å¼ å¼€' : 'æ¡æ‹³';
                        const rightStatus = G.rightHand.openness > 0.6 ? 'å¼ å¼€' : 'æ¡æ‹³';
                        statusText.textContent = `åŒæ‰‹æ£€æµ‹ | å·¦: ${leftStatus} å³: ${rightStatus}`;
                    } else {
                        // éšè—åŒæ‰‹æŒ‡ç¤ºå™¨
                        if (handIndicator) handIndicator.style.display = 'none';
                        if (leftHandDot) leftHandDot.classList.remove('active', 'left');
                        if (rightHandDot) rightHandDot.classList.remove('active', 'right');
                        
                        const handLabel = results.multiHandedness[0]?.label || 'å³æ‰‹';
                        statusText.textContent = `${handLabel}æ£€æµ‹ | ${G.handOpenness > 0.6 ? 'å¼ å¼€ (æ‰©æ•£)' : 'æ¡æ‹³ (èšæ‹¢)'}`;
                    }
                } else {
                    statusDot.classList.remove('active');
                    statusText.textContent = "æœªæ£€æµ‹åˆ°æ‰‹åŠ¿";
                    // å¹³æ»‘è¿‡æ¸¡åˆ°é»˜è®¤çŠ¶æ€
                    G.handOpenness += (1 - G.handOpenness) * 0.05;
                    G.leftHand.openness += (1 - G.leftHand.openness) * 0.05;
                    G.rightHand.openness += (1 - G.rightHand.openness) * 0.05;
                }
            }

            hands.onResults(onResults);

            // å‚è€ƒç¤ºä¾‹çš„æ‘„åƒå¤´åˆå§‹åŒ–
            const cameraUtils = new Camera(video, {
                onFrame: async () => {
                    await hands.send({ image: video });
                },
                width: 320,
                height: 240
            });

            cameraUtils.start().catch(error => {
                console.error('Camera start failed:', error);
                if (loader) {
                    loader.innerHTML = '<div class="spinner"></div><p style="color:#ef4444;">æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥æƒé™è®¾ç½®</p>';
                }
            });
        }

        // ============ UI ============
        function selectGame(mode) {
            G.mode = mode;
            
            // æ€§èƒ½ä¼˜åŒ–ï¼šæ‰¹é‡DOMæ“ä½œ
            const options = document.querySelectorAll('.game-option');
            for (let i = 0; i < options.length; i++) {
                options[i].classList.remove('active');
            }
            const activeOption = document.querySelector(`[data-game="${mode}"]`);
            if (activeOption) activeOption.classList.add('active');
            
            const three = document.getElementById('threeContainer');
            const canvas = document.getElementById('gameCanvas');
            const controls = document.getElementById('particleControls');
            const scorePanel = document.getElementById('scorePanel');
            const handTracker = document.getElementById('handTracker');
            
            if (mode === 'particles') {
                three.style.display = 'block';
                canvas.style.display = 'none';
                controls.style.display = 'block';
                scorePanel.style.display = 'none';
                if (handTracker) handTracker.classList.remove('active');
                
                // ç¡®ä¿ç²’å­ç³»ç»Ÿå·²åˆå§‹åŒ–
                if (!G.particles) {
                    initThreeJS();
                    requestAnimationFrame(() => animateParticles(performance.now()));
                }
            } else {
                three.style.display = 'none';
                canvas.style.display = 'block';
                controls.style.display = 'none';
                scorePanel.style.display = 'block';
                
                const container = canvas.parentElement;
                if (container) {
                    canvas.width = container.clientWidth;
                    canvas.height = container.clientHeight;
                }
                initCanvasGame(mode);
                
                // å¯åŠ¨canvasåŠ¨ç”»
                if (lastCanvasFrame === 0) {
                    requestAnimationFrame(() => animateCanvas(performance.now()));
                }
            }
        }

        function showMessage(text, dur = 2000) {
            const msg = document.getElementById('gameMessage');
            msg.textContent = text; msg.classList.add('show');
            setTimeout(() => msg.classList.remove('show'), dur);
        }

        // ============ åˆå§‹åŒ–ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼Œå‚è€ƒç¤ºä¾‹ï¼‰============
        function initializeGame() {
            // æ ¹æ®è®¿é—®æ¥æºæ˜¾ç¤º/éšè—æ¸¸æˆéƒ¨åˆ†
            if (!isLocalhost) {
                const gameSection = document.getElementById('game');
                const gameNavItem = document.getElementById('gameNavItem');
                if (gameSection) gameSection.style.display = 'none';
                if (gameNavItem) gameNavItem.style.display = 'none';
                return;
            }
            
            // æ˜¾ç¤ºæ¸¸æˆéƒ¨åˆ†å’Œå¯¼èˆªé¡¹ï¼ˆæœ¬åœ°è®¿é—®ï¼‰
            const gameSection = document.getElementById('game');
            const gameNavItem = document.getElementById('gameNavItem');
            if (gameSection) gameSection.style.display = '';
            if (gameNavItem) gameNavItem.style.display = '';
            
            // ç­‰å¾…DOMå’Œè„šæœ¬åŠ è½½å®Œæˆ
            const initGame = () => {
                if (typeof THREE === 'undefined' || typeof Hands === 'undefined') {
                    setTimeout(initGame, 50);
                    return;
                }
                
                try {
                    initThreeJS();
                    requestAnimationFrame(() => animateParticles(performance.now()));
                    initMediaPipe();
                } catch (error) {
                    console.error('Game initialization error:', error);
                }
            };
            
            // DOMåŠ è½½å®Œæˆååˆå§‹åŒ–
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initGame);
            } else {
                initGame();
            }
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            initializeGame();

            // åªåœ¨æœ¬åœ°è®¿é—®æ—¶ç»‘å®šæ¸¸æˆç›¸å…³äº‹ä»¶
            if (isLocalhost) {
                document.querySelectorAll('.game-option').forEach(opt => {
                    opt.addEventListener('click', () => selectGame(opt.dataset.game));
                });

                document.querySelectorAll('.shape-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        updateTargetPositions(btn.dataset.shape);
                        document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                    });
                });

                const colorPicker = document.getElementById('colorPicker');
                if (colorPicker) {
                    colorPicker.addEventListener('input', (e) => {
                        if (G.particles) G.particles.material.color.set(e.target.value);
                    });
                }

                const resetBtn = document.getElementById('resetBtn');
                if (resetBtn) {
                    resetBtn.addEventListener('click', () => {
                        G.score = 0;
                        const scoreValue = document.getElementById('scoreValue');
                        if (scoreValue) scoreValue.textContent = '0';
                        if (G.mode === 'particles') {
                            updateTargetPositions(G.currentShape);
                        } else {
                            initCanvasGame(G.mode);
                        }
                        showMessage('ğŸ”„ å·²é‡ç½®', 1500);
                    });
                }
            }

            window.addEventListener('scroll', () => {
                document.getElementById('scrollTop').classList.toggle('show', window.pageYOffset > 300);
            });
            document.getElementById('scrollTop').addEventListener('click', () => window.scrollTo({ top: 0, behavior: 'smooth' }));

            document.querySelectorAll('a[href^="#"]').forEach(a => {
                a.addEventListener('click', (e) => {
                    e.preventDefault();
                    const target = document.querySelector(a.getAttribute('href'));
                    if (target && target.style.display !== 'none') {
                        target.scrollIntoView({ behavior: 'smooth' });
                    }
                });
            });

            // æ€§èƒ½ä¼˜åŒ–ï¼šèŠ‚æµresizeäº‹ä»¶
            let resizeTimer;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(() => {
                    const container = document.getElementById('threeContainer');
                    if (G.renderer && container) {
                        G.renderer.setSize(container.clientWidth, container.clientHeight);
                        G.camera.aspect = container.clientWidth / container.clientHeight;
                        G.camera.updateProjectionMatrix();
                    }
                    if (G.mode !== 'particles') {
                        const canvas = document.getElementById('gameCanvas');
                        if (canvas && canvas.parentElement) {
                            canvas.width = canvas.parentElement.clientWidth;
                            canvas.height = canvas.parentElement.clientHeight;
                        }
                    }
                }, 250);
            });
        });
    </script>
</body>
</html>