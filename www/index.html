<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XRK-AGT | å¤šè¯­è¨€ã€å¤šé€‚é…å™¨ã€å·¥ä½œæµé©±åŠ¨å‹æ™ºèƒ½ä½“å¹³å°</title>
    <!-- ç›´æ¥åŠ è½½è„šæœ¬ï¼Œé¿å…åŠ¨æ€åŠ è½½å¯¼è‡´çš„å»¶è¿Ÿ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script>
        // æ£€æµ‹æ˜¯å¦ä¸ºæœ¬åœ°è®¿é—®
        window.isLocalhost = window.location.hostname === 'localhost' || 
                             window.location.hostname === '127.0.0.1' || 
                             window.location.hostname === '[::1]' ||
                             window.location.hostname === '' ||
                             window.location.protocol === 'file:';
    </script>
    <style>
        :root {
            --bg-primary: #0a0a0f;
            --bg-secondary: #13131f;
            --accent-primary: #6366f1;
            --accent-secondary: #8b5cf6;
            --accent-gold: #fbbf24;
            --text-primary: #f8fafc;
            --text-secondary: #94a3b8;
            --glass-bg: rgba(255, 255, 255, 0.03);
            --glass-border: rgba(255, 255, 255, 0.08);
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
        }
        .bg-gradient {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 0;
            background: radial-gradient(ellipse at top, rgba(99, 102, 241, 0.15) 0%, transparent 50%),
                        radial-gradient(ellipse at bottom, rgba(139, 92, 246, 0.1) 0%, transparent 50%);
        }
        .mesh-gradient {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; opacity: 0.3;
            background: radial-gradient(at 40% 20%, rgba(99, 102, 241, 0.25) 0px, transparent 50%),
                        radial-gradient(at 80% 0%, rgba(139, 92, 246, 0.25) 0px, transparent 50%),
                        radial-gradient(at 0% 50%, rgba(251, 191, 36, 0.15) 0px, transparent 50%);
            filter: blur(80px);
            animation: mesh-move 20s ease-in-out infinite;
            will-change: transform; /* æ€§èƒ½ä¼˜åŒ– */
        }
        @keyframes mesh-move {
            0%, 100% { transform: scale(1) translateY(0); }
            50% { transform: scale(1.1) translateY(-20px); }
        }
        nav {
            position: fixed; top: 0; width: 100%; z-index: 1000;
            backdrop-filter: blur(20px) saturate(180%);
            background: rgba(10, 10, 15, 0.7);
            border-bottom: 1px solid var(--glass-border);
        }
        .nav-container {
            max-width: 1400px; margin: 0 auto; padding: 1.2rem 2rem;
            display: flex; justify-content: space-between; align-items: center;
        }
        .logo {
            display: flex; align-items: center; gap: 0.8rem;
            font-size: 1.3rem; font-weight: 700;
            background: linear-gradient(135deg, var(--accent-gold), var(--accent-primary));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }
        .nav-links { display: flex; gap: 2rem; list-style: none; }
        .nav-links a {
            color: var(--text-secondary); text-decoration: none;
            font-weight: 500; transition: color 0.3s; position: relative;
        }
        .nav-links a:hover { color: var(--text-primary); }
        .container { position: relative; z-index: 1; max-width: 1400px; margin: 0 auto; padding: 0 2rem; width: 100%; }
        .hero {
            min-height: 100vh; display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            text-align: center; padding: 8rem 0 4rem;
            max-width: 1200px; margin: 0 auto;
        }
        .sunflower-icon { font-size: 5rem; margin-bottom: 2rem; animation: float 3s ease-in-out infinite; }
        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }
        .hero h1 {
            font-size: clamp(3rem, 8vw, 6rem); font-weight: 800; margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff, var(--accent-gold), var(--accent-primary));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }
        .hero p { font-size: 1.5rem; color: var(--text-secondary); margin-bottom: 3rem; max-width: 600px; }
        .badges { display: flex; gap: 1rem; flex-wrap: wrap; justify-content: center; margin-bottom: 3rem; }
        .badge {
            padding: 0.6rem 1.5rem; background: var(--glass-bg); border: 1px solid var(--glass-border);
            border-radius: 2rem; backdrop-filter: blur(10px); font-size: 0.9rem; color: var(--text-secondary);
            transition: all 0.3s;
        }
        .badge:hover { background: rgba(99, 102, 241, 0.1); border-color: var(--accent-primary); color: var(--text-primary); transform: translateY(-2px); }
        .cta-buttons { display: flex; gap: 1rem; flex-wrap: wrap; justify-content: center; }
        .btn {
            padding: 1rem 2.5rem; border-radius: 1rem; font-weight: 600; text-decoration: none;
            transition: all 0.15s ease; display: inline-flex; align-items: center; gap: 0.5rem;
            border: none; cursor: pointer; font-size: 1rem; user-select: none;
        }
        .btn-primary {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            color: white; box-shadow: 0 10px 30px rgba(99, 102, 241, 0.3);
        }
        .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 15px 40px rgba(99, 102, 241, 0.4); }
        .btn-primary:active { transform: translateY(1px) scale(0.98); }
        .btn-secondary {
            background: var(--glass-bg); color: var(--text-primary);
            border: 1px solid var(--glass-border); backdrop-filter: blur(10px);
        }
        .btn-secondary:hover { background: rgba(255, 255, 255, 0.08); transform: translateY(-2px); }
        .btn-secondary:active { transform: translateY(1px) scale(0.98); }
        .game-section { padding: 6rem 0; min-height: 100vh; display: flex; flex-direction: column; align-items: center; }
        .section-title { font-size: 2.5rem; font-weight: 700; text-align: center; margin-bottom: 2rem; }
        .docs-section { padding: 6rem 0; max-width: 1200px; margin: 0 auto; width: 100%; box-sizing: border-box; }
        .docs-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 2rem; margin-top: 3rem; padding: 0 2rem; }
        .docs-card {
            background: var(--glass-bg); border: 1px solid var(--glass-border); border-radius: 1.5rem;
            padding: 2rem; transition: all 0.3s; backdrop-filter: blur(10px);
            will-change: transform; /* æ€§èƒ½ä¼˜åŒ– */
        }
        .docs-card:hover { transform: translateY(-5px); border-color: var(--accent-primary); background: rgba(99, 102, 241, 0.1); }
        .docs-card h3 { font-size: 1.5rem; margin-bottom: 1rem; color: var(--accent-gold); 
                        background: linear-gradient(135deg, var(--accent-gold), var(--accent-primary));
                        -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .docs-card ul { list-style: none; padding: 0; margin: 0; }
        .docs-card li { padding: 0.5rem 0; color: var(--text-secondary); line-height: 1.6; }
        .docs-card li:before { content: "â–¸ "; color: var(--accent-primary); margin-right: 0.5rem; font-weight: bold; }
        .game-selector {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem; max-width: 1200px; margin: 0 auto 3rem; padding: 0 2rem;
            width: 100%;
        }
        .game-option {
            background: var(--glass-bg); border: 2px solid var(--glass-border); border-radius: 1.5rem;
            padding: 2rem; cursor: pointer; transition: all 0.3s; text-align: center; 
            position: relative; overflow: hidden; will-change: transform; /* æ€§èƒ½ä¼˜åŒ– */
        }
        .game-option::before {
            content: ''; position: absolute; top: 0; left: 0; right: 0; height: 3px;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
            transform: scaleX(0); transition: transform 0.3s;
        }
        .game-option:hover { transform: translateY(-5px); border-color: var(--accent-primary); background: rgba(99, 102, 241, 0.1); }
        .game-option:hover::before { transform: scaleX(1); }
        .game-option.active { border-color: var(--accent-gold); background: rgba(251, 191, 36, 0.1); box-shadow: 0 0 30px rgba(251, 191, 36, 0.3); }
        .game-option-icon { font-size: 4rem; margin-bottom: 1rem; display: block; }
        .game-option h3 { font-size: 1.3rem; margin-bottom: 0.5rem; }
        .game-option p { color: var(--text-secondary); font-size: 0.9rem; }
        .game-container {
            width: 95%; max-width: 1600px; height: 80vh; min-height: 600px; 
            margin: 0 auto; position: relative; background: var(--bg-secondary); 
            border: 3px solid var(--glass-border); border-radius: 2rem; 
            overflow: hidden; box-shadow: 0 30px 80px rgba(0, 0, 0, 0.6);
        }
        #threeContainer, #gameCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        .video-feed {
            position: absolute; bottom: 20px; left: 20px; width: 160px; height: 120px;
            border-radius: 12px; border: 2px solid var(--glass-border); opacity: 0.7;
            z-index: 10; transform: scaleX(-1); transition: opacity 0.3s; background: #000;
        }
        .video-feed:hover { opacity: 1; }
        .game-hud {
            position: absolute; top: 20px; left: 0; right: 0; padding: 0 2rem;
            display: flex; justify-content: space-between; align-items: flex-start;
            pointer-events: none; z-index: 10;
        }
        .hud-panel {
            background: rgba(0, 0, 0, 0.7); padding: 1.5rem 2rem; border-radius: 1.5rem;
            backdrop-filter: blur(20px); border: 2px solid rgba(255, 255, 255, 0.1); min-width: 180px;
        }
        .hud-title { font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 0.5rem; text-transform: uppercase; letter-spacing: 1px; }
        .hud-value {
            font-size: 2rem; font-weight: 700;
            background: linear-gradient(135deg, var(--accent-gold), var(--accent-primary));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }
        .status-badge { display: inline-flex; align-items: center; gap: 6px; padding: 6px 12px; border-radius: 20px; font-size: 0.8rem; background: rgba(255, 255, 255, 0.05); margin-top: 0.5rem; }
        .status-dot { width: 8px; height: 8px; border-radius: 50%; background: #ef4444; transition: background 0.3s; }
        .status-dot.active { background: #22c55e; box-shadow: 0 0 10px #22c55e; }
        .status-dot.active.dual { background: #3b82f6; box-shadow: 0 0 10px #3b82f6; } /* åŒæ‰‹æ£€æµ‹æ—¶çš„é¢œè‰² */
        .hand-status { display: flex; gap: 10px; margin-top: 8px; font-size: 0.75rem; }
        .hand-indicator { display: flex; align-items: center; gap: 4px; }
        .hand-dot { width: 6px; height: 6px; border-radius: 50%; background: #64748b; transition: background 0.3s; }
        .hand-dot.open { background: #22c55e; box-shadow: 0 0 6px #22c55e; }
        .hand-dot.closed { background: #ef4444; box-shadow: 0 0 6px #ef4444; }
        .status-dot.active.dual { background: #3b82f6; box-shadow: 0 0 10px #3b82f6; } /* åŒæ‰‹æ£€æµ‹æ—¶çš„é¢œè‰² */
        .hand-status { display: flex; gap: 10px; margin-top: 8px; font-size: 0.75rem; }
        .hand-indicator { display: flex; align-items: center; gap: 4px; }
        .hand-dot { width: 6px; height: 6px; border-radius: 50%; background: #64748b; }
        .hand-dot.open { background: #22c55e; }
        .hand-dot.closed { background: #ef4444; }
        .particle-controls {
            position: absolute; top: 20px; right: 20px; width: 280px;
            background: rgba(15, 15, 20, 0.85); backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border); border-radius: 20px; padding: 20px; z-index: 100; pointer-events: auto;
        }
        .control-group { margin-bottom: 15px; }
        .control-label { font-size: 0.85rem; color: #94a3b8; margin-bottom: 8px; display: block; }
        .shape-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; }
        .shape-btn {
            background: var(--glass-bg); border: 1px solid var(--glass-border); color: var(--text-primary);
            padding: 8px; border-radius: 8px; cursor: pointer; font-size: 0.8rem; transition: all 0.3s;
        }
        .shape-btn:hover, .shape-btn.active { background: var(--accent-primary); border-color: var(--accent-primary); box-shadow: 0 0 15px rgba(99, 102, 241, 0.4); }
        .color-picker-wrapper { display: flex; align-items: center; gap: 10px; background: var(--glass-bg); padding: 8px; border-radius: 8px; }
        input[type="color"] { -webkit-appearance: none; border: none; width: 30px; height: 30px; border-radius: 50%; overflow: hidden; cursor: pointer; background: none; }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: none; border-radius: 50%; border: 2px solid rgba(255, 255, 255, 0.2); }
        .hand-tracker {
            position: absolute; width: 80px; height: 80px; border: 4px solid var(--accent-gold);
            border-radius: 50%; box-shadow: 0 0 30px rgba(251, 191, 36, 0.6);
            pointer-events: none; z-index: 20; 
            transition: transform 0.1s cubic-bezier(0.4, 0, 0.2, 1), border-color 0.2s ease; 
            display: none;
            will-change: transform; /* æ€§èƒ½ä¼˜åŒ– */
        }
        .hand-tracker.active { display: block; }
        .hand-tracker.closed { border-color: #ef4444; box-shadow: 0 0 40px rgba(239, 68, 68, 0.8); }
        .game-controls { display: flex; gap: 1rem; margin-top: 2rem; flex-wrap: wrap; justify-content: center; }
        .game-message {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 3rem; font-weight: 700; color: white; text-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            opacity: 0; pointer-events: none; z-index: 30; transition: opacity 0.3s; text-align: center; padding: 2rem;
        }
        .game-message.show { opacity: 1; }
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(10, 10, 15, 0.95); z-index: 9999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 0.5s;
        }
        #loader.hidden { opacity: 0; pointer-events: none; }
        .spinner { width: 50px; height: 50px; border: 4px solid var(--accent-primary); border-top-color: transparent; border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px; }
        @keyframes spin { to { transform: rotate(360deg); } }
        footer { padding: 4rem 0 2rem; text-align: center; border-top: 1px solid var(--glass-border); max-width: 1200px; margin: 0 auto; }
        .scroll-top {
            position: fixed; bottom: 2rem; right: 2rem; width: 3rem; height: 3rem;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            border-radius: 50%; display: flex; align-items: center; justify-content: center;
            cursor: pointer; opacity: 0; transition: all 0.3s; z-index: 100; border: none; color: white; font-size: 1.2rem;
        }
        .scroll-top.show { opacity: 1; }
        .scroll-top:hover { transform: translateY(-5px); }
        @media (max-width: 768px) {
            .nav-links { display: none; }
            .hero h1 { font-size: 3rem; }
            .game-container { width: 98%; height: 60vh; }
            .game-hud { flex-direction: column; padding: 1rem; }
            .hud-panel { min-width: auto; padding: 1rem 1.5rem; }
            .particle-controls { width: 220px; padding: 15px; top: auto; bottom: 150px; right: 10px; }
            .game-selector { grid-template-columns: 1fr; }
            .docs-grid { grid-template-columns: 1fr; }
            .docs-section { padding: 3rem 1rem; }
            .container { padding: 0 1rem; }
        }
    </style>
</head>
<body>
    <div class="bg-gradient"></div>
    <div class="mesh-gradient"></div>
    <nav>
        <div class="nav-container">
            <div class="logo"><span>ğŸŒ»</span><span>XRK-AGT</span></div>
            <ul class="nav-links">
                <li><a href="#home">é¦–é¡µ</a></li>
                <li><a href="#docs">æ–‡æ¡£</a></li>
                <li id="gameNavItem" style="display:none;"><a href="#game">äº¤äº’æ¸¸æˆ</a></li>
                <li><a href="https://gitcode.com/Xrkseek/XRK-AGT" target="_blank">é¡¹ç›®ä»“åº“</a></li>
            </ul>
        </div>
    </nav>
    <div class="container">
        <section id="home" class="hero">
            <div class="sunflower-icon">ğŸŒ»</div>
            <h1>XRK-AGT</h1>
            <p>å¤šè¯­è¨€ã€å¤šé€‚é…å™¨ã€å·¥ä½œæµé©±åŠ¨å‹æ™ºèƒ½ä½“å¹³å°</p>
            <div class="badges">
                <span class="badge">âš¡ å¤šå¹³å°æ¥å…¥</span>
                <span class="badge">ğŸ”Œ æ’ä»¶å·¥ä½œæµ</span>
                <span class="badge">ğŸŒ Webæ§åˆ¶å°</span>
                <span class="badge">ğŸ¤– AIå·¥ä½œæµ</span>
                <span class="badge">ğŸ¨ æ¸²æŸ“æˆªå›¾</span>
            </div>
            <div class="cta-buttons">
                <a href="#docs" class="btn btn-primary"><span>æŸ¥çœ‹æ–‡æ¡£</span><span>â†’</span></a>
                <a href="https://gitcode.com/Xrkseek/XRK-AGT" target="_blank" class="btn btn-secondary"><span>æŸ¥çœ‹æºç </span></a>
            </div>
        </section>
    </div>
    <section id="docs" class="docs-section">
        <h2 class="section-title">ğŸ“š é¡¹ç›®æ–‡æ¡£</h2>
        <div class="docs-grid">
            <div class="docs-card">
                <h3>ğŸš€ å¿«é€Ÿå¼€å§‹</h3>
                <ul>
                    <li>Node.js â‰¥ 18.14.0</li>
                    <li>Redis â‰¥ 5.0.0</li>
                    <li>æ”¯æŒ Windows / Linux</li>
                    <li>éœ€è¦ Chrome/Chromium/Edgeï¼ˆæ¸²æŸ“åŠŸèƒ½ï¼‰</li>
                </ul>
            </div>
            <div class="docs-card">
                <h3>ğŸ”Œ æ ¸å¿ƒç‰¹æ€§</h3>
                <ul>
                    <li>å¤šå¹³å°æ¶ˆæ¯æ¥å…¥ï¼ˆOneBotv11 / ComWeChatï¼‰</li>
                    <li>æ’ä»¶å·¥ä½œæµ + AI å·¥ä½œæµ</li>
                    <li>Web æ§åˆ¶å° + REST API + WebSocket</li>
                    <li>åŸºäº Puppeteer/Playwright çš„æ¸²æŸ“</li>
                </ul>
            </div>
            <div class="docs-card">
                <h3>ğŸ“– æ–‡æ¡£å¯¼èˆª</h3>
                <ul>
                    <li>é¡¹ç›®æ¦‚è§ˆï¼šäº†è§£æ•´ä½“æ¶æ„</li>
                    <li>Bot ä¸»ç±»ï¼šæ ¸å¿ƒè¿è¡Œæ—¶å¯¹è±¡</li>
                    <li>æ’ä»¶ç³»ç»Ÿï¼šè§„åˆ™åŒ¹é…ä¸ä¸Šä¸‹æ–‡ç®¡ç†</li>
                    <li>é€‚é…å™¨ç³»ç»Ÿï¼šå¤šå¹³å°åè®®å¯¹æ¥</li>
                    <li>AI å·¥ä½œæµï¼šChat Completion ä¸ Embedding</li>
                </ul>
            </div>
            <div class="docs-card">
                <h3>ğŸ—ï¸ é¡¹ç›®ç»“æ„</h3>
                <ul>
                    <li>src/ï¼šè¿è¡Œæ ¸å¿ƒä¸åŸºç¡€è®¾æ–½</li>
                    <li>core/ï¼šé€‚é…å™¨ã€APIã€å·¥ä½œæµ</li>
                    <li>config/ï¼šé»˜è®¤é…ç½®ä¸å‘½ä»¤è¡Œå·¥å…·</li>
                    <li>docs/ï¼šå®Œæ•´æ¨¡å—æ–‡æ¡£</li>
                    <li>www/ï¼šå‰ç«¯é™æ€èµ„æº</li>
                </ul>
            </div>
            <div class="docs-card">
                <h3>ğŸ’¡ ä½¿ç”¨åœºæ™¯</h3>
                <ul>
                    <li>æ­å»º QQ æ™ºèƒ½ä½“ï¼ˆèŠå¤©æœºå™¨äººï¼‰</li>
                    <li>ä»»åŠ¡åŠ©æ‰‹ä¸æ•°æ®ç›‘æ§</li>
                    <li>å‚ç›´åœºæ™¯è‡ªåŠ¨åŒ–å·¥ä½œæµ</li>
                    <li>å¯æ‰©å±•çš„ Bot å¹³å°</li>
                </ul>
            </div>
            <div class="docs-card">
                <h3>ğŸ”§ å¼€å‘æŒ‡å—</h3>
                <ul>
                    <li>é˜…è¯» PROJECT_OVERVIEW.md</li>
                    <li>æŸ¥çœ‹ docs/README.md</li>
                    <li>å‚è€ƒ docs/app-dev.md</li>
                    <li>äº†è§£æ’ä»¶ä¸é€‚é…å™¨å¼€å‘</li>
                </ul>
            </div>
        </div>
    </section>
    <section id="game" class="game-section" style="display:none;">
        <h2 class="section-title">ğŸ® é€‰æ‹©ä½ çš„æ¸¸æˆ</h2>
        <div class="game-selector">
            <div class="game-option active" data-game="particles"><span class="game-option-icon">âœ¨</span><h3>3Dç²’å­äº¤äº’</h3><p>æ‰‹åŠ¿æ§åˆ¶ç²’å­å½¢æ€å˜æ¢</p></div>
            <div class="game-option" data-game="sunflower"><span class="game-option-icon">ğŸŒ»</span><h3>å‘æ—¥è‘µæ”¶é›†</h3><p>æŠ“å–å‘æ—¥è‘µå¾—åˆ†</p></div>
            <div class="game-option" data-game="balloon"><span class="game-option-icon">ğŸˆ</span><h3>æ°”çƒæ´¾å¯¹</h3><p>å¿«é€Ÿæ‹æ‰“ä¸Šå‡æ°”çƒ</p></div>
            <div class="game-option" data-game="fruit"><span class="game-option-icon">ğŸ</span><h3>æ°´æœå¿è€…</h3><p>æŒ¥æ‰‹åˆ‡å‰²æ‰è½æ°´æœ</p></div>
        </div>
        <div class="game-container">
            <div id="loader"><div class="spinner"></div><p style="color:#94a3b8;">æ­£åœ¨åˆå§‹åŒ– AI è§†è§‰å¼•æ“...</p><p style="font-size:0.8rem;margin-top:10px;color:#64748b;">è¯·å…è®¸æ‘„åƒå¤´æƒé™</p></div>
            <div id="threeContainer"></div>
            <canvas id="gameCanvas" style="display:none;"></canvas>
            <video id="webcam" class="video-feed" playsinline></video>
            <div class="hand-tracker" id="handTracker"></div>
            <div class="game-hud">
                <div class="hud-panel">
                    <div class="hud-title">æ‰‹åŠ¿çŠ¶æ€</div>
                    <div class="status-badge"><div class="status-dot" id="handStatus"></div><span id="statusText">ç­‰å¾…æ‰‹åŠ¿...</span></div>
                    <div class="hand-status" id="handStatusDetail" style="display: none; margin-top: 8px;">
                        <div class="hand-indicator">
                            <div class="hand-dot" id="hand1Dot"></div>
                            <span style="font-size: 0.7rem;">å·¦æ‰‹</span>
                        </div>
                        <div class="hand-indicator">
                            <div class="hand-dot" id="hand2Dot"></div>
                            <span style="font-size: 0.7rem;">å³æ‰‹</span>
                        </div>
                    </div>
                </div>
                <div class="hud-panel" id="scorePanel" style="display:none;">
                    <div class="hud-title">åˆ†æ•°</div>
                    <div class="hud-value" id="scoreValue">0</div>
                </div>
            </div>
            <div class="particle-controls" id="particleControls">
                <div class="control-group">
                    <label class="control-label">ç²’å­å½¢çŠ¶</label>
                    <div class="shape-grid">
                        <button class="shape-btn active" data-shape="heart">â¤ï¸ çˆ±å¿ƒ</button>
                        <button class="shape-btn" data-shape="saturn">ğŸª åœŸæ˜Ÿ</button>
                        <button class="shape-btn" data-shape="flower">ğŸŒ¸ èŠ±æœµ</button>
                        <button class="shape-btn" data-shape="buddha">ğŸ§˜ ä½›åƒ</button>
                        <button class="shape-btn" data-shape="fireworks">ğŸ† çƒŸèŠ±</button>
                        <button class="shape-btn" data-shape="dna">ğŸ§¬ DNA</button>
                    </div>
                </div>
                <div class="control-group">
                    <label class="control-label">ç²’å­é¢œè‰²</label>
                    <div class="color-picker-wrapper">
                        <input type="color" id="colorPicker" value="#6366f1">
                        <span style="font-size:0.9rem;">è‡ªå®šä¹‰é¢œè‰²</span>
                    </div>
                </div>
                <div class="control-group">
                    <label class="control-label">æ“ä½œæç¤º</label>
                    <p style="font-size:0.8rem;color:#94a3b8;line-height:1.5;">ğŸ– <b>å¼ å¼€æ‰‹æŒ</b>ï¼šç²’å­å¤§å¹…æ‰©æ•£<br>âœŠ <b>æ¡ç´§æ‹³å¤´</b>ï¼šç²’å­å¤§å¹…èšæ‹¢<br>ğŸ‘‹ <b>ç§»åŠ¨æ‰‹æŒ</b>ï¼šæ—‹è½¬è§†è§’<br>ğŸ¤² <b>åŒæ‰‹å¼ å¼€</b>ï¼šé¢å¤–æ”¾å¤§æ•ˆæœ<br>âœŠâœŠ <b>åŒæ‰‹æ¡æ‹³</b>ï¼šæè‡´èšæ‹¢æ•ˆæœ</p>
                </div>
            </div>
            <div class="game-message" id="gameMessage"></div>
        </div>
        <div class="game-controls">
            <button class="btn btn-secondary" id="resetBtn"><span>ğŸ”„</span><span>é‡ç½®æ¸¸æˆ</span></button>
        </div>
    </section>
    <footer>
        <p style="color:var(--text-secondary);">Â© 2024 XRK-AGT | å¤šè¯­è¨€ã€å¤šé€‚é…å™¨ã€å·¥ä½œæµé©±åŠ¨å‹æ™ºèƒ½ä½“å¹³å°</p>
        <p style="color:var(--text-secondary);margin-top:1rem;font-size:0.9rem;">æ°¸è¿œå‘ç€é˜³å…‰ç”Ÿé•¿ ğŸŒ»</p>
    </footer>
    <button class="scroll-top" id="scrollTop">â†‘</button>

    <script>
        // ============ è®¿é—®æ£€æµ‹ ============
        const isLocalhost = window.isLocalhost || (window.location.hostname === 'localhost' || 
                           window.location.hostname === '127.0.0.1' || 
                           window.location.hostname === '[::1]' ||
                           window.location.hostname === '');

        // ============ å…¨å±€çŠ¶æ€ ============
        const G = {
            mode: 'particles',
            // åŒæ‰‹æ”¯æŒ
            hands: [
                { x: 0.5, y: 0.5, openness: 1.0, detected: false },
                { x: 0.5, y: 0.5, openness: 1.0, detected: false }
            ],
            // å…¼å®¹æ—§ä»£ç 
            handX: 0.5, handY: 0.5,
            handOpenness: 1.0,
            isHandDetected: false,
            scene: null, camera: null, renderer: null, particles: null,
            particleCount: isLocalhost ? 5000 : 3500, // æ ¹æ®è®¿é—®æ¥æºè°ƒæ•´ç²’å­æ•°
            positions: null, targetPositions: null,
            currentShape: 'heart',
            gameObjects: [], score: 0,
            canvasW: 0, canvasH: 0,
            lastFrameTime: 0,
            targetFPS: 60,
            frameInterval: 1000 / 60,
            // å¹³æ»‘æ’å€¼çŠ¶æ€ï¼ˆç”¨äºå‡å°‘é—ªåŠ¨ï¼‰
            smoothHandPositions: [
                { x: 0.5, y: 0.5, vx: 0, vy: 0 },
                { x: 0.5, y: 0.5, vx: 0, vy: 0 }
            ]
        };

        // ============ Three.js ç²’å­ç³»ç»Ÿï¼ˆå‚è€ƒä¼˜åŒ–ç‰ˆæœ¬ï¼‰============
        function initThreeJS() {
            const container = document.getElementById('threeContainer');
            if (!container) return;
            
            G.scene = new THREE.Scene();
            G.scene.fog = new THREE.FogExp2(0x0a0a0f, 0.002);
            
            G.camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            G.camera.position.z = 30;
            
            // ä¼˜åŒ–æ¸²æŸ“å™¨è®¾ç½®ï¼ˆå‚è€ƒç¤ºä¾‹ï¼‰
            G.renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                powerPreference: "high-performance"
            });
            G.renderer.setSize(container.clientWidth, container.clientHeight);
            G.renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(G.renderer.domElement);

            // ç”Ÿæˆåœ†å½¢çº¹ç†ï¼ˆå¤ç”¨å‡½æ•°ï¼‰
            function getTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 32;
                canvas.height = 32;
                const ctx = canvas.getContext('2d');
                const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
                grad.addColorStop(0, 'rgba(255,255,255,1)');
                grad.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, 32, 32);
                const texture = new THREE.Texture(canvas);
                texture.needsUpdate = true;
                return texture;
            }

            // åˆ›å»ºå‡ ä½•ä½“å’Œæè´¨
            const geometry = new THREE.BufferGeometry();
            G.positions = new Float32Array(G.particleCount * 3);
            G.targetPositions = new Float32Array(G.particleCount * 3);
            
            // åˆå§‹åŒ–éšæœºä½ç½®
            for (let i = 0; i < G.particleCount; i++) {
                G.positions[i * 3] = (Math.random() - 0.5) * 100;
                G.positions[i * 3 + 1] = (Math.random() - 0.5) * 100;
                G.positions[i * 3 + 2] = (Math.random() - 0.5) * 100;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(G.positions, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.5, // å‚è€ƒç¤ºä¾‹çš„å¤§å°
                map: getTexture(),
                transparent: true,
                opacity: 0.8,
                vertexColors: false,
                color: new THREE.Color(0x6366f1),
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            G.particles = new THREE.Points(geometry, material);
            G.scene.add(G.particles);
            updateTargetPositions('heart');
        }

        const Shapes = {
            heart: (i) => { const t = Math.random() * Math.PI * 2, r = Math.random(); const x = 16 * Math.pow(Math.sin(t), 3), y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t); return { x: x * 0.5 * r, y: y * 0.5 * r, z: (Math.random() - 0.5) * 4 }; },
            saturn: (i) => { if (Math.random() > 0.6) { const a = Math.random() * Math.PI * 2, rad = 12 + Math.random() * 6; return { x: Math.cos(a) * rad, y: (Math.random()-0.5), z: Math.sin(a) * rad }; } const phi = Math.acos(-1 + 2 * Math.random()), theta = Math.sqrt(G.particleCount * Math.PI) * phi, r = 7; return { x: r * Math.cos(theta) * Math.sin(phi), y: r * Math.sin(theta) * Math.sin(phi), z: r * Math.cos(phi) }; },
            flower: (i) => { const theta = Math.random() * Math.PI * 2, phi = Math.random() * Math.PI, k = 4, r = 10 * Math.sin(k * theta) * Math.sin(phi); return { x: r * Math.sin(phi) * Math.cos(theta), y: r * Math.cos(phi), z: r * Math.sin(phi) * Math.sin(theta) }; },
            buddha: (i) => { const rand = Math.random(); if (rand < 0.2) { const r = 2.5, u = Math.random(), v = Math.random(), theta = 2 * Math.PI * u, phi = Math.acos(2 * v - 1); return { x: r * Math.sin(phi) * Math.cos(theta), y: r * Math.sin(phi) * Math.sin(theta) + 6, z: r * Math.cos(phi) }; } if (rand < 0.7) { const h = Math.random() * 7, theta = Math.random() * Math.PI * 2, coneR = 6 * (1 - h/7); return { x: coneR * Math.cos(theta), y: h - 1, z: coneR * Math.sin(theta) }; } const a = Math.random() * Math.PI * 2, rad = 5 + Math.random() * 4; return { x: Math.cos(a) * rad, y: -2 + Math.random() * 2, z: Math.sin(a) * rad }; },
            fireworks: (i) => { const r = Math.random() * 15, theta = Math.random() * Math.PI * 2, phi = Math.acos(2 * Math.random() - 1); return { x: r * Math.sin(phi) * Math.cos(theta), y: r * Math.sin(phi) * Math.sin(theta), z: r * Math.cos(phi) }; },
            dna: (i) => { const t = (i / G.particleCount) * Math.PI * 20, radius = 5, height = 20, y = (i / G.particleCount) * height - height/2; let x = Math.cos(t) * radius, z = Math.sin(t) * radius; if (i % 2 === 0) { x = Math.cos(t + Math.PI) * radius; z = Math.sin(t + Math.PI) * radius; } if (Math.random() > 0.8) { const r = (Math.random() * 2 - 1) * radius; x = Math.cos(t) * r; z = Math.sin(t) * r; } return { x, y, z }; }
        };

        function updateTargetPositions(name) {
            const func = Shapes[name]; if (!func) return;
            for (let i = 0; i < G.particleCount; i++) {
                const pos = func(i);
                G.targetPositions[i * 3] = pos.x;
                G.targetPositions[i * 3 + 1] = pos.y;
                G.targetPositions[i * 3 + 2] = pos.z;
            }
            G.currentShape = name;
        }

        function animateParticles(currentTime) {
            // å…ˆæ£€æŸ¥æ¡ä»¶ï¼Œé¿å…ä¸å¿…è¦çš„ requestAnimationFrame è°ƒç”¨
            if (G.mode !== 'particles' || !G.particles) {
                requestAnimationFrame(animateParticles);
                return;
            }
            
            // åˆå§‹åŒ– lastFrameTimeï¼ˆä¿®å¤å¡ä½é—®é¢˜ï¼‰
            if (G.lastFrameTime === 0) {
                G.lastFrameTime = currentTime;
            }
            
            // æ€§èƒ½ä¼˜åŒ–ï¼šä½¿ç”¨å›ºå®šæ—¶é—´æ­¥é•¿ï¼ˆæ›´æµç•…ï¼‰
            const elapsed = currentTime - G.lastFrameTime;
            const deltaTime = Math.min(elapsed, 100); // é™åˆ¶æœ€å¤§deltaTimeé¿å…è·³å¸§
            
            if (elapsed < G.frameInterval) {
                requestAnimationFrame(animateParticles);
                return;
            }
            G.lastFrameTime = currentTime;
            
            const pos = G.particles.geometry.attributes.position.array;
            const targetPos = G.targetPositions;
            
            // åŸºç¡€æ—‹è½¬
            G.particles.rotation.y += 0.002;
            
            // åŒæ‰‹æ§åˆ¶æ—‹è½¬ï¼ˆä½¿ç”¨åŒæ‰‹çš„å¹³å‡ä½ç½®ï¼‰
            let hasHand = false;
            let avgX = 0.5, avgY = 0.5;
            
            if (G.hands[0].detected) {
                avgX += G.hands[0].x;
                avgY += G.hands[0].y;
                hasHand = true;
            }
            if (G.hands[1].detected) {
                avgX += G.hands[1].x;
                avgY += G.hands[1].y;
                hasHand = true;
            }
            
            if (hasHand) {
                avgX = avgX / (G.hands[0].detected ? (G.hands[1].detected ? 2 : 1) : 1);
                avgY = avgY / (G.hands[0].detected ? (G.hands[1].detected ? 2 : 1) : 1);
                
                const rotY = (avgX - 0.5) * 0.05;
                const rotX = (avgY - 0.5) * 0.05;
                G.particles.rotation.y += rotY;
                G.particles.rotation.x += rotX;
            } else if (G.isHandDetected) {
                // å…¼å®¹æ—§ä»£ç 
                const rotY = (G.handX - 0.5) * 0.05;
                const rotX = (G.handY - 0.5) * 0.05;
                G.particles.rotation.y += rotY;
                G.particles.rotation.x += rotX;
            }
            
            // åŒæ‰‹æ”¯æŒï¼šè®¡ç®—å¹³å‡å¼€åˆåº¦ï¼ˆæ›´å¤§çš„æ‰©å±•å·®å¼‚ï¼‰
            let avgOpenness = 1.0;
            let handCount = 0;
            
            if (G.hands[0].detected) {
                avgOpenness += G.hands[0].openness;
                handCount++;
            }
            if (G.hands[1].detected) {
                avgOpenness += G.hands[1].openness;
                handCount++;
            }
            
            if (handCount > 0) {
                avgOpenness = avgOpenness / handCount;
            } else {
                // å…¼å®¹æ—§ä»£ç 
                avgOpenness = G.handOpenness;
            }
            
            // å¢å¤§æ‰©å±•å·®å¼‚ï¼šæ¡æ‹³(0) -> 0.2å€ï¼Œå¼ å¼€(1) -> 1.8å€ï¼ˆå·®å¼‚æ›´å¤§ï¼‰
            let scaleFactor = 0.2 + (avgOpenness * 1.6); // èŒƒå›´ï¼š0.2 - 1.8
            
            // çƒŸèŠ±æ¨¡å¼ï¼šå·®å¼‚æ›´å¤§
            if (G.currentShape === 'fireworks') {
                scaleFactor = 0.3 + (avgOpenness * 2.7); // èŒƒå›´ï¼š0.3 - 3.0
            }
            
            // åŒæ‰‹åŒæ—¶å¼ å¼€æ—¶ï¼Œé¢å¤–æ”¾å¤§æ•ˆæœ
            if (handCount === 2 && G.hands[0].openness > 0.7 && G.hands[1].openness > 0.7) {
                scaleFactor *= 1.2; // åŒæ‰‹å¼ å¼€æ—¶é¢å¤–æ”¾å¤§20%
            }
            
            const speed = 0.05; // å‚è€ƒç¤ºä¾‹çš„é€Ÿåº¦
            
            // å‚è€ƒç¤ºä¾‹çš„ç®€å•æ’å€¼å¾ªç¯ï¼ˆæ›´é«˜æ•ˆï¼‰
            const positionsArr = pos;
            const targetArr = targetPos;
            
            for (let i = 0; i < G.particleCount; i++) {
                const px = i * 3;
                const py = i * 3 + 1;
                const pz = i * 3 + 2;

                const tx = targetArr[px] * scaleFactor;
                const ty = targetArr[py] * scaleFactor;
                const tz = targetArr[pz] * scaleFactor;

                // ç®€å•çš„ Lerp æ’å€¼ï¼ˆå‚è€ƒç¤ºä¾‹ï¼‰
                positionsArr[px] += (tx - positionsArr[px]) * speed;
                positionsArr[py] += (ty - positionsArr[py]) * speed;
                positionsArr[pz] += (tz - positionsArr[pz]) * speed;
            }
            
            // åªåœ¨ä½ç½®å˜åŒ–æ—¶æ›´æ–°ï¼ˆæ€§èƒ½ä¼˜åŒ–ï¼‰
            G.particles.geometry.attributes.position.needsUpdate = true;
            
            // ä½¿ç”¨requestAnimationFrameè‡ªåŠ¨åŒæ­¥åˆ·æ–°ç‡
            G.renderer.render(G.scene, G.camera);
            
            // ç»§ç»­åŠ¨ç”»å¾ªç¯
            requestAnimationFrame(animateParticles);
        }

        // ============ 2Dæ¸¸æˆï¼ˆé«˜æ€§èƒ½ä¼˜åŒ–ç‰ˆæœ¬ï¼‰============
        // å¯¹è±¡æ± ï¼šé‡ç”¨å¯¹è±¡å‡å°‘GCå‹åŠ›
        const objectPool = {
            pool: [],
            get(x, y, type) {
                let obj = this.pool.find(o => !o.active);
                if (!obj) {
                    obj = new GameObject(x, y, type);
                    this.pool.push(obj);
                } else {
                    obj.reset(x, y, type);
                }
                return obj;
            },
            release(obj) {
                obj.active = false;
            }
        };

        // ä½å›¾ç¼“å­˜ï¼šé¢„æ¸²æŸ“emojiåˆ°canvasï¼Œé¿å…é‡å¤ç»˜åˆ¶
        const emojiCache = new Map();
        function getEmojiImage(emoji, size) {
            const key = `${emoji}-${size}`;
            if (emojiCache.has(key)) {
                return emojiCache.get(key);
            }
            const canvas = document.createElement('canvas');
            canvas.width = size * 2;
            canvas.height = size * 2;
            const ctx = canvas.getContext('2d');
            ctx.font = `${size}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(emoji, size, size);
            emojiCache.set(key, canvas);
            return canvas;
        }

        class GameObject {
            constructor(x, y, type) {
                this.reset(x, y, type);
            }
            reset(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.vx = (Math.random() - 0.5) * 4;
                this.vy = type === 'balloon' ? -(2 + Math.random() * 2) : (Math.random() - 0.5) * 2;
                this.size = 50 + Math.random() * 30;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotSpeed = (Math.random() - 0.5) * 0.1;
                this.popped = false;
                this.opacity = 1;
                this.active = true;
                this.emoji = this.getEmoji();
                this.emojiImage = null; // å»¶è¿ŸåŠ è½½
            }
            getEmoji() {
                const emojis = {
                    sunflower: 'ğŸŒ»',
                    balloon: ['ğŸˆ','ğŸ”´','ğŸŸ¡','ğŸŸ¢','ğŸ”µ','ğŸŸ£'][Math.floor(Math.random()*6)],
                    fruit: ['ğŸ','ğŸŠ','ğŸ‹','ğŸ‰','ğŸ‡','ğŸ“','ğŸ¥'][Math.floor(Math.random()*7)]
                };
                return emojis[this.type] || 'ğŸŒ»';
            }
            update(w, h) {
                if (this.popped) { 
                    this.opacity -= 0.1; 
                    return; 
                }
                if (this.type === 'balloon') {
                    this.y += this.vy; 
                    this.x += Math.sin(Date.now() / 500 + this.x) * 0.5;
                    if (this.y < -this.size) { 
                        this.y = h + this.size; 
                        this.x = Math.random() * w; 
                    }
                } else if (this.type === 'fruit') {
                    this.vy += 0.3; // ç¨å¾®åŠ å¿«ä¸‹è½é€Ÿåº¦
                    this.y += this.vy; 
                    this.x += this.vx; 
                    this.rotation += this.rotSpeed;
                    if (this.y > h + this.size) { 
                        this.y = -this.size; 
                        this.x = Math.random() * w; 
                        this.vy = Math.random() * 2; 
                        this.emoji = this.getEmoji(); 
                    }
                } else {
                    this.vy += 0.2; 
                    this.x += this.vx; 
                    this.y += this.vy; 
                    this.rotation += this.rotSpeed;
                    if (this.x < this.size || this.x > w - this.size) this.vx *= -0.8;
                    if (this.y > h - this.size) { 
                        this.vy *= -0.6; 
                        this.y = h - this.size; 
                    }
                }
            }
            draw(ctx) {
                if (this.opacity <= 0 || !this.active) return;
                
                // ä½¿ç”¨ä½å›¾ç¼“å­˜æå‡æ€§èƒ½
                if (!this.emojiImage) {
                    this.emojiImage = getEmojiImage(this.emoji, this.size);
                }
                
                // æ€§èƒ½ä¼˜åŒ–ï¼šå‡å°‘save/restoreï¼Œä½¿ç”¨transform
                ctx.save();
                ctx.globalAlpha = this.opacity;
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                // ä½¿ç”¨drawImageä»£æ›¿fillTextï¼ˆæ€§èƒ½æå‡10å€+ï¼‰
                const imgSize = this.size * 2;
                ctx.drawImage(this.emojiImage, -imgSize/2, -imgSize/2, imgSize, imgSize);
                ctx.restore();
            }
            hit(x, y, r) { return Math.hypot(this.x - x, this.y - y) < this.size / 2 + r; }
        }

        function initCanvasGame(type) {
            const canvas = document.getElementById('gameCanvas');
            if (!canvas) return;
            G.canvasW = canvas.width;
            G.canvasH = canvas.height;
            G.gameObjects = [];
            G.score = 0;
            const scoreEl = document.getElementById('scoreValue');
            if (scoreEl) scoreEl.textContent = '0';
            
            const count = type === 'balloon' ? 12 : type === 'fruit' ? 15 : 10;
            for (let i = 0; i < count; i++) {
                const x = Math.random() * G.canvasW;
                const y = type === 'balloon' 
                    ? G.canvasH + Math.random() * G.canvasH 
                    : type === 'fruit' 
                        ? -Math.random() * 300 
                        : Math.random() * G.canvasH * 0.5;
                G.gameObjects.push(objectPool.get(x, y, type));
            }
        }

        let lastCanvasFrame = 0;
        let animationId = null;
        
        function animateCanvas(currentTime) {
            // å…ˆæ£€æŸ¥æ¡ä»¶
            if (G.mode === 'particles') {
                animationId = requestAnimationFrame(animateCanvas);
                return;
            }
            
            // åˆå§‹åŒ– lastCanvasFrame
            if (lastCanvasFrame === 0) {
                lastCanvasFrame = currentTime;
            }
            
            // æ€§èƒ½ä¼˜åŒ–ï¼šä½¿ç”¨å›ºå®šæ—¶é—´æ­¥é•¿ï¼ˆæ›´æµç•…ï¼‰
            const elapsed = currentTime - lastCanvasFrame;
            const deltaTime = Math.min(elapsed, 100); // é™åˆ¶æœ€å¤§deltaTimeé¿å…è·³å¸§
            lastCanvasFrame = currentTime;
            
            // ä½¿ç”¨å›ºå®šæ—¶é—´æ­¥é•¿æ›´æ–°ï¼ˆ60fpsï¼‰
            const fixedDelta = 16.67; // 60fpsçš„å¸§é—´éš”
            if (elapsed < fixedDelta) {
                animationId = requestAnimationFrame(animateCanvas);
                return;
            }
            
            const canvas = document.getElementById('gameCanvas');
            if (!canvas) {
                requestAnimationFrame(animateCanvas);
                return;
            }
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // æ€§èƒ½ä¼˜åŒ–ï¼šå‡å°‘DOMæ“ä½œï¼Œæ‰¹é‡æ›´æ–°
            // æ”¯æŒåŒæ‰‹æ˜¾ç¤ºå’Œå¹³æ»‘æ’å€¼ï¼ˆå‡å°‘é—ªåŠ¨ï¼‰
            const handTracker = document.getElementById('handTracker');
            const smoothingFactor = 0.15; // å¹³æ»‘æ’å€¼ç³»æ•°ï¼ˆè¶Šå°è¶Šå¹³æ»‘ï¼Œä½†å»¶è¿Ÿè¶Šå¤§ï¼‰
            const velocityDamping = 0.85; // é€Ÿåº¦è¡°å‡ç³»æ•°
            
            // æ›´æ–°å¹³æ»‘ä½ç½®ï¼ˆä½¿ç”¨é€Ÿåº¦é¢„æµ‹å‡å°‘é—ªåŠ¨ï¼‰
            for (let handIdx = 0; handIdx < 2; handIdx++) {
                const smooth = G.smoothHandPositions[handIdx];
                const hand = G.hands[handIdx];
                
                if (hand.detected) {
                    // è®¡ç®—ç›®æ ‡ä½ç½®ï¼ˆå½’ä¸€åŒ–åæ ‡ï¼‰
                    const targetX = hand.x;
                    const targetY = hand.y;
                    
                    // è®¡ç®—é€Ÿåº¦ï¼ˆç”¨äºé¢„æµ‹ï¼‰
                    const dx = targetX - smooth.x;
                    const dy = targetY - smooth.y;
                    smooth.vx = smooth.vx * velocityDamping + dx * (1 - velocityDamping);
                    smooth.vy = smooth.vy * velocityDamping + dy * (1 - velocityDamping);
                    
                    // å¹³æ»‘æ’å€¼ï¼ˆä½¿ç”¨é€Ÿåº¦é¢„æµ‹ï¼‰
                    smooth.x += (targetX - smooth.x) * smoothingFactor + smooth.vx * 0.3;
                    smooth.y += (targetY - smooth.y) * smoothingFactor + smooth.vy * 0.3;
                } else {
                    // æœªæ£€æµ‹åˆ°æ—¶ï¼Œå¹³æ»‘è¡°å‡é€Ÿåº¦
                    smooth.vx *= velocityDamping;
                    smooth.vy *= velocityDamping;
                }
            }
            
            // ç»˜åˆ¶åŒæ‰‹æŒ‡ç¤ºå™¨ï¼ˆæ”¯æŒä¸¤ä¸ªç‚¹ï¼‰
            let hasAnyHand = false;
            for (let handIdx = 0; handIdx < 2; handIdx++) {
                const hand = G.hands[handIdx];
                const smooth = G.smoothHandPositions[handIdx];
                
                if (hand.detected) {
                    hasAnyHand = true;
                    const hx = (1 - smooth.x) * canvas.width;
                    const hy = smooth.y * canvas.height;
                    const isClosed = hand.openness < 0.5;
                    
                    // ç»˜åˆ¶æ‰‹éƒ¨æŒ‡ç¤ºå™¨ï¼ˆä¸åŒé¢œè‰²åŒºåˆ†å·¦å³æ‰‹ï¼‰
                    const color = handIdx === 0 ? 'rgba(251,191,36,0.4)' : 'rgba(99,102,241,0.4)';
                    const colorOuter = handIdx === 0 ? 'rgba(251,191,36,0)' : 'rgba(99,102,241,0)';
                    const grad = ctx.createRadialGradient(hx, hy, 0, hx, hy, 80);
                    grad.addColorStop(0, color);
                    grad.addColorStop(1, colorOuter);
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(hx, hy, 80, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // ç»˜åˆ¶ä¸­å¿ƒç‚¹ï¼ˆæ›´æ˜æ˜¾ï¼‰
                    ctx.fillStyle = isClosed ? 'rgba(239,68,68,0.8)' : 'rgba(34,197,94,0.8)';
                    ctx.beginPath();
                    ctx.arc(hx, hy, 8, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // æ›´æ–°DOMæ‰‹éƒ¨è·Ÿè¸ªå™¨ï¼ˆä½¿ç”¨ç¬¬ä¸€åªæ‰‹çš„ä½ç½®ï¼Œå…¼å®¹æ—§ä»£ç ï¼‰
            if (hasAnyHand) {
                const firstHand = G.hands[0].detected ? G.smoothHandPositions[0] : G.smoothHandPositions[1];
                const hx = (1 - firstHand.x) * canvas.width;
                const hy = firstHand.y * canvas.height;
                
                if (!handTracker.classList.contains('active')) {
                    handTracker.classList.add('active');
                }
                // ä½¿ç”¨transformä»£æ›¿left/topï¼Œæ€§èƒ½æ›´å¥½ä¸”æ›´å¹³æ»‘
                handTracker.style.transform = `translate(${hx - 40}px, ${hy - 40}px)`;
                
                const isClosed = (G.hands[0].detected ? G.hands[0].openness : G.hands[1].openness) < 0.5;
                if (isClosed && !handTracker.classList.contains('closed')) {
                    handTracker.classList.add('closed');
                } else if (!isClosed && handTracker.classList.contains('closed')) {
                    handTracker.classList.remove('closed');
                }
            } else {
                if (handTracker.classList.contains('active')) {
                    handTracker.classList.remove('active');
                }
            }
            
            // å…¼å®¹æ—§ä»£ç ï¼šæ›´æ–°G.isHandDetectedå’ŒG.handX/Y
            G.isHandDetected = hasAnyHand;
            if (hasAnyHand) {
                const firstHand = G.hands[0].detected ? G.smoothHandPositions[0] : G.smoothHandPositions[1];
                G.handX = firstHand.x;
                G.handY = firstHand.y;
            }

            // æ€§èƒ½ä¼˜åŒ–ï¼šä½¿ç”¨æ›´é«˜æ•ˆçš„è¿‡æ»¤å’Œæ›´æ–°æ–¹å¼ï¼ˆåŸåœ°è¿‡æ»¤ï¼‰
            let writeIdx = 0;
            for (let i = 0; i < G.gameObjects.length; i++) {
                const obj = G.gameObjects[i];
                if (obj.opacity > 0 && obj.active) {
                    if (writeIdx !== i) {
                        G.gameObjects[writeIdx] = obj;
                    }
                    writeIdx++;
                } else {
                    objectPool.release(obj);
                }
            }
            G.gameObjects.length = writeIdx;
            
            // ä¿æŒå¯¹è±¡æ•°é‡ï¼ˆä½¿ç”¨å¯¹è±¡æ± ï¼‰
            const targetCount = G.mode === 'balloon' ? 12 : G.mode === 'fruit' ? 15 : 10;
            if (G.gameObjects.length < targetCount) {
                const needed = targetCount - G.gameObjects.length;
                for (let i = 0; i < needed; i++) {
                    const x = Math.random() * canvas.width;
                    const y = G.mode === 'balloon' ? canvas.height + 50 : -50;
                    G.gameObjects.push(objectPool.get(x, y, G.mode));
                }
            }
            
            // æ‰¹é‡æ›´æ–°å’Œç»˜åˆ¶ï¼Œå‡å°‘DOMæ“ä½œ
            const scoreEl = document.getElementById('scoreValue');
            let scoreUpdated = false;
            
            // æ€§èƒ½ä¼˜åŒ–ï¼šåˆ†ç¦»æ›´æ–°å’Œæ¸²æŸ“é€»è¾‘
            // æ”¯æŒåŒæ‰‹ç¢°æ’æ£€æµ‹
            const hitRadius = 50;
            const hitRadiusSq = hitRadius * hitRadius;
            
            for (let i = 0; i < G.gameObjects.length; i++) {
                const obj = G.gameObjects[i];
                obj.update(canvas.width, canvas.height);
                
                // ä½¿ç”¨å¹³æ–¹è·ç¦»é¿å…sqrtè®¡ç®—ï¼ˆæ€§èƒ½ä¼˜åŒ–ï¼‰
                // æ”¯æŒåŒæ‰‹ç¢°æ’æ£€æµ‹
                if (!obj.popped) {
                    for (let handIdx = 0; handIdx < 2; handIdx++) {
                        const hand = G.hands[handIdx];
                        if (hand.detected) {
                            const smooth = G.smoothHandPositions[handIdx];
                            const hx = (1 - smooth.x) * canvas.width;
                            const hy = smooth.y * canvas.height;
                            const dx = obj.x - hx;
                            const dy = obj.y - hy;
                            const distSq = dx * dx + dy * dy;
                            if (distSq < hitRadiusSq) {
                                obj.popped = true;
                                G.score += 10;
                                scoreUpdated = true;
                                break; // åªè®¡ç®—ä¸€æ¬¡ç¢°æ’
                            }
                        }
                    }
                }
            }
            
            // æ‰¹é‡ç»˜åˆ¶ï¼ˆå‡å°‘çŠ¶æ€åˆ‡æ¢ï¼‰
            for (let i = 0; i < G.gameObjects.length; i++) {
                G.gameObjects[i].draw(ctx);
            }
            
            // åªåœ¨åˆ†æ•°å˜åŒ–æ—¶æ›´æ–°DOMï¼ˆæ€§èƒ½ä¼˜åŒ–ï¼‰
            if (scoreUpdated && scoreEl) {
                scoreEl.textContent = G.score;
                showMessage('âœ¨ +10', 400);
            }
            
            // ç»§ç»­åŠ¨ç”»å¾ªç¯
            animationId = requestAnimationFrame(animateCanvas);
        }
        
        // åˆå§‹åŒ–æ—¶è°ƒç”¨animateCanvasï¼ˆå»¶è¿Ÿå¯åŠ¨ï¼Œç¡®ä¿DOMå·²åŠ è½½ï¼‰
        if (isLocalhost) {
            requestAnimationFrame(() => animateCanvas(performance.now()));
        }

        // ============ MediaPipe Handsï¼ˆå‚è€ƒç¤ºä¾‹ç®€åŒ–ç‰ˆæœ¬ï¼‰============
        function initMediaPipe() {
            if (!isLocalhost) return;
            
            const video = document.getElementById('webcam');
            const loader = document.getElementById('loader');
            const statusDot = document.getElementById('handStatus');
            const statusText = document.getElementById('statusText');

            if (!video || !loader || !statusDot || !statusText) {
                console.error('MediaPipe initialization failed: required elements not found');
                return;
            }

            // æ”¯æŒåŒæ‰‹æ£€æµ‹ï¼ˆä½¿ç”¨å¼€æºMediaPipeé…ç½®ï¼‰
            const hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });
            
            // ä¼˜åŒ–é…ç½®ï¼šæ”¯æŒåŒæ‰‹ï¼Œæé«˜å‡†ç¡®åº¦
            hands.setOptions({
                maxNumHands: 2, // æ”¯æŒåŒæ‰‹
                modelComplexity: 1, // ä½¿ç”¨ä¸­ç­‰å¤æ‚åº¦æ¨¡å‹ï¼ˆå¹³è¡¡æ€§èƒ½å’Œå‡†ç¡®åº¦ï¼‰
                minDetectionConfidence: 0.7, // æé«˜æ£€æµ‹ç½®ä¿¡åº¦é˜ˆå€¼ï¼ˆå‡å°‘è¯¯æ£€ï¼‰
                minTrackingConfidence: 0.7 // æé«˜è·Ÿè¸ªç½®ä¿¡åº¦é˜ˆå€¼ï¼ˆæ›´ç¨³å®šï¼‰
            });

            // ä¼˜åŒ–çš„åŒæ‰‹æ£€æµ‹å¤„ç†ï¼ˆä½¿ç”¨å¼€æºMediaPipe APIï¼‰
            function onResults(results) {
                loader.style.opacity = '0';
                setTimeout(() => loader.style.display = 'none', 500);

                // é‡ç½®åŒæ‰‹çŠ¶æ€
                G.hands[0].detected = false;
                G.hands[1].detected = false;
                G.isHandDetected = false;

                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    G.isHandDetected = true;
                    statusDot.classList.add('active');
                    
                    // å¤„ç†æ£€æµ‹åˆ°çš„æ‰€æœ‰æ‰‹ï¼ˆæœ€å¤š2åªï¼‰
                    const handCount = Math.min(results.multiHandLandmarks.length, 2);
                    
                    for (let handIdx = 0; handIdx < handCount; handIdx++) {
                        const landmarks = results.multiHandLandmarks[handIdx];
                        const hand = G.hands[handIdx];
                        
                        hand.detected = true;
                        
                        // ä¼˜åŒ–çš„æ‰‹æŒä½ç½®è®¡ç®—ï¼ˆä½¿ç”¨ä¸­æŒ‡æ ¹éƒ¨ï¼Œæ›´ç¨³å®šï¼‰
                        hand.x = landmarks[9].x;
                        hand.y = landmarks[9].y;

                        // ä¼˜åŒ–çš„æ‰‹æŒå¼ å¼€ç¨‹åº¦è®¡ç®—ï¼ˆä¿®å¤ï¼šç¡®ä¿å¼ å¼€æ‰‹è¯†åˆ«ä¸ºå¼ å¼€ï¼‰
                        const wrist = landmarks[0];
                        const tips = [4, 8, 12, 16, 20]; // äº”ä¸ªæŒ‡å°–
                        
                        // æ–¹æ³•1ï¼šè®¡ç®—æ‰€æœ‰æŒ‡å°–åˆ°æ‰‹è…•çš„å¹³å‡è·ç¦»
                        let totalDist = 0;
                        tips.forEach(idx => {
                            const tip = landmarks[idx];
                            const d = Math.sqrt(Math.pow(tip.x - wrist.x, 2) + Math.pow(tip.y - wrist.y, 2));
                            totalDist += d;
                        });
                        const avgDist = totalDist / 5;
                        
                        // æ–¹æ³•2ï¼šè®¡ç®—æ‹‡æŒ‡å’Œé£ŸæŒ‡çš„è·ç¦»ï¼ˆæ›´æ•æ„Ÿï¼‰
                        const thumbTip = landmarks[4];
                        const indexTip = landmarks[8];
                        const thumbIndexDist = Math.sqrt(
                            Math.pow(thumbTip.x - indexTip.x, 2) + 
                            Math.pow(thumbTip.y - indexTip.y, 2)
                        );
                        
                        // æ–¹æ³•3ï¼šè®¡ç®—ä¸­æŒ‡å’Œæ— åæŒ‡çš„è·ç¦»
                        const middleTip = landmarks[12];
                        const ringTip = landmarks[16];
                        const middleRingDist = Math.sqrt(
                            Math.pow(middleTip.x - ringTip.x, 2) + 
                            Math.pow(middleTip.y - ringTip.y, 2)
                        );
                        
                        // æ–¹æ³•4ï¼šè®¡ç®—æ‰€æœ‰ç›¸é‚»æŒ‡å°–ä¹‹é—´çš„å¹³å‡è·ç¦»ï¼ˆæ›´å‡†ç¡®åˆ¤æ–­å¼ å¼€ï¼‰
                        let fingerSpread = 0;
                        const fingerPairs = [[8, 12], [12, 16], [16, 20]]; // é£ŸæŒ‡-ä¸­æŒ‡, ä¸­æŒ‡-æ— åæŒ‡, æ— åæŒ‡-å°æŒ‡
                        fingerPairs.forEach(([idx1, idx2]) => {
                            const p1 = landmarks[idx1];
                            const p2 = landmarks[idx2];
                            fingerSpread += Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
                        });
                        fingerSpread = fingerSpread / fingerPairs.length;
                        
                        // ç»¼åˆå››ç§æ–¹æ³•ï¼Œæé«˜å‡†ç¡®åº¦
                        // å½’ä¸€åŒ–å¤„ç†ï¼ˆè°ƒæ•´é˜ˆå€¼ï¼Œç¡®ä¿å¼ å¼€æ‰‹è¯†åˆ«ä¸ºå¼ å¼€ï¼‰
                        const minOpen = 0.10;
                        const maxOpen = 0.50;
                        const openness1 = Math.max(0, Math.min(1, (avgDist - minOpen) / (maxOpen - minOpen)));
                        const openness2 = Math.max(0, Math.min(1, (thumbIndexDist - 0.04) / 0.25));
                        const openness3 = Math.max(0, Math.min(1, (middleRingDist - 0.02) / 0.18));
                        const openness4 = Math.max(0, Math.min(1, (fingerSpread - 0.03) / 0.20));
                        
                        // åŠ æƒå¹³å‡ï¼ˆå¢åŠ æ‰‹æŒ‡é—´è·æƒé‡ï¼Œæ›´å‡†ç¡®åˆ¤æ–­å¼ å¼€ï¼‰
                        hand.openness = (openness1 * 0.3 + openness2 * 0.3 + openness3 * 0.2 + openness4 * 0.2);
                        
                        // ç¡®ä¿å€¼åœ¨åˆç†èŒƒå›´å†…ï¼Œå¹¶æ·»åŠ å¹³æ»‘å¤„ç†
                        hand.openness = Math.max(0, Math.min(1, hand.openness));
                        
                        // å…¼å®¹æ—§ä»£ç ï¼ˆä½¿ç”¨ç¬¬ä¸€åªæ‰‹ï¼‰
                        if (handIdx === 0) {
                            G.handX = hand.x;
                            G.handY = hand.y;
                            G.handOpenness = hand.openness;
                        }
                    }
                    
                    // æ›´æ–°UIæ˜¾ç¤ºï¼ˆå¢å¼ºç”¨æˆ·ä½“éªŒï¼‰
                    const handStatusDetail = document.getElementById('handStatusDetail');
                    const hand1Dot = document.getElementById('hand1Dot');
                    const hand2Dot = document.getElementById('hand2Dot');
                    
                    if (handCount === 2) {
                        const hand1Status = G.hands[0].openness > 0.6 ? "å¼ å¼€" : "æ¡æ‹³";
                        const hand2Status = G.hands[1].openness > 0.6 ? "å¼ å¼€" : "æ¡æ‹³";
                        statusText.textContent = `åŒæ‰‹æ£€æµ‹: å·¦æ‰‹${hand1Status} | å³æ‰‹${hand2Status}`;
                        statusDot.classList.add('dual');
                        
                        // æ˜¾ç¤ºåŒæ‰‹çŠ¶æ€æŒ‡ç¤ºå™¨
                        if (handStatusDetail) handStatusDetail.style.display = 'flex';
                        if (hand1Dot) {
                            hand1Dot.className = 'hand-dot ' + (G.hands[0].openness > 0.6 ? 'open' : 'closed');
                        }
                        if (hand2Dot) {
                            hand2Dot.className = 'hand-dot ' + (G.hands[1].openness > 0.6 ? 'open' : 'closed');
                        }
                    } else if (handCount === 1) {
                        const handStatus = G.hands[0].openness > 0.6 ? "å¼ å¼€ (æ‰©æ•£)" : "æ¡æ‹³ (èšæ‹¢)";
                        statusText.textContent = `å•æ‰‹æ£€æµ‹: ${handStatus}`;
                        statusDot.classList.remove('dual');
                        
                        // æ˜¾ç¤ºå•æ‰‹çŠ¶æ€
                        if (handStatusDetail) handStatusDetail.style.display = 'flex';
                        if (hand1Dot) {
                            hand1Dot.className = 'hand-dot ' + (G.hands[0].openness > 0.6 ? 'open' : 'closed');
                        }
                        if (hand2Dot) {
                            hand2Dot.className = 'hand-dot';
                        }
                    } else {
                        if (handStatusDetail) handStatusDetail.style.display = 'none';
                    }
                } else {
                    statusDot.classList.remove('active');
                    statusDot.classList.remove('dual');
                    statusText.textContent = "æœªæ£€æµ‹åˆ°æ‰‹åŠ¿";
                    
                    // éšè—åŒæ‰‹çŠ¶æ€æŒ‡ç¤ºå™¨
                    const handStatusDetail = document.getElementById('handStatusDetail');
                    if (handStatusDetail) handStatusDetail.style.display = 'none';
                    
                    // å¹³æ»‘è¿‡æ¸¡åˆ°é»˜è®¤çŠ¶æ€
                    G.handOpenness += (1 - G.handOpenness) * 0.05;
                    G.hands[0].openness += (1 - G.hands[0].openness) * 0.05;
                    G.hands[1].openness += (1 - G.hands[1].openness) * 0.05;
                }
            }

            hands.onResults(onResults);

            // å‚è€ƒç¤ºä¾‹çš„æ‘„åƒå¤´åˆå§‹åŒ–
            const cameraUtils = new Camera(video, {
                onFrame: async () => {
                    await hands.send({ image: video });
                },
                width: 320,
                height: 240
            });

            cameraUtils.start().catch(error => {
                console.error('Camera start failed:', error);
                if (loader) {
                    loader.innerHTML = '<div class="spinner"></div><p style="color:#ef4444;">æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥æƒé™è®¾ç½®</p>';
                }
            });
        }

        // ============ UI ============
        function selectGame(mode) {
            G.mode = mode;
            
            // æ€§èƒ½ä¼˜åŒ–ï¼šæ‰¹é‡DOMæ“ä½œ
            const options = document.querySelectorAll('.game-option');
            for (let i = 0; i < options.length; i++) {
                options[i].classList.remove('active');
            }
            const activeOption = document.querySelector(`[data-game="${mode}"]`);
            if (activeOption) activeOption.classList.add('active');
            
            const three = document.getElementById('threeContainer');
            const canvas = document.getElementById('gameCanvas');
            const controls = document.getElementById('particleControls');
            const scorePanel = document.getElementById('scorePanel');
            const handTracker = document.getElementById('handTracker');
            
            if (mode === 'particles') {
                three.style.display = 'block';
                canvas.style.display = 'none';
                controls.style.display = 'block';
                scorePanel.style.display = 'none';
                if (handTracker) handTracker.classList.remove('active');
                
                // ç¡®ä¿ç²’å­ç³»ç»Ÿå·²åˆå§‹åŒ–
                if (!G.particles) {
                    initThreeJS();
                    requestAnimationFrame(() => animateParticles(performance.now()));
                }
            } else {
                three.style.display = 'none';
                canvas.style.display = 'block';
                controls.style.display = 'none';
                scorePanel.style.display = 'block';
                
                const container = canvas.parentElement;
                if (container) {
                    canvas.width = container.clientWidth;
                    canvas.height = container.clientHeight;
                }
                initCanvasGame(mode);
                
                // å¯åŠ¨canvasåŠ¨ç”»
                if (lastCanvasFrame === 0) {
                    requestAnimationFrame(() => animateCanvas(performance.now()));
                }
            }
        }

        function showMessage(text, dur = 2000) {
            const msg = document.getElementById('gameMessage');
            msg.textContent = text; msg.classList.add('show');
            setTimeout(() => msg.classList.remove('show'), dur);
        }

        // ============ åˆå§‹åŒ–ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼Œå‚è€ƒç¤ºä¾‹ï¼‰============
        function initializeGame() {
            // æ ¹æ®è®¿é—®æ¥æºæ˜¾ç¤º/éšè—æ¸¸æˆéƒ¨åˆ†
            if (!isLocalhost) {
                const gameSection = document.getElementById('game');
                const gameNavItem = document.getElementById('gameNavItem');
                if (gameSection) gameSection.style.display = 'none';
                if (gameNavItem) gameNavItem.style.display = 'none';
                return;
            }
            
            // æ˜¾ç¤ºæ¸¸æˆéƒ¨åˆ†å’Œå¯¼èˆªé¡¹ï¼ˆæœ¬åœ°è®¿é—®ï¼‰
            const gameSection = document.getElementById('game');
            const gameNavItem = document.getElementById('gameNavItem');
            if (gameSection) gameSection.style.display = '';
            if (gameNavItem) gameNavItem.style.display = '';
            
            // ç­‰å¾…DOMå’Œè„šæœ¬åŠ è½½å®Œæˆ
            const initGame = () => {
                if (typeof THREE === 'undefined' || typeof Hands === 'undefined') {
                    setTimeout(initGame, 50);
                    return;
                }
                
                try {
                    initThreeJS();
                    requestAnimationFrame(() => animateParticles(performance.now()));
                    initMediaPipe();
                } catch (error) {
                    console.error('Game initialization error:', error);
                }
            };
            
            // DOMåŠ è½½å®Œæˆååˆå§‹åŒ–
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initGame);
            } else {
                initGame();
            }
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            initializeGame();

            // åªåœ¨æœ¬åœ°è®¿é—®æ—¶ç»‘å®šæ¸¸æˆç›¸å…³äº‹ä»¶
            if (isLocalhost) {
                document.querySelectorAll('.game-option').forEach(opt => {
                    opt.addEventListener('click', () => selectGame(opt.dataset.game));
                });

                document.querySelectorAll('.shape-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        updateTargetPositions(btn.dataset.shape);
                        document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                    });
                });

                const colorPicker = document.getElementById('colorPicker');
                if (colorPicker) {
                    colorPicker.addEventListener('input', (e) => {
                        if (G.particles) G.particles.material.color.set(e.target.value);
                    });
                }

                const resetBtn = document.getElementById('resetBtn');
                if (resetBtn) {
                    resetBtn.addEventListener('click', () => {
                        G.score = 0;
                        const scoreValue = document.getElementById('scoreValue');
                        if (scoreValue) scoreValue.textContent = '0';
                        if (G.mode === 'particles') {
                            updateTargetPositions(G.currentShape);
                        } else {
                            initCanvasGame(G.mode);
                        }
                        showMessage('ğŸ”„ å·²é‡ç½®', 1500);
                    });
                }
            }

            window.addEventListener('scroll', () => {
                document.getElementById('scrollTop').classList.toggle('show', window.pageYOffset > 300);
            });
            document.getElementById('scrollTop').addEventListener('click', () => window.scrollTo({ top: 0, behavior: 'smooth' }));

            document.querySelectorAll('a[href^="#"]').forEach(a => {
                a.addEventListener('click', (e) => {
                    e.preventDefault();
                    const target = document.querySelector(a.getAttribute('href'));
                    if (target && target.style.display !== 'none') {
                        target.scrollIntoView({ behavior: 'smooth' });
                    }
                });
            });

            // æ€§èƒ½ä¼˜åŒ–ï¼šèŠ‚æµresizeäº‹ä»¶
            let resizeTimer;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(() => {
                    const container = document.getElementById('threeContainer');
                    if (G.renderer && container) {
                        G.renderer.setSize(container.clientWidth, container.clientHeight);
                        G.camera.aspect = container.clientWidth / container.clientHeight;
                        G.camera.updateProjectionMatrix();
                    }
                    if (G.mode !== 'particles') {
                        const canvas = document.getElementById('gameCanvas');
                        if (canvas && canvas.parentElement) {
                            canvas.width = canvas.parentElement.clientWidth;
                            canvas.height = canvas.parentElement.clientHeight;
                        }
                    }
                }, 250);
            });
        });
    </script>
</body>
</html>