================================================================================
é¡¹ç›®åç§°: XRK-AGT(Github)
ç”Ÿæˆæ—¶é—´: 2025-11-15 08:46:58
æ–‡ä»¶æ•°é‡: 8
================================================================================

# ğŸ“‹ é¡¹ç›®ç»“æ„

```
ğŸ“ XRK-AGT(Github)/
â”œâ”€â”€ ğŸ“ components/
â”‚   â”œâ”€â”€ ğŸ“ asr/
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ ASRFactory.js
â”‚   â”‚   â””â”€â”€ ğŸ“„ VolcengineASRClient.js
â”‚   â”œâ”€â”€ ğŸ“ config/
â”‚   â”‚   â””â”€â”€ ğŸ“„ deviceConfig.js
â”‚   â”œâ”€â”€ ğŸ“ tts/
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ TTSFactory.js
â”‚   â”‚   â””â”€â”€ ğŸ“„ VolcengineTTSClient.js
â”‚   â””â”€â”€ ğŸ“ util/
â”‚       â””â”€â”€ ğŸ“„ deviceUtil.js
â”œâ”€â”€ ğŸ“ lib/
â”‚   â””â”€â”€ ğŸ“„ bot.js
â””â”€â”€ ğŸ“ plugins/
    â””â”€â”€ ğŸ“ api/
        â””â”€â”€ ğŸ“„ device.js
```

================================================================================

# ğŸ“ æ–‡ä»¶å†…å®¹

--------------------------------------------------------------------------------
## æ–‡ä»¶: ./components/asr/ASRFactory.js
--------------------------------------------------------------------------------

```javascript
/**
 * ASRå·¥å‚ç±»
 * ç»Ÿä¸€ç®¡ç†ä¸åŒå¹³å°çš„ASRå®¢æˆ·ç«¯åˆ›å»º
 * æ”¯æŒæ‰©å±•å¤šä¸ªASRæœåŠ¡æä¾›å•†
 */

import VolcengineASRClient from './VolcengineASRClient.js';

/**
 * ASRå·¥å‚ç±»
 */
export default class ASRFactory {
    /**
     * åˆ›å»ºASRå®¢æˆ·ç«¯
     * @param {string} deviceId - è®¾å¤‡ID
     * @param {Object} config - ASRé…ç½®
     * @param {Object} Bot - Botå®ä¾‹
     * @returns {Object} ASRå®¢æˆ·ç«¯å®ä¾‹
     */
    static createClient(deviceId, config, Bot) {
        if (!config.enabled) {
            throw new Error('ASRæœªå¯ç”¨');
        }

        const provider = config.provider || 'volcengine';

        switch (provider.toLowerCase()) {
            case 'volcengine':
                return new VolcengineASRClient(deviceId, config, Bot);
            
            // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ å…¶ä»–ASRæä¾›å•†
            // case 'aliyun':
            //     return new AliyunASRClient(deviceId, config, Bot);
            // case 'tencent':
            //     return new TencentASRClient(deviceId, config, Bot);
            
            default:
                throw new Error(`ä¸æ”¯æŒçš„ASRæä¾›å•†: ${provider}`);
        }
    }

    /**
     * è·å–æ”¯æŒçš„ASRæä¾›å•†åˆ—è¡¨
     * @returns {Array<string>} æä¾›å•†åˆ—è¡¨
     */
    static getSupportedProviders() {
        return ['volcengine'];
    }

    /**
     * æ£€æŸ¥æä¾›å•†æ˜¯å¦æ”¯æŒ
     * @param {string} provider - æä¾›å•†åç§°
     * @returns {boolean} æ˜¯å¦æ”¯æŒ
     */
    static isProviderSupported(provider) {
        return this.getSupportedProviders().includes(provider.toLowerCase());
    }
}
```


--------------------------------------------------------------------------------
## æ–‡ä»¶: ./components/asr/VolcengineASRClient.js
--------------------------------------------------------------------------------

```javascript
/**
 * ç«å±±å¼•æ“ASRå®¢æˆ·ç«¯
 * å®ç°è¯­éŸ³è¯†åˆ«åŠŸèƒ½ï¼Œæ”¯æŒå®æ—¶æµå¼è¯†åˆ«
 */

import WebSocket from 'ws';
import zlib from 'zlib';
import { v4 as uuidv4 } from 'uuid';
import BotUtil from '../../lib/common/util.js';

export default class VolcengineASRClient {
    /**
     * æ„é€ å‡½æ•°
     * @param {string} deviceId - è®¾å¤‡ID
     * @param {Object} config - ASRé…ç½®
     * @param {Object} Bot - Botå®ä¾‹
     */
    constructor(deviceId, config, Bot) {
        this.deviceId = deviceId;
        this.config = config;
        this.Bot = Bot;
        
        // WebSocketç›¸å…³
        this.ws = null;
        this.connected = false;
        this.connecting = false;
        this.connectId = uuidv4();
        
        // ä¼šè¯ç›¸å…³
        this.sequence = 1;
        this.currentUtterance = null;
        
        // æ—¶é—´æˆ³
        this.lastMessageAt = 0;
        this.lastAudioAt = 0;
        
        // æ—¥å¿—ID
        this.logId = null;
        
        // å®šæ—¶å™¨
        this._idleTimer = null;
        this._pingTimer = null;
        this._pongTimer = null;
        
        // é‡è¿ç›¸å…³
        this.reconnectAttempts = 0;
        
        // æ€§èƒ½æŒ‡æ ‡
        this.performanceMetrics = {
            firstResultTime: null,
            totalProcessingTime: 0,
            audioStartTime: null
        };
    }

    /**
     * ç”ŸæˆWebSocketè¿æ¥å¤´éƒ¨
     * @returns {Object} è¯·æ±‚å¤´å¯¹è±¡
     * @private
     */
    _headers() {
        return {
            'X-Api-App-Key': this.config.appKey,
            'X-Api-Access-Key': this.config.accessKey,
            'X-Api-Resource-Id': this.config.resourceId,
            'X-Api-Connect-Id': this.connectId,
        };
    }

    /**
     * æ„å»ºåè®®å¤´éƒ¨ï¼ˆ4å­—èŠ‚ï¼‰
     * @param {number} messageType - æ¶ˆæ¯ç±»å‹
     * @param {number} messageFlags - æ¶ˆæ¯æ ‡å¿—
     * @param {number} serialization - åºåˆ—åŒ–æ–¹å¼
     * @param {number} compression - å‹ç¼©æ–¹å¼
     * @returns {Buffer} åè®®å¤´Buffer
     * @private
     */
    _protoHeader(messageType, messageFlags, serialization, compression) {
        const header = Buffer.alloc(4);
        header[0] = 0x11;
        header[1] = (messageType << 4) | messageFlags;
        header[2] = (serialization << 4) | compression;
        header[3] = 0x00;
        return header;
    }

    /**
     * æ„å»ºå®Œæ•´å®¢æˆ·ç«¯è¯·æ±‚ï¼ˆå¸¦éŸ³é¢‘é…ç½®ï¼‰
     * @param {Object} audioInfo - éŸ³é¢‘ä¿¡æ¯
     * @returns {Buffer} è¯·æ±‚Buffer
     * @private
     */
    _fullClientRequest(audioInfo) {
        const payload = {
            user: {
                uid: this.deviceId,
                platform: 'ESP32-S3'
            },
            audio: {
                format: 'pcm',
                codec: 'raw',
                rate: audioInfo?.rate || 16000,
                bits: audioInfo?.bits || 16,
                channel: audioInfo?.channel || 1,
            },
            request: {
                model_name: 'bigmodel',
                enable_itn: this.config.enableItn,
                enable_punc: this.config.enablePunc,
                enable_ddc: this.config.enableDdc,
                show_utterances: this.config.showUtterances,
                result_type: this.config.resultType,
                enable_accelerate_text: this.config.enableAccelerateText,
                accelerate_score: this.config.accelerateScore,
                end_window_size: this.config.endWindowSize,
                force_to_speech_time: this.config.forceToSpeechTime,
            }
        };

        const json = JSON.stringify(payload);
        const gz = zlib.gzipSync(Buffer.from(json, 'utf-8'));
        const header = this._protoHeader(0x1, 0x0, 0x1, 0x1);
        const size = Buffer.alloc(4);
        size.writeUInt32BE(gz.length, 0);

        return Buffer.concat([header, size, gz]);
    }

    /**
     * æ„å»ºçº¯éŸ³é¢‘è¯·æ±‚
     * @param {Buffer} audioBuf - éŸ³é¢‘æ•°æ®
     * @param {boolean} isLast - æ˜¯å¦æœ€åä¸€å¸§
     * @returns {Buffer} è¯·æ±‚Buffer
     * @private
     */
    _audioOnlyRequest(audioBuf, isLast = false) {
        const gz = zlib.gzipSync(audioBuf);
        const flags = isLast ? 0x2 : 0x1;
        const header = this._protoHeader(0x2, flags, 0x0, 0x1);
        const payloadSize = Buffer.alloc(4);
        payloadSize.writeUInt32BE(gz.length, 0);

        if (!isLast) {
            this.sequence++;
            if (this.sequence > 0xFFFFFFFF) {
                this.sequence = 1;
            }
            const seq = Buffer.alloc(4);
            seq.writeUInt32BE(this.sequence, 0);
            return Buffer.concat([header, seq, payloadSize, gz]);
        }

        return Buffer.concat([header, payloadSize, gz]);
    }

    /**
     * è§£ææœåŠ¡å™¨è¿”å›çš„æ•°æ®
     * @param {Buffer} data - åŸå§‹æ•°æ®
     * @returns {Object|null} è§£æç»“æœ
     * @private
     */
    _parse(data) {
        try {
            if (!data || data.length < 4) return null;

            const messageType = (data[1] >> 4) & 0x0F;
            const messageFlags = data[1] & 0x0F;
            const compression = data[2] & 0x0F;

            // é”™è¯¯å¸§
            if (messageType === 0xF) {
                const errCode = data.readUInt32BE(4);
                const errSize = data.readUInt32BE(8);
                const msg = data.slice(12, 12 + errSize).toString('utf-8');
                return { type: 'error', errorCode: errCode, errorMessage: msg };
            }

            // ç»“æœå¸§
            if (messageType === 0x9) {
                let offset = 4;
                if (messageFlags === 0x1 || messageFlags === 0x3) {
                    offset += 4;
                }
                const size = data.readUInt32BE(offset);
                offset += 4;
                let payload = data.slice(offset, offset + size);
                
                if (compression === 0x1) {
                    payload = zlib.gunzipSync(payload);
                }
                
                const result = JSON.parse(payload.toString('utf-8'));
                const isLast = messageFlags === 0x3 || messageFlags === 0x2;

                return { type: 'result', result, isLast };
            }

            return null;
        } catch (e) {
            return null;
        }
    }

    /**
     * å¯åŠ¨Pingå®šæ—¶å™¨
     * @private
     */
    _startPingTimer() {
        if (!this.config.wsPingIntervalMs) return;
        this._clearPingTimer();

        this._pingTimer = setInterval(() => {
            try {
                if (this.ws && this.connected) {
                    this.ws.ping();
                    this._startPongTimer();
                }
            } catch (e) {
                // å¿½ç•¥é”™è¯¯
            }
        }, this.config.wsPingIntervalMs || 30000);
    }

    /**
     * æ¸…é™¤Pingå®šæ—¶å™¨
     * @private
     */
    _clearPingTimer() {
        if (this._pingTimer) {
            clearInterval(this._pingTimer);
            this._pingTimer = null;
        }
    }

    /**
     * å¯åŠ¨Pongè¶…æ—¶å®šæ—¶å™¨
     * @private
     */
    _startPongTimer() {
        this._clearPongTimer();
        this._pongTimer = setTimeout(() => {
            BotUtil.makeLog('warn', `[ASR] Pongè¶…æ—¶ï¼Œæ–­å¼€è¿æ¥`, this.deviceId);
            if (this.ws) {
                try {
                    this.ws.terminate();
                } catch (e) {
                    // å¿½ç•¥é”™è¯¯
                }
            }
        }, this.config.wsPongTimeoutMs || 10000);
    }

    /**
     * æ¸…é™¤Pongè¶…æ—¶å®šæ—¶å™¨
     * @private
     */
    _clearPongTimer() {
        if (this._pongTimer) {
            clearTimeout(this._pongTimer);
            this._pongTimer = null;
        }
    }

    /**
     * ç¡®ä¿WebSocketå·²è¿æ¥
     * @returns {Promise<void>}
     * @private
     */
    async _ensureConnected() {
        if (this.connected) return;

        if (this.connecting) {
            for (let i = 0; i < 100; i++) {
                await new Promise(r => setTimeout(r, 30));
                if (this.connected) return;
            }
            throw new Error('è¿æ¥è¶…æ—¶');
        }

        this.connecting = true;

        try {
            await new Promise((resolve, reject) => {
                const connectTimeout = setTimeout(() => {
                    this.connecting = false;
                    reject(new Error('è¿æ¥è¶…æ—¶'));
                }, 8000);

                try {
                    const ws = new WebSocket(this.config.wsUrl, {
                        headers: this._headers(),
                        handshakeTimeout: 8000
                    });

                    this.ws = ws;

                    ws.on('open', () => {
                        clearTimeout(connectTimeout);
                        this.connected = true;
                        this.connecting = false;
                        this.lastMessageAt = Date.now();
                        this.reconnectAttempts = 0;

                        BotUtil.makeLog('info', `âš¡ [ASR] WebSocketå·²è¿æ¥`, this.deviceId);
                        this._startPingTimer();
                        resolve();
                    });

                    ws.on('upgrade', (response) => {
                        this.logId = response.headers['x-tt-logid'];
                    });

                    ws.on('message', (buf) => {
                        this.lastMessageAt = Date.now();
                        const msg = this._parse(buf);

                        if (!msg) return;

                        if (msg.type === 'error') {
                            this._handleError(msg);
                            return;
                        }

                        if (msg.type === 'result') {
                            if (!this.performanceMetrics.firstResultTime && this.performanceMetrics.audioStartTime) {
                                this.performanceMetrics.firstResultTime = Date.now() - this.performanceMetrics.audioStartTime;
                                BotUtil.makeLog('info',
                                    `âš¡ [ASRæ€§èƒ½] é¦–å­—è¿”å›: ${this.performanceMetrics.firstResultTime}ms`,
                                    this.deviceId
                                );
                            }

                            this._handleResult(msg.result, msg.isLast);

                            if (msg.isLast) {
                                if (this.currentUtterance) {
                                    const totalTime = Date.now() - this.performanceMetrics.audioStartTime;
                                    BotUtil.makeLog('info',
                                        `âš¡ [ASRæ€§èƒ½] æ€»å¤„ç†æ—¶é—´: ${totalTime}ms`,
                                        this.deviceId
                                    );
                                }
                                this._armIdleTimer();
                            }
                        }
                    });

                    ws.on('pong', () => {
                        this._clearPongTimer();
                    });

                    ws.on('error', (err) => {
                        clearTimeout(connectTimeout);

                        if (err.message.includes('401')) {
                            BotUtil.makeLog('error',
                                `âŒ [ASR] è®¤è¯å¤±è´¥(401): è¯·æ£€æŸ¥appKeyå’ŒaccessKey`,
                                this.deviceId
                            );
                        } else {
                            BotUtil.makeLog('error',
                                `âŒ [ASR] WebSocketé”™è¯¯: ${err.message}`,
                                this.deviceId
                            );
                        }

                        this.connected = false;
                        this.connecting = false;
                        this.currentUtterance = null;
                        this._clearIdleTimer();
                        this._clearPingTimer();
                        this._clearPongTimer();
                        reject(err);
                    });

                    ws.on('close', (code) => {
                        BotUtil.makeLog('info', `âœ“ [ASR] WebSocketå…³é—­ (code=${code})`, this.deviceId);
                        this.connected = false;
                        this.connecting = false;

                        if (this.currentUtterance) {
                            this.currentUtterance = null;
                        }

                        this._clearIdleTimer();
                        this._clearPingTimer();
                        this._clearPongTimer();

                        if (code !== 1000 && this.reconnectAttempts < (this.config.wsMaxReconnectAttempts || 5)) {
                            this._scheduleReconnect();
                        }
                    });

                } catch (e) {
                    clearTimeout(connectTimeout);
                    this.connecting = false;
                    reject(e);
                }
            });
        } catch (e) {
            this.connecting = false;
            throw e;
        }
    }

    /**
     * å®‰æ’é‡è¿
     * @private
     */
    _scheduleReconnect() {
        this.reconnectAttempts++;
        const delay = Math.min(
            (this.config.wsReconnectDelayMs || 2000) * this.reconnectAttempts,
            10000
        );

        BotUtil.makeLog('info',
            `ğŸ”„ [ASR] å°†åœ¨${delay}msåé‡è¿ï¼ˆç¬¬${this.reconnectAttempts}æ¬¡ï¼‰`,
            this.deviceId
        );

        setTimeout(() => {
            if (!this.connected && !this.connecting) {
                this._ensureConnected().catch(e => {
                    BotUtil.makeLog('error', `âŒ [ASR] é‡è¿å¤±è´¥: ${e.message}`, this.deviceId);
                });
            }
        }, delay);
    }

    /**
     * å¤„ç†é”™è¯¯
     * @param {Object} msg - é”™è¯¯æ¶ˆæ¯
     * @private
     */
    _handleError(msg) {
        const errorCode = msg.errorCode;

        if (errorCode === 45000081) {
            BotUtil.makeLog('warn', `âš ï¸ [ASR] æœåŠ¡å™¨è¶…æ—¶ï¼Œæ¸…ç†çŠ¶æ€`, this.deviceId);
        } else if (errorCode === 45000000) {
            this.sequence = 1;
        } else {
            BotUtil.makeLog('error',
                `âŒ [ASRé”™è¯¯] ${errorCode}: ${msg.errorMessage}`,
                this.deviceId
            );
        }

        if (this.currentUtterance) {
            this.currentUtterance = null;
        }
        this._armIdleTimer();
    }

    /**
     * å¤„ç†è¯†åˆ«ç»“æœ
     * @param {Object} result - è¯†åˆ«ç»“æœ
     * @param {boolean} isLast - æ˜¯å¦æœ€åä¸€ä¸ªç»“æœ
     * @private
     */
    _handleResult(result, isLast) {
        try {
            const text = result?.result?.text || result?.text || '';
            const duration = result?.audio_info?.duration || 0;

            if (text) {
                const sessionId = this.currentUtterance?.sessionId;

                if (isLast) {
                    BotUtil.makeLog('info',
                        `âœ… [ASRæœ€ç»ˆ] "${text}" (${duration}ms)`,
                        this.deviceId
                    );
                } else {
                    BotUtil.makeLog('info',
                        `âš¡ [ASRä¸­é—´] "${text}" (${duration}ms)`,
                        this.deviceId
                    );
                }

                // å‘é€äº‹ä»¶
                if (this.Bot[this.deviceId]) {
                    this.Bot.em('device.asr_result', {
                        post_type: 'device',
                        event_type: 'asr_result',
                        device_id: this.deviceId,
                        session_id: sessionId || null,
                        text,
                        is_final: !!isLast,
                        duration,
                        result: result?.result || result,
                        self_id: this.deviceId,
                        time: Math.floor(Date.now() / 1000)
                    });
                }
            }
        } catch (e) {
            BotUtil.makeLog('error',
                `âŒ [ASR] å¤„ç†ç»“æœå¤±è´¥: ${e.message}`,
                this.deviceId
            );
        }
    }

    /**
     * å¯åŠ¨ç©ºé—²å®šæ—¶å™¨
     * @private
     */
    _armIdleTimer() {
        if (this.config.idleCloseMs > 0) {
            this._clearIdleTimer();
            this._idleTimer = setTimeout(() => {
                if (this.ws && this.connected && !this.currentUtterance) {
                    BotUtil.makeLog('info', `âœ“ [ASR] ç©ºé—²è¶…æ—¶ï¼Œå…³é—­è¿æ¥`, this.deviceId);
                    this.ws.close();
                }
            }, this.config.idleCloseMs);
        }
    }

    /**
     * æ¸…é™¤ç©ºé—²å®šæ—¶å™¨
     * @private
     */
    _clearIdleTimer() {
        if (this._idleTimer) {
            clearTimeout(this._idleTimer);
            this._idleTimer = null;
        }
    }

    /**
     * å¼€å§‹ä¸€ä¸ªutteranceï¼ˆå…¬å…±APIï¼‰
     * @param {string} sessionId - ä¼šè¯ID
     * @param {Object} audioInfo - éŸ³é¢‘ä¿¡æ¯
     * @returns {Promise<void>}
     */
    async beginUtterance(sessionId, audioInfo) {
        if (this.currentUtterance) {
            BotUtil.makeLog('info',
                `ğŸ”„ [ASR] åˆ‡æ¢ä¼šè¯ï¼š${this.currentUtterance.sessionId} â†’ ${sessionId}`,
                this.deviceId
            );
            try {
                await this.endUtterance();
            } catch (e) {
                // å¿½ç•¥é”™è¯¯
            }
            await new Promise(r => setTimeout(r, 50));
        }

        await this._ensureConnected();
        this._clearIdleTimer();

        this.performanceMetrics = {
            firstResultTime: null,
            totalProcessingTime: 0,
            audioStartTime: Date.now()
        };

        this.currentUtterance = {
            sessionId,
            startedAt: Date.now(),
            ending: false
        };

        this.sequence = 1;

        const fullReq = this._fullClientRequest({
            rate: audioInfo?.sample_rate || 16000,
            bits: audioInfo?.bits || 16,
            channel: audioInfo?.channels || 1
        });

        this.ws.send(fullReq);
        BotUtil.makeLog('info', `âš¡ [ASRä¼šè¯] å¼€å§‹: ${sessionId}`, this.deviceId);
    }

    /**
     * å‘é€éŸ³é¢‘æ•°æ®ï¼ˆå…¬å…±APIï¼‰
     * @param {Buffer} audioBuf - éŸ³é¢‘æ•°æ®
     * @returns {boolean} æ˜¯å¦æˆåŠŸ
     */
    sendAudio(audioBuf) {
        if (!this.ws || !this.connected) return false;
        if (!this.currentUtterance || this.currentUtterance.ending) return false;

        try {
            const frame = this._audioOnlyRequest(audioBuf, false);
            this.ws.send(frame);
            this.lastAudioAt = Date.now();
            return true;
        } catch (e) {
            BotUtil.makeLog('error', `âŒ [ASR] å‘é€éŸ³é¢‘å¤±è´¥: ${e.message}`, this.deviceId);
            return false;
        }
    }

    /**
     * ç»“æŸutteranceï¼ˆå…¬å…±APIï¼‰
     * @returns {Promise<boolean>} æ˜¯å¦æˆåŠŸ
     */
    async endUtterance() {
        if (!this.currentUtterance || this.currentUtterance.ending) return false;

        this.currentUtterance.ending = true;

        if (!this.ws || !this.connected) {
            this.currentUtterance = null;
            this._armIdleTimer();
            return false;
        }

        try {
            const last = this._audioOnlyRequest(Buffer.alloc(0), true);
            this.ws.send(last);

            const sessionId = this.currentUtterance.sessionId;
            BotUtil.makeLog('info', `âœ“ [ASRä¼šè¯] ç»“æŸ: ${sessionId}`, this.deviceId);

            setTimeout(() => {
                if (this.currentUtterance && this.currentUtterance.sessionId === sessionId) {
                    this.currentUtterance = null;
                }
            }, 300);

            this._armIdleTimer();
            return true;

        } catch (e) {
            BotUtil.makeLog('error', `âŒ [ASR] ç»“æŸå¤±è´¥: ${e.message}`, this.deviceId);
            this.currentUtterance = null;
            this._armIdleTimer();
            return false;
        }
    }

    /**
     * é”€æ¯å®¢æˆ·ç«¯
     * @returns {Promise<void>}
     */
    async destroy() {
        this._clearIdleTimer();
        this._clearPingTimer();
        this._clearPongTimer();

        if (this.currentUtterance && !this.currentUtterance.ending) {
            try {
                await this.endUtterance();
            } catch (e) {
                // å¿½ç•¥é”™è¯¯
            }
        }

        this.currentUtterance = null;
        this.sequence = 1;

        if (this.ws) {
            try {
                if (this.ws.readyState === 1) {
                    this.ws.close(1000, 'client destroy');
                } else {
                    this.ws.terminate();
                }
            } catch (e) {
                // å¿½ç•¥é”™è¯¯
            }
            this.ws = null;
        }

        this.connected = false;
        this.connecting = false;
        this.reconnectAttempts = 0;
    }
}
```


--------------------------------------------------------------------------------
## æ–‡ä»¶: ./components/config/deviceConfig.js
--------------------------------------------------------------------------------

```javascript
/**
 * è®¾å¤‡ç®¡ç†å™¨é…ç½®æ–‡ä»¶
 * é›†ä¸­ç®¡ç†æ‰€æœ‰é…ç½®é¡¹ï¼Œä¾¿äºç»´æŠ¤å’Œæ‰©å±•
 */

import cfg from '../../lib/config/config.js';

// ==================== AIé…ç½® ====================
export const AI_CONFIG = {
    enabled: true,
    baseUrl: 'https://api.gptgod.online/v1',
    apiKey: 'sk-kXTC6vIMUnNrYIJhSmOpZMPZHDQuDYWCCIOHdh1qZmxpvqKC',
    chatModel: 'deepseek-r1-0528',
    temperature: 0.8,
    max_tokens: 2000,
    top_p: 0.9,
    presence_penalty: 0.6,
    frequency_penalty: 0.6,
    timeout: 30000,
    displayDelay: 1500,
    persona: 'æˆ‘æ˜¯ä¸€ä¸ªæ™ºèƒ½è¯­éŸ³åŠ©æ‰‹ï¼Œå¯ä»¥å¬æ‡‚ä½ è¯´çš„è¯å¹¶åšå‡ºå›åº”ã€‚æˆ‘ä¼šç”¨ç®€çŸ­çš„è¯è¯­å’Œè¡¨æƒ…ä¸ä½ äº¤æµã€‚'
};

// ==================== ç«å±±TTSé…ç½®ï¼ˆV3åŒå‘æµå¼ï¼‰ ====================
export const VOLCENGINE_TTS_CONFIG = {
    enabled: true,
    provider: 'volcengine', // æœåŠ¡æä¾›å•†æ ‡è¯†
    wsUrl: 'wss://openspeech.bytedance.com/api/v3/tts/bidirection',
    appKey: '5231143210',
    accessKey: 'hSkG2n1yavXry2N3DtQeoTohvWp3qTrR',
    resourceId: 'seed-tts-2.0',
    voiceType: 'zh_female_vv_uranus_bigtts',
    encoding: 'pcm',
    sampleRate: 16000,
    speechRate: 5,
    loudnessRate: 0,
    emotion: 'happy',
    chunkMs: 128,
    chunkDelayMs: 5
};

// ==================== ç«å±±ASRé…ç½® ====================
export const VOLCENGINE_ASR_CONFIG = {
    enabled: true,
    provider: 'volcengine', // æœåŠ¡æä¾›å•†æ ‡è¯†
    wsUrl: 'wss://openspeech.bytedance.com/api/v3/sauc/bigmodel_async',
    appKey: '5231143210',
    accessKey: 'hSkG2n1yavXry2N3DtQeoTohvWp3qTrR',
    resourceId: 'volc.bigasr.sauc.duration',
    enableItn: true,
    enablePunc: true,
    enableDdc: false,
    showUtterances: true,
    resultType: 'full',
    enableAccelerateText: true,
    accelerateScore: 15,
    persistentWs: true,
    idleCloseMs: 6000,
    endWindowSize: 350,
    forceToSpeechTime: 500,
    maxAudioBufferSize: 30,
    asrFinalTextWaitMs: 1200,
};

// ==================== ç³»ç»Ÿé…ç½® ====================
export const SYSTEM_CONFIG = {
    heartbeatInterval: cfg.device?.heartbeat_interval || 30,
    heartbeatTimeout: cfg.device?.heartbeat_timeout || 180,
    commandTimeout: cfg.device?.command_timeout || 10000,
    maxDevices: cfg.device?.max_devices || 100,
    maxLogsPerDevice: cfg.device?.max_logs_per_device || 100,
    messageQueueSize: cfg.device?.message_queue_size || 100,
    wsPingIntervalMs: 30000,
    wsPongTimeoutMs: 10000,
    wsReconnectDelayMs: 2000,
    wsMaxReconnectAttempts: 5,
    enableDetailedLogs: true,
    enablePerformanceLogs: true,
    audioSaveDir: './data/wav'
};

// ==================== TTSäº‹ä»¶å®šä¹‰ ====================
export const TTS_EVENTS = {
    START_CONNECTION: 1,
    FINISH_CONNECTION: 2,
    CONNECTION_STARTED: 50,
    CONNECTION_FAILED: 51,
    CONNECTION_FINISHED: 52,
    START_SESSION: 100,
    CANCEL_SESSION: 101,
    FINISH_SESSION: 102,
    SESSION_STARTED: 150,
    SESSION_CANCELED: 151,
    SESSION_FINISHED: 152,
    SESSION_FAILED: 153,
    TASK_REQUEST: 200,
    TTS_SENTENCE_START: 350,
    TTS_SENTENCE_END: 351,
    TTS_RESPONSE: 352
};

// ==================== è¡¨æƒ…å…³é”®è¯æ˜ å°„ ====================
export const EMOTION_KEYWORDS = {
    'å¼€å¿ƒ': 'happy',
    'ä¼¤å¿ƒ': 'sad',
    'ç”Ÿæ°”': 'angry',
    'æƒŠè®¶': 'surprise',
    'çˆ±': 'love',
    'é…·': 'cool',
    'ç¡è§‰': 'sleep',
    'æ€è€ƒ': 'think',
    'çœ¨çœ¼': 'wink',
    'å¤§ç¬‘': 'laugh'
};

// ==================== æ”¯æŒçš„è¡¨æƒ…åˆ—è¡¨ ====================
export const SUPPORTED_EMOTIONS = [
    'happy', 'sad', 'angry', 'surprise', 'love',
    'cool', 'sleep', 'think', 'wink', 'laugh'
];
```


--------------------------------------------------------------------------------
## æ–‡ä»¶: ./components/tts/TTSFactory.js
--------------------------------------------------------------------------------

```javascript
/**
 * TTSå·¥å‚ç±»
 * ç»Ÿä¸€ç®¡ç†ä¸åŒå¹³å°çš„TTSå®¢æˆ·ç«¯åˆ›å»º
 * æ”¯æŒæ‰©å±•å¤šä¸ªTTSæœåŠ¡æä¾›å•†
 */

import VolcengineTTSClient from './VolcengineTTSClient.js';

/**
 * TTSå·¥å‚ç±»
 */
export default class TTSFactory {
    /**
     * åˆ›å»ºTTSå®¢æˆ·ç«¯
     * @param {string} deviceId - è®¾å¤‡ID
     * @param {Object} config - TTSé…ç½®
     * @param {Object} Bot - Botå®ä¾‹
     * @returns {Object} TTSå®¢æˆ·ç«¯å®ä¾‹
     */
    static createClient(deviceId, config, Bot) {
        if (!config.enabled) {
            throw new Error('TTSæœªå¯ç”¨');
        }

        const provider = config.provider || 'volcengine';

        switch (provider.toLowerCase()) {
            case 'volcengine':
                return new VolcengineTTSClient(deviceId, config, Bot);
            
            // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ å…¶ä»–TTSæä¾›å•†
            // case 'aliyun':
            //     return new AliyunTTSClient(deviceId, config, Bot);
            // case 'tencent':
            //     return new TencentTTSClient(deviceId, config, Bot);
            
            default:
                throw new Error(`ä¸æ”¯æŒçš„TTSæä¾›å•†: ${provider}`);
        }
    }

    /**
     * è·å–æ”¯æŒçš„TTSæä¾›å•†åˆ—è¡¨
     * @returns {Array<string>} æä¾›å•†åˆ—è¡¨
     */
    static getSupportedProviders() {
        return ['volcengine'];
    }

    /**
     * æ£€æŸ¥æä¾›å•†æ˜¯å¦æ”¯æŒ
     * @param {string} provider - æä¾›å•†åç§°
     * @returns {boolean} æ˜¯å¦æ”¯æŒ
     */
    static isProviderSupported(provider) {
        return this.getSupportedProviders().includes(provider.toLowerCase());
    }
}
```


--------------------------------------------------------------------------------
## æ–‡ä»¶: ./components/tts/VolcengineTTSClient.js
--------------------------------------------------------------------------------

```javascript
/**
 * ç«å±±å¼•æ“TTSå®¢æˆ·ç«¯ï¼ˆV3åŒå‘æµå¼åè®®ï¼‰
 * å®ç°æ–‡æœ¬è½¬è¯­éŸ³åŠŸèƒ½ï¼Œæ”¯æŒå®æ—¶æµå¼åˆæˆ
 */

import WebSocket from 'ws';
import zlib from 'zlib';
import { v4 as uuidv4 } from 'uuid';
import BotUtil from '../../lib/common/util.js';
import { TTS_EVENTS } from '../config/deviceConfig.js';

export default class VolcengineTTSClient {
    /**
     * æ„é€ å‡½æ•°
     * @param {string} deviceId - è®¾å¤‡ID
     * @param {Object} config - TTSé…ç½®
     * @param {Object} Bot - Botå®ä¾‹
     */
    constructor(deviceId, config, Bot) {
        this.deviceId = deviceId;
        this.config = config;
        this.Bot = Bot;
        
        // WebSocketç›¸å…³
        this.ws = null;
        this.connected = false;
        this.connecting = false;
        
        // è¿æ¥å’Œä¼šè¯çŠ¶æ€
        this.connectionId = null;
        this.currentSessionId = null;
        this.sessionActive = false;
        
        // ç»Ÿè®¡ä¿¡æ¯
        this.totalAudioBytes = 0;
    }

    /**
     * ç”ŸæˆWebSocketè¿æ¥å¤´éƒ¨
     * @returns {Object} è¯·æ±‚å¤´å¯¹è±¡
     * @private
     */
    _headers() {
        return {
            'X-Api-App-Key': this.config.appKey,
            'X-Api-Access-Key': this.config.accessKey,
            'X-Api-Resource-Id': this.config.resourceId,
            'X-Api-Connect-Id': uuidv4()
        };
    }

    /**
     * æ„å»ºåè®®å¤´éƒ¨ï¼ˆ4å­—èŠ‚ï¼‰
     * @param {number} messageType - æ¶ˆæ¯ç±»å‹
     * @param {number} messageFlags - æ¶ˆæ¯æ ‡å¿—
     * @param {number} serialization - åºåˆ—åŒ–æ–¹å¼
     * @param {number} compression - å‹ç¼©æ–¹å¼
     * @returns {Buffer} åè®®å¤´Buffer
     * @private
     */
    _protoHeader(messageType, messageFlags, serialization, compression) {
        const header = Buffer.alloc(4);
        header[0] = 0x11;
        header[1] = (messageType << 4) | messageFlags;
        header[2] = (serialization << 4) | compression;
        header[3] = 0x00;
        return header;
    }

    /**
     * æ„å»ºäº‹ä»¶å¸§
     * @param {number} event - äº‹ä»¶ç±»å‹
     * @param {string|null} sessionId - ä¼šè¯IDï¼ˆå¯é€‰ï¼‰
     * @param {Object} payload - è´Ÿè½½æ•°æ®
     * @returns {Buffer} äº‹ä»¶å¸§Buffer
     * @private
     */
    _buildEventFrame(event, sessionId = null, payload = {}) {
        const payloadJson = JSON.stringify(payload);
        const payloadBuf = Buffer.from(payloadJson, 'utf-8');

        const header = this._protoHeader(0x1, 0x4, 0x1, 0x0);

        const eventBuf = Buffer.alloc(4);
        eventBuf.writeInt32BE(event, 0);

        let frame = Buffer.concat([header, eventBuf]);

        if (sessionId) {
            const sessionIdBuf = Buffer.from(sessionId, 'utf-8');
            const sessionIdLen = Buffer.alloc(4);
            sessionIdLen.writeUInt32BE(sessionIdBuf.length, 0);
            frame = Buffer.concat([frame, sessionIdLen, sessionIdBuf]);
        }

        const payloadLen = Buffer.alloc(4);
        payloadLen.writeUInt32BE(payloadBuf.length, 0);
        frame = Buffer.concat([frame, payloadLen, payloadBuf]);

        return frame;
    }

    /**
     * è§£ææœåŠ¡å™¨è¿”å›çš„æ•°æ®å¸§
     * @param {Buffer} data - åŸå§‹æ•°æ®
     * @returns {Object|null} è§£æç»“æœ
     * @private
     */
    _parse(data) {
        try {
            if (!data || data.length < 4) return null;

            const messageType = (data[1] >> 4) & 0x0F;
            const messageFlags = data[1] & 0x0F;
            const serialization = (data[2] >> 4) & 0x0F;
            const compression = data[2] & 0x0F;

            let offset = 4;

            // é”™è¯¯å¸§
            if (messageType === 0xF) {
                const errCode = data.readInt32BE(offset);
                offset += 4;
                const errLen = data.readUInt32BE(offset);
                offset += 4;
                const errMsg = data.slice(offset, offset + errLen).toString('utf-8');
                return { type: 'error', errorCode: errCode, errorMessage: errMsg };
            }

            // éŸ³é¢‘å¸§
            if (messageType === 0xB) {
                const event = data.readInt32BE(offset);
                offset += 4;

                const sessionIdLen = data.readUInt32BE(offset);
                offset += 4;
                const sessionId = data.slice(offset, offset + sessionIdLen).toString('utf-8');
                offset += sessionIdLen;

                const audioLen = data.readUInt32BE(offset);
                offset += 4;
                const audioBuf = data.slice(offset, offset + audioLen);

                return {
                    type: 'audio',
                    event,
                    sessionId,
                    data: audioBuf
                };
            }

            // äº‹ä»¶å¸§
            if (messageFlags === 0x4) {
                const event = data.readInt32BE(offset);
                offset += 4;

                let connectionId = null;
                let sessionId = null;

                if (event >= 50 && event < 100) {
                    const connectionIdLen = data.readUInt32BE(offset);
                    offset += 4;
                    connectionId = data.slice(offset, offset + connectionIdLen).toString('utf-8');
                    offset += connectionIdLen;
                } else if ((event >= 100 && event < 200) || (event >= 350 && event < 400)) {
                    const sessionIdLen = data.readUInt32BE(offset);
                    offset += 4;
                    sessionId = data.slice(offset, offset + sessionIdLen).toString('utf-8');
                    offset += sessionIdLen;
                }

                const payloadLen = data.readUInt32BE(offset);
                offset += 4;
                let payload = data.slice(offset, offset + payloadLen);

                if (compression === 0x1 && payload.length > 0) {
                    try {
                        payload = zlib.gunzipSync(payload);
                    } catch (gzipErr) {
                        BotUtil.makeLog('warn', 
                            `[TTS] Gzipè§£å‹å¤±è´¥: ${gzipErr.message}`, 
                            this.deviceId
                        );
                    }
                }

                let payloadObj = {};
                if (serialization === 0x1 && payload.length > 0) {
                    try {
                        const payloadStr = payload.toString('utf-8');
                        payloadObj = JSON.parse(payloadStr);
                    } catch (parseErr) {
                        // å¿½ç•¥è§£æé”™è¯¯
                    }
                }

                return {
                    type: 'event',
                    event,
                    connectionId,
                    sessionId,
                    payload: payloadObj
                };
            }

            return null;
        } catch (e) {
            BotUtil.makeLog('error', `[TTS] è§£æé”™è¯¯: ${e.message}`, this.deviceId);
            return null;
        }
    }

    _sendAudioToDevice(audioData) {
        const deviceBot = this.Bot[this.deviceId];
        if (!deviceBot || !audioData || audioData.length === 0) return Promise.resolve();
        const sr = this.config.sampleRate || 16000;
        const chunkMs = Math.max(5, Math.min(512, this.config.chunkMs || 40));
        const bytesPerMs = (sr * 2) / 1000;
        const chunkBytes = Math.max(2, Math.floor((bytesPerMs * chunkMs) / 2) * 2);
        const delayMs = Math.max(0, this.config.chunkDelayMs || 0);
        return (async () => {
            for (let offset = 0; offset < audioData.length; offset += chunkBytes) {
                const slice = audioData.slice(offset, Math.min(offset + chunkBytes, audioData.length));
                const hex = slice.toString('hex');
                try { deviceBot.sendAudioChunk(hex); } catch {}
                if (delayMs > 0) {
                    await new Promise(r => setTimeout(r, delayMs));
                }
            }
        })();
    }

    /**
     * ç¡®ä¿WebSocketå·²è¿æ¥
     * @returns {Promise<void>}
     * @private
     */
    async _ensureConnected() {
        if (this.connected) return;

        if (this.connecting) {
            for (let i = 0; i < 100; i++) {
                await new Promise(r => setTimeout(r, 30));
                if (this.connected) return;
            }
            throw new Error('TTSè¿æ¥è¶…æ—¶');
        }

        this.connecting = true;

        try {
            await new Promise((resolve, reject) => {
                const connectTimeout = setTimeout(() => {
                    this.connecting = false;
                    reject(new Error('TTSè¿æ¥è¶…æ—¶'));
                }, 8000);

                try {
                    const ws = new WebSocket(this.config.wsUrl, {
                        headers: this._headers(),
                        handshakeTimeout: 8000
                    });

                    this.ws = ws;

                    ws.on('open', () => {
                        BotUtil.makeLog('info', `âš¡ [TTS] WebSocketæ¡æ‰‹æˆåŠŸ`, this.deviceId);

                        const startConnFrame = this._buildEventFrame(TTS_EVENTS.START_CONNECTION, null, {});
                        ws.send(startConnFrame);
                    });

                    ws.on('upgrade', (response) => {
                        const logId = response.headers['x-tt-logid'];
                        if (logId) {
                            BotUtil.makeLog('info', `[TTS] X-Tt-Logid: ${logId}`, this.deviceId);
                        }
                    });

                    ws.on('message', (buf) => {
                        const msg = this._parse(buf);

                        if (!msg) return;

                        if (msg.type === 'error') {
                            BotUtil.makeLog('error',
                                `âŒ [TTSé”™è¯¯] ${msg.errorCode}: ${msg.errorMessage}`,
                                this.deviceId
                            );
                            clearTimeout(connectTimeout);
                            this.connecting = false;
                            reject(new Error(msg.errorMessage));
                            return;
                        }

                        if (msg.type === 'event') {
                            this._handleEvent(msg, connectTimeout, resolve, reject);
                        }

                        if (msg.type === 'audio') {
                            this.totalAudioBytes += msg.data.length;
                            this._sendAudioToDevice(msg.data).catch(e => {
                                BotUtil.makeLog('error', `[TTS] å‘é€éŸ³é¢‘å¤±è´¥: ${e.message}`, this.deviceId);
                            });
                        }
                    });

                    ws.on('error', (err) => {
                        clearTimeout(connectTimeout);
                        BotUtil.makeLog('error',
                            `âŒ [TTS] WebSocketé”™è¯¯: ${err.message}`,
                            this.deviceId
                        );
                        this.connected = false;
                        this.connecting = false;
                        reject(err);
                    });

                    ws.on('close', (code) => {
                        BotUtil.makeLog('info', `âœ“ [TTS] WebSocketå…³é—­ (code=${code})`, this.deviceId);
                        this.connected = false;
                        this.connecting = false;
                        this.sessionActive = false;
                    });

                } catch (e) {
                    clearTimeout(connectTimeout);
                    this.connecting = false;
                    reject(e);
                }
            });
        } catch (e) {
            this.connecting = false;
            throw e;
        }
    }

    /**
     * å¤„ç†æœåŠ¡å™¨äº‹ä»¶
     * @param {Object} msg - æ¶ˆæ¯å¯¹è±¡
     * @param {NodeJS.Timeout} connectTimeout - è¿æ¥è¶…æ—¶å®šæ—¶å™¨
     * @param {Function} resolve - Promise resolveå‡½æ•°
     * @param {Function} reject - Promise rejectå‡½æ•°
     * @private
     */
    _handleEvent(msg, connectTimeout, resolve, reject) {
        switch (msg.event) {
            case TTS_EVENTS.CONNECTION_STARTED:
                clearTimeout(connectTimeout);
                this.connected = true;
                this.connecting = false;
                this.connectionId = msg.connectionId || msg.payload.connection_id || 'unknown';
                BotUtil.makeLog('info',
                    `âœ… [TTS] è¿æ¥å·²å»ºç«‹ (conn_id=${this.connectionId})`,
                    this.deviceId
                );
                resolve();
                break;

            case TTS_EVENTS.CONNECTION_FAILED:
                clearTimeout(connectTimeout);
                this.connecting = false;
                BotUtil.makeLog('error',
                    `âŒ [TTS] è¿æ¥å¤±è´¥: ${msg.payload.message}`,
                    this.deviceId
                );
                reject(new Error(msg.payload.message));
                break;

            case TTS_EVENTS.SESSION_STARTED:
                this.sessionActive = true;
                this.totalAudioBytes = 0;
                BotUtil.makeLog('info',
                    `âš¡ [TTS] Sessionå·²å¯åŠ¨ (${msg.sessionId})`,
                    this.deviceId
                );
                break;

            case TTS_EVENTS.SESSION_FINISHED:
                this.sessionActive = false;
                BotUtil.makeLog('info',
                    `âœ… [TTS] Sessionå·²ç»“æŸ (${this.totalAudioBytes} bytes)`,
                    this.deviceId
                );
                break;

            case TTS_EVENTS.TTS_SENTENCE_START:
                BotUtil.makeLog('debug',
                    `[TTS] å¥å­å¼€å§‹: ${msg.payload.res_params?.text || ''}`,
                    this.deviceId
                );
                break;

            case TTS_EVENTS.TTS_SENTENCE_END:
                BotUtil.makeLog('debug', `[TTS] å¥å­ç»“æŸ`, this.deviceId);
                break;
        }
    }

    /**
     * åˆæˆæ–‡æœ¬
     * @param {string} text - è¦åˆæˆçš„æ–‡æœ¬
     * @returns {Promise<boolean>} - åˆæˆç»“æœ
     */
    async synthesize(text) {
        if (!text || text.trim() === '') {
            BotUtil.makeLog('warn', '[TTS] æ–‡æœ¬ä¸ºç©º', this.deviceId);
            return false;
        }

        try {
            await this._ensureConnected();

            this.currentSessionId = uuidv4();

            const sessionPayload = {
                user: {
                    uid: this.deviceId
                },
                req_params: {
                    speaker: this.config.voiceType,
                    audio_params: {
                        format: this.config.encoding,
                        sample_rate: this.config.sampleRate,
                        speech_rate: this.config.speechRate,
                        loudness_rate: this.config.loudnessRate,
                        emotion: this.config.emotion
                    }
                }
            };

            const startSessionFrame = this._buildEventFrame(
                TTS_EVENTS.START_SESSION,
                this.currentSessionId,
                sessionPayload
            );
            this.ws.send(startSessionFrame);

            await new Promise(resolve => setTimeout(resolve, 100));

            const taskPayload = {
                req_params: {
                    text: text
                }
            };

            const taskFrame = this._buildEventFrame(
                TTS_EVENTS.TASK_REQUEST,
                this.currentSessionId,
                taskPayload
            );
            this.ws.send(taskFrame);

            BotUtil.makeLog('info',
                `âš¡ [TTS] å¼€å§‹åˆæˆ: "${text.substring(0, 30)}${text.length > 30 ? '...' : ''}"`,
                this.deviceId
            );

            const finishFrame = this._buildEventFrame(
                TTS_EVENTS.FINISH_SESSION,
                this.currentSessionId,
                {}
            );
            this.ws.send(finishFrame);

            return true;

        } catch (e) {
            BotUtil.makeLog('error', `âŒ [TTS] åˆæˆå¤±è´¥: ${e.message}`, this.deviceId);
            return false;
        }
    }

    /**
     * é”€æ¯å®¢æˆ·ç«¯
     * @returns {Promise<void>}
     */
    async destroy() {
        if (this.ws) {
            try {
                if (this.connected) {
                    const finishConnFrame = this._buildEventFrame(TTS_EVENTS.FINISH_CONNECTION, null, {});
                    this.ws.send(finishConnFrame);
                    await new Promise(resolve => setTimeout(resolve, 100));
                }

                if (this.ws.readyState === 1) {
                    this.ws.close(1000, 'client destroy');
                } else {
                    this.ws.terminate();
                }
            } catch (e) {
                // å¿½ç•¥é”™è¯¯
            }
            this.ws = null;
        }

        this.connected = false;
        this.connecting = false;
        this.sessionActive = false;
    }
}
```


--------------------------------------------------------------------------------
## æ–‡ä»¶: ./components/util/deviceUtil.js
--------------------------------------------------------------------------------

```javascript
/**
 * è®¾å¤‡å·¥å…·å‡½æ•°æ¨¡å—
 * æä¾›è®¾å¤‡ç®¡ç†ç›¸å…³çš„é€šç”¨å·¥å…·å‡½æ•°
 */

import fs from 'fs';
import path from 'path';

/**
 * åˆå§‹åŒ–ç›®å½•
 * @param {string[]} directories - éœ€è¦åˆ›å»ºçš„ç›®å½•åˆ—è¡¨
 */
export function initializeDirectories(directories) {
    for (const dir of directories) {
        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }
    }
}

/**
 * éªŒè¯è®¾å¤‡æ³¨å†Œæ•°æ®
 * @param {Object} deviceData - è®¾å¤‡æ³¨å†Œæ•°æ®
 * @returns {Object} éªŒè¯ç»“æœ { valid: boolean, error?: string }
 */
export function validateDeviceRegistration(deviceData) {
    if (!deviceData.device_id) {
        return { valid: false, error: 'ç¼ºå°‘device_id' };
    }
    
    if (!deviceData.device_type) {
        return { valid: false, error: 'ç¼ºå°‘device_type' };
    }
    
    return { valid: true };
}

/**
 * ç”Ÿæˆå”¯ä¸€çš„å‘½ä»¤ID
 * @returns {string} å‘½ä»¤ID
 */
export function generateCommandId() {
    return `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

/**
 * æ£€æŸ¥è®¾å¤‡æ˜¯å¦å…·æœ‰æŸä¸ªèƒ½åŠ›
 * @param {Object} device - è®¾å¤‡å¯¹è±¡
 * @param {string} capability - èƒ½åŠ›åç§°
 * @returns {boolean} æ˜¯å¦å…·æœ‰è¯¥èƒ½åŠ›
 */
export function hasCapability(device, capability) {
    return device.capabilities?.includes(capability) || false;
}

/**
 * è·å–éŸ³é¢‘æ–‡ä»¶åˆ—è¡¨
 * @param {string} directory - ç›®å½•è·¯å¾„
 * @param {string} deviceId - è®¾å¤‡IDï¼ˆå¯é€‰ï¼‰
 * @returns {Promise<Array>} éŸ³é¢‘æ–‡ä»¶åˆ—è¡¨
 */
export async function getAudioFileList(directory, deviceId = null) {
    try {
        const files = await fs.promises.readdir(directory);
        
        let audioFiles = files.filter(f => f.endsWith('.wav'));
        
        if (deviceId) {
            audioFiles = audioFiles.filter(f => f.startsWith(deviceId));
        }
        
        const recordings = await Promise.all(
            audioFiles.map(async (filename) => {
                const filepath = path.join(directory, filename);
                const stats = await fs.promises.stat(filepath);
                const parts = filename.replace('.wav', '').split('_');
                const sessionId = parts.length >= 2 ? parts[1] : 'unknown';
                
                return {
                    filename,
                    session_id: sessionId,
                    device_id: parts[0],
                    size: stats.size,
                    created_at: stats.birthtime,
                    path: filepath
                };
            })
        );
        
        // æŒ‰åˆ›å»ºæ—¶é—´å€’åºæ’åº
        recordings.sort((a, b) => b.created_at - a.created_at);
        
        return recordings;
    } catch (e) {
        return [];
    }
}
```


--------------------------------------------------------------------------------
## æ–‡ä»¶: ./lib/bot.js
--------------------------------------------------------------------------------

```javascript
import path from 'path';
import fs from 'node:fs/promises';
import * as fsSync from 'fs';
import { EventEmitter } from "events";
import express from "express";
import http from "node:http";
import https from "node:https";
import tls from "node:tls";
import { WebSocketServer } from "ws";
import compression from 'compression';
import helmet from 'helmet';
import rateLimit from 'express-rate-limit';
import crypto from 'crypto';
import os from 'node:os';
import dgram from 'node:dgram';
import chalk from 'chalk';
import { createProxyMiddleware } from 'http-proxy-middleware';

import PluginsLoader from "./plugins/loader.js";
import ListenerLoader from "./listener/loader.js";
import ApiLoader from "./http/loader.js";
import Packageloader from "./config/loader.js";
import StreamLoader from "./aistream/loader.js";
import BotUtil from './common/util.js';
import cfg from './config/config.js';

export default class Bot extends EventEmitter {
  constructor() {
    super();
    
    // æ ¸å¿ƒå±æ€§åˆå§‹åŒ–
    this.stat = { start_time: Date.now() / 1000 };
    this.bot = this;
    this.bots = {};
    this.adapter = [];
    this.uin = this._createUinManager();
    
    // Expressåº”ç”¨å’ŒæœåŠ¡å™¨
    this.express = Object.assign(express(), { skip_auth: [], quiet: [] });
    this.server = null;
    this.httpsServer = null;
    this.wss = new WebSocketServer({ noServer: true });
    this.wsf = Object.create(null);
    this.fs = Object.create(null);
    
    // é…ç½®å±æ€§
    this.apiKey = '';
    this._cache = BotUtil.getMap('yunzai_cache', { ttl: 60000, autoClean: true });
    this._rateLimiters = new Map();
    this.httpPort = null;
    this.httpsPort = null;
    this.actualPort = null;
    this.actualHttpsPort = null;
    this.url = cfg.server?.server?.url || '';
    
    // åå‘ä»£ç†ç›¸å…³
    this.proxyEnabled = false;
    this.proxyApp = null;
    this.proxyServer = null;
    this.proxyHttpsServer = null;
    this.proxyMiddlewares = new Map();
    this.domainConfigs = new Map();
    this.sslContexts = new Map();
    
    this.ApiLoader = ApiLoader;
    this._initHttpServer();
    this._setupSignalHandlers();
    this.generateApiKey();
    
    return this._createProxy();
  }
  /**
   * é™æ€æ–¹æ³•ç‰ˆæœ¬çš„makeError
   * @static
   * @param {string|Error} message - é”™è¯¯æ¶ˆæ¯æˆ–é”™è¯¯å¯¹è±¡
   * @param {string} [type='Error'] - é”™è¯¯ç±»å‹
   * @param {Object} [details={}] - é¢å¤–çš„é”™è¯¯è¯¦æƒ…
   * @returns {Error} æ ‡å‡†åŒ–çš„é”™è¯¯å¯¹è±¡
   */
  makeError(message, type = 'Error', details = {}) {
    let error;

    if (message instanceof Error) {
      error = message;
      if (type === 'Error' && error.type) {
        type = error.type;
      }
    } else {
      error = new Error(message);
    }

    error.type = type;
    error.timestamp = Date.now();

    if (details && typeof details === 'object') {
      Object.assign(error, details);
    }

    error.source = 'Bot';
    const logMessage = `${type}: ${error.message}`;
    const logDetails = Object.keys(details).length > 0 ?
      chalk.gray(` Details: ${JSON.stringify(details)}`) : '';

    if (typeof BotUtil !== 'undefined' && BotUtil.makeLog) {
      BotUtil.makeLog('error', chalk.red(`âœ— ${logMessage}${logDetails}`), type);

      if (error.stack && cfg?.debug) {
        BotUtil.makeLog('debug', chalk.gray(error.stack), type);
      }
    } else {
      console.error(`[${type}] ${error.message}`, details);
    }

    return error;
  }

  _createUinManager() {
    return Object.assign([], {
      toJSON() {
        if (!this.now) {
          if (this.length <= 2) return this[this.length - 1] || "";
          const array = this.slice(1);
          this.now = array[Math.floor(Math.random() * array.length)];
          setTimeout(() => delete this.now, 60000);
        }
        return this.now;
      },
      toString(raw, ...args) {
        return raw === true ?
          Array.prototype.toString.apply(this, args) :
          this.toJSON().toString(raw, ...args);
      },
      includes(value) {
        return this.some(i => i == value);
      }
    });
  }

  _initHttpServer() {
    this.server = http.createServer(this.express)
      .on("error", err => this._handleServerError(err, false))
      .on("upgrade", this.wsConnect.bind(this));
  }

  _handleServerError(err, isHttps) {
    const handler = this[`server${err.code}`];
    if (typeof handler === "function") {
      return handler.call(this, err, isHttps);
    }
    BotUtil.makeLog("error", err, isHttps ? "HTTPSæœåŠ¡å™¨" : "HTTPæœåŠ¡å™¨");
  }

  /**
   * åˆå§‹åŒ–ä»£ç†åº”ç”¨å’ŒæœåŠ¡å™¨
   */
  async _initProxyApp() {
    const proxyConfig = cfg.server?.proxy;
    if (!proxyConfig?.enabled) return;
    
    // åˆ›å»ºç‹¬ç«‹çš„Expressåº”ç”¨ç”¨äºä»£ç†
    this.proxyApp = express();
    
    // åŠ è½½æ‰€æœ‰åŸŸåçš„SSLè¯ä¹¦
    await this._loadDomainCertificates();
    
    // é…ç½®ä»£ç†è·¯ç”±
    this.proxyApp.use(async (req, res, next) => {
      const hostname = req.hostname || req.headers.host?.split(':')[0];
      
      if (!hostname) {
        return res.status(400).send('é”™è¯¯è¯·æ±‚ï¼šç¼ºå°‘Hostå¤´');
      }
      
      // æŸ¥æ‰¾åŸŸåé…ç½®
      const domainConfig = this._findDomainConfig(hostname);
      
      if (!domainConfig) {
        return res.status(404).send(`åŸŸå ${hostname} æœªé…ç½®`);
      }
      
      // å¤„ç†è·¯å¾„é‡å†™
      if (domainConfig.rewritePath) {
        const { from, to } = domainConfig.rewritePath;
        if (from && req.path.startsWith(from)) {
          const newPath = req.path.replace(from, to || '');
          req.url = newPath + (req.url.includes('?') ? req.url.substring(req.url.indexOf('?')) : '');
          BotUtil.makeLog('debug', `è·¯å¾„é‡å†™ï¼š${req.path} â†’ ${newPath}`, 'ä»£ç†');
        }
      }
      
      // å¦‚æœé…ç½®äº†è‡ªå®šä¹‰ç›®æ ‡ï¼Œä½¿ç”¨è‡ªå®šä¹‰ä»£ç†
      if (domainConfig.target) {
        let middleware = this.proxyMiddlewares.get(domainConfig.domain);
        if (!middleware) {
          middleware = this._createProxyMiddleware(domainConfig);
          this.proxyMiddlewares.set(domainConfig.domain, middleware);
        }
        return middleware(req, res, next);
      }
      
      // é»˜è®¤ä»£ç†åˆ°æœ¬åœ°æœåŠ¡
      const targetPort = this.actualPort;
      const proxyOptions = {
        target: `http://127.0.0.1:${targetPort}`,
        changeOrigin: true,
        ws: domainConfig.ws !== false,
        secure: false,
        logLevel: 'warn',
        onError: (err, req, res) => {
          BotUtil.makeLog('error', `ä»£ç†é”™è¯¯ [${hostname}]: ${err.message}`, 'ä»£ç†');
          if (!res.headersSent) {
            res.status(502).json({
              error: 'ç½‘å…³é”™è¯¯',
              message: 'æ— æ³•è¿æ¥åˆ°ä¸Šæ¸¸æœåŠ¡å™¨',
              upstream: `http://127.0.0.1:${targetPort}`
            });
          }
        }
      };
      
      const proxy = createProxyMiddleware(proxyOptions);
      return proxy(req, res, next);
    });
    
    // åˆ›å»ºHTTPä»£ç†æœåŠ¡å™¨
    this.proxyServer = http.createServer(this.proxyApp);
    this.proxyServer.on("error", err => {
      BotUtil.makeLog("error", `HTTPä»£ç†æœåŠ¡å™¨é”™è¯¯ï¼š${err.message}`, 'ä»£ç†');
    });
    
    // å¦‚æœæœ‰HTTPSåŸŸåï¼Œåˆ›å»ºHTTPSä»£ç†æœåŠ¡å™¨
    if (this.sslContexts.size > 0) {
      await this._createHttpsProxyServer();
    }
  }

  /**
   * åŠ è½½åŸŸåSSLè¯ä¹¦
   */
  async _loadDomainCertificates() {
    const proxyConfig = cfg.server?.proxy;
    if (!proxyConfig?.domains) return;
    
    for (const domainConfig of proxyConfig.domains) {
      if (!domainConfig.ssl?.enabled || !domainConfig.ssl?.certificate) continue;
      
      const cert = domainConfig.ssl.certificate;
      if (!cert.key || !cert.cert) {
        BotUtil.makeLog("warn", `åŸŸå ${domainConfig.domain} ç¼ºå°‘è¯ä¹¦é…ç½®`, 'ä»£ç†');
        continue;
      }
      
      if (!fsSync.existsSync(cert.key) || !fsSync.existsSync(cert.cert)) {
        BotUtil.makeLog("warn", `åŸŸå ${domainConfig.domain} çš„è¯ä¹¦æ–‡ä»¶ä¸å­˜åœ¨`, 'ä»£ç†');
        continue;
      }
      
      try {
        const context = tls.createSecureContext({
          key: await fs.readFile(cert.key),
          cert: await fs.readFile(cert.cert),
          ca: cert.ca && fsSync.existsSync(cert.ca) ? await fs.readFile(cert.ca) : undefined
        });
        
        this.sslContexts.set(domainConfig.domain, context);
        this.domainConfigs.set(domainConfig.domain, domainConfig);
        BotUtil.makeLog("info", `âœ“ åŠ è½½SSLè¯ä¹¦ï¼š${domainConfig.domain}`, 'ä»£ç†');
      } catch (err) {
        BotUtil.makeLog("error", `åŠ è½½SSLè¯ä¹¦å¤±è´¥ [${domainConfig.domain}]: ${err.message}`, 'ä»£ç†');
      }
    }
  }

  /**
   * åˆ›å»ºHTTPSä»£ç†æœåŠ¡å™¨
   */
  async _createHttpsProxyServer() {
    // ä½¿ç”¨ç¬¬ä¸€ä¸ªå¯ç”¨è¯ä¹¦ä½œä¸ºé»˜è®¤è¯ä¹¦
    const [firstDomain] = this.sslContexts.keys();
    const domainConfig = this.domainConfigs.get(firstDomain);
    
    if (!domainConfig?.ssl?.certificate) {
      BotUtil.makeLog("error", "æ²¡æœ‰å¯ç”¨çš„SSLè¯ä¹¦", 'ä»£ç†');
      return;
    }
    
    const cert = domainConfig.ssl.certificate;
    
    const httpsOptions = {
      key: await fs.readFile(cert.key),
      cert: await fs.readFile(cert.cert),
      ca: cert.ca && fsSync.existsSync(cert.ca) ? await fs.readFile(cert.ca) : undefined,
      // SNIå›è°ƒå¤„ç†å¤šåŸŸåè¯ä¹¦
      SNICallback: (servername, cb) => {
        const context = this.sslContexts.get(servername) || this._findWildcardContext(servername);
        cb(null, context);
      }
    };
    
    this.proxyHttpsServer = https.createServer(httpsOptions, this.proxyApp);
    this.proxyHttpsServer.on("error", err => {
      BotUtil.makeLog("error", `HTTPSä»£ç†æœåŠ¡å™¨é”™è¯¯ï¼š${err.message}`, 'ä»£ç†');
    });
  }

  /**
   * åˆ›å»ºåŸŸåä¸“ç”¨ä»£ç†ä¸­é—´ä»¶
   */
  _createProxyMiddleware(domainConfig) {
    const proxyOptions = {
      target: domainConfig.target,
      changeOrigin: true,
      ws: domainConfig.ws !== false,
      preserveHostHeader: domainConfig.preserveHostHeader === true,
      timeout: domainConfig.timeout || 30000,
      proxyTimeout: domainConfig.timeout || 30000,
      secure: false,
      logLevel: 'warn',
      
      onProxyReq: (proxyReq, req, res) => {
        // æ·»åŠ è‡ªå®šä¹‰è¯·æ±‚å¤´
        if (domainConfig.headers?.request) {
          for (const [key, value] of Object.entries(domainConfig.headers.request)) {
            proxyReq.setHeader(key, value);
          }
        }
      },
      
      onProxyRes: (proxyRes, req, res) => {
        // æ·»åŠ è‡ªå®šä¹‰å“åº”å¤´
        if (domainConfig.headers?.response) {
          for (const [key, value] of Object.entries(domainConfig.headers.response)) {
            res.setHeader(key, value);
          }
        }
      },
      
      onError: (err, req, res) => {
        BotUtil.makeLog('error', `ä»£ç†é”™è¯¯ [${domainConfig.domain}]: ${err.message}`, 'ä»£ç†');
        if (!res.headersSent) {
          res.status(502).json({
            error: 'ç½‘å…³é”™è¯¯',
            message: 'ä»£ç†æœåŠ¡å™¨é”™è¯¯',
            domain: domainConfig.domain,
            target: domainConfig.target
          });
        }
      }
    };
    
    // è·¯å¾„é‡å†™è§„åˆ™
    if (domainConfig.pathRewrite && typeof domainConfig.pathRewrite === 'object') {
      proxyOptions.pathRewrite = domainConfig.pathRewrite;
    }
    
    return createProxyMiddleware(proxyOptions);
  }

  /**
   * æŸ¥æ‰¾åŸŸåé…ç½®ï¼ˆæ”¯æŒé€šé…ç¬¦ï¼‰
   */
  _findDomainConfig(hostname) {
    // ç²¾ç¡®åŒ¹é…
    if (this.domainConfigs.has(hostname)) {
      return this.domainConfigs.get(hostname);
    }
    
    // é€šé…ç¬¦åŒ¹é…
    for (const [domain, config] of this.domainConfigs) {
      if (domain.startsWith('*.')) {
        const baseDomain = domain.substring(2);
        if (hostname === baseDomain || hostname.endsWith('.' + baseDomain)) {
          const subdomain = hostname === baseDomain ? '' : 
                           hostname.substring(0, hostname.length - baseDomain.length - 1);
          const configCopy = { ...config, subdomain };
          
          // æ›¿æ¢è·¯å¾„ä¸­çš„å˜é‡
          if (config.rewritePath?.to?.includes('${subdomain}')) {
            configCopy.rewritePath = {
              ...config.rewritePath,
              to: config.rewritePath.to.replace('${subdomain}', subdomain)
            };
          }
          
          return configCopy;
        }
      }
    }
    
    return null;
  }

  /**
   * æŸ¥æ‰¾é€šé…ç¬¦SSLè¯ä¹¦
   */
  _findWildcardContext(servername) {
    for (const [domain, context] of this.sslContexts) {
      if (domain.startsWith('*.')) {
        const baseDomain = domain.substring(2);
        if (servername === baseDomain || servername.endsWith('.' + baseDomain)) {
          return context;
        }
      }
    }
    return null;
  }

  /**
   * åˆå§‹åŒ–ä¸­é—´ä»¶å’Œè·¯ç”±
   */
  _initializeMiddlewareAndRoutes() {
    // å‹ç¼©ä¸­é—´ä»¶
    if (cfg.server?.compression?.enabled !== false) {
      this.express.use(compression({
        filter: (req, res) => !req.headers['x-no-compression'] && compression.filter(req, res),
        level: cfg.server?.compression?.level || 6,
        threshold: cfg.server?.compression?.threshold || 1024
      }));
    }
    
    // å®‰å…¨å¤´éƒ¨
    if (cfg.server?.security?.helmet?.enabled !== false) {
      this.express.use(helmet({
        contentSecurityPolicy: false,
        crossOriginEmbedderPolicy: false,
        hsts: cfg.server?.security?.hsts?.enabled === true ? {
          maxAge: cfg.server.security.hsts.maxAge || 31536000,
          includeSubDomains: cfg.server.security.hsts.includeSubDomains !== false,
          preload: cfg.server.security.hsts.preload === true
        } : false
      }));
    }
    
    this._setupCors();
    this._setupRequestLogging();
    this._setupRateLimiting();
    this._setupBodyParsers();
    this.express.use(this._authMiddleware.bind(this));
    
    // ç³»ç»Ÿè·¯ç”±
    this.express.get('/status', this._statusHandler.bind(this));
    this.express.get('/health', this._healthHandler.bind(this));
    this.express.use('/File', this._fileHandler.bind(this));
    
    // æ ‡è®°UIè®¿é—®å¹¶ä¸‹å‘è½»é‡é‰´æƒCookieï¼ˆä»…ç”¨äºåŒæºå‰ç«¯è°ƒç”¨APIï¼‰
    this.express.use((req, res, next) => {
      try {
        if (req.path.startsWith('/xrk')) {
          res.cookie?.('xrk_ui', '1', {
            httpOnly: true,
            sameSite: 'lax'
          });
          // æ—  cookie ä¸­é—´ä»¶æ—¶ï¼Œæ‰‹åŠ¨è®¾ç½® Set-Cookie
          if (!res.cookie) {
            res.setHeader('Set-Cookie', 'xrk_ui=1; Path=/; HttpOnly; SameSite=Lax');
          }
        }
      } catch {}
      next();
    });

    this._setupStaticServing();
  }

  /**
   * é…ç½®CORSè·¨åŸŸ
   */
  _setupCors() {
    const corsConfig = cfg.server?.cors;
    if (corsConfig?.enabled === false) return;
    
    this.express.use((req, res, next) => {
      const config = corsConfig || {};
      const allowedOrigins = config.origins || ['*'];
      const origin = req.headers.origin;
      
      if (allowedOrigins.includes('*') || allowedOrigins.includes(origin)) {
        res.header('Access-Control-Allow-Origin', origin || '*');
      }
      
      res.header('Access-Control-Allow-Methods',
        config.methods?.join(', ') || 'GET, POST, PUT, DELETE, OPTIONS');
      res.header('Access-Control-Allow-Headers',
        config.headers?.join(', ') || 'Content-Type, Authorization, X-API-Key');
      res.header('Access-Control-Allow-Credentials',
        config.credentials ? 'true' : 'false');
      
      if (config.maxAge) {
        res.header('Access-Control-Max-Age', String(config.maxAge));
      }
      
      if (req.method === 'OPTIONS') return res.sendStatus(200);
      next();
    });
  }

  /**
   * è¯·æ±‚æ—¥å¿—ä¸­é—´ä»¶
   */
  _setupRequestLogging() {
    if (cfg.server?.logging?.requests === false) return;
    
    this.express.use((req, res, next) => {
      const start = Date.now();
      res.on('finish', () => {
        const duration = Date.now() - start;
        const quietPaths = cfg.server?.logging?.quiet || [];
        
        if (!quietPaths.some(p => req.path.startsWith(p))) {
          const statusColor = res.statusCode < 400 ? 'green' :
                             res.statusCode < 500 ? 'yellow' : 'red';
          const method = chalk.cyan(req.method.padEnd(6));
          const status = chalk[statusColor](res.statusCode);
          const time = chalk.gray(`${duration}ms`.padStart(7));
          const path = chalk.white(req.path);
          const host = req.hostname ? chalk.gray(` [${req.hostname}]`) : '';
          
          BotUtil.makeLog('debug', `${method} ${status} ${time} ${path}${host}`, 'HTTP');
        }
      });
      next();
    });
  }

  /**
   * é™æ€æ–‡ä»¶æœåŠ¡é…ç½®
   */
  _setupStaticServing() {
    this.express.use(this._directoryIndexMiddleware.bind(this));
    this.express.use(this._staticSecurityMiddleware.bind(this));
    
    this.express.use((req, res, next) => {
      const staticRoot = req.staticRoot || path.join(process.cwd(), 'www');
      
      if (!fsSync.existsSync(staticRoot)) {
        fsSync.mkdirSync(staticRoot, { recursive: true });
      }
      
      const staticOptions = {
        index: cfg.server?.static?.index || ['index.html', 'index.htm'],
        dotfiles: 'deny',
        extensions: cfg.server?.static?.extensions || false,
        fallthrough: true,
        maxAge: cfg.server?.static?.cacheTime || '1d',
        etag: true,
        lastModified: true,
        setHeaders: (res, filePath) => this._setStaticHeaders(res, filePath)
      };
      
      express.static(staticRoot, staticOptions)(req, res, next);
    });
    
    this.express.get('/favicon.ico', this._handleFavicon.bind(this));
    this.express.get('/robots.txt', this._handleRobotsTxt.bind(this));
  }

  /**
   * ç›®å½•ç´¢å¼•ä¸­é—´ä»¶
   */
  _directoryIndexMiddleware(req, res, next) {
    const hasExtension = path.extname(req.path);
    if (hasExtension || req.path.endsWith('/')) {
      return next();
    }
    
    const staticRoot = req.staticRoot || path.join(process.cwd(), 'www');
    const dirPath = path.join(staticRoot, req.path);
    
    if (fsSync.existsSync(dirPath) && fsSync.statSync(dirPath).isDirectory()) {
      const indexFiles = cfg.server?.static?.index || ['index.html', 'index.htm'];
      
      for (const indexFile of indexFiles) {
        const indexPath = path.join(dirPath, indexFile);
        if (fsSync.existsSync(indexPath)) {
          const redirectUrl = req.path + '/';
          BotUtil.makeLog('debug', `ç›®å½•é‡å®šå‘ï¼š${req.path} â†’ ${redirectUrl}`, 'æœåŠ¡å™¨');
          return res.redirect(301, redirectUrl);
        }
      }
    }
    
    next();
  }

  /**
   * è®¾ç½®é™æ€æ–‡ä»¶å“åº”å¤´
   */
  _setStaticHeaders(res, filePath) {
    const ext = path.extname(filePath).toLowerCase();
    const mimeTypes = {
      '.html': 'text/html; charset=utf-8',
      '.css': 'text/css; charset=utf-8',
      '.js': 'application/javascript; charset=utf-8',
      '.json': 'application/json; charset=utf-8',
      '.png': 'image/png',
      '.jpg': 'image/jpeg',
      '.jpeg': 'image/jpeg',
      '.gif': 'image/gif',
      '.svg': 'image/svg+xml',
      '.ico': 'image/x-icon',
      '.webp': 'image/webp',
      '.mp4': 'video/mp4',
      '.webm': 'video/webm',
      '.mp3': 'audio/mpeg',
      '.wav': 'audio/wav',
      '.pdf': 'application/pdf',
      '.zip': 'application/zip',
      '.woff': 'font/woff',
      '.woff2': 'font/woff2',
      '.ttf': 'font/ttf',
      '.otf': 'font/otf'
    };
    
    if (mimeTypes[ext]) {
      res.setHeader('Content-Type', mimeTypes[ext]);
    }
    
    res.setHeader('X-Content-Type-Options', 'nosniff');
    
    const cacheConfig = cfg.server?.static?.cache || {};
    if (['.html', '.htm'].includes(ext)) {
      res.setHeader('Cache-Control', 'no-cache, must-revalidate');
    } else if (['.css', '.js', '.json'].includes(ext)) {
      res.setHeader('Cache-Control', `public, max-age=${cacheConfig.static || 86400}`);
    } else if (['.png', '.jpg', '.jpeg', '.gif', '.svg', '.webp', '.ico'].includes(ext)) {
      res.setHeader('Cache-Control', `public, max-age=${cacheConfig.images || 604800}`);
    }
  }

  /**
   * é™æ€æ–‡ä»¶å®‰å…¨ä¸­é—´ä»¶
   */
  _staticSecurityMiddleware(req, res, next) {
    const normalizedPath = path.normalize(req.path);
    
    if (normalizedPath.includes('..')) {
      return res.status(403).json({ error: 'ç¦æ­¢è®¿é—®' });
    }
    
    const hiddenPatterns = cfg.server?.security?.hiddenFiles || [
      /^\./, /\/\./, /node_modules/, /\.git/
    ];
    
    const isHidden = hiddenPatterns.some(pattern => {
      if (typeof pattern === 'string') {
        return normalizedPath.includes(pattern);
      }
      return pattern.test(normalizedPath);
    });
    
    if (isHidden) {
      return res.status(404).json({ error: 'æœªæ‰¾åˆ°' });
    }
    
    next();
  }

  /**
   * å¤„ç†faviconè¯·æ±‚
   */
  async _handleFavicon(req, res) {
    const staticRoot = req.staticRoot || path.join(process.cwd(), 'www');
    const faviconPath = path.join(staticRoot, 'favicon.ico');
    
    if (fsSync.existsSync(faviconPath)) {
      res.set({
        'Content-Type': 'image/x-icon',
        'Cache-Control': 'public, max-age=604800'
      });
      return res.sendFile(faviconPath);
    }
    
    res.status(204).end();
  }

  /**
   * å¤„ç†robots.txtè¯·æ±‚
   */
  async _handleRobotsTxt(req, res) {
    const staticRoot = req.staticRoot || path.join(process.cwd(), 'www');
    const robotsPath = path.join(staticRoot, 'robots.txt');
    
    if (fsSync.existsSync(robotsPath)) {
      res.set({
        'Content-Type': 'text/plain; charset=utf-8',
        'Cache-Control': 'public, max-age=86400'
      });
      return res.sendFile(robotsPath);
    }
    
    const defaultRobots = `User-agent: *
Disallow: /api/
Disallow: /config/
Disallow: /data/
Disallow: /lib/
Disallow: /plugins/
Disallow: /temp/
Allow: /

Sitemap: ${this.getServerUrl()}/sitemap.xml`;
    
    res.set('Content-Type', 'text/plain; charset=utf-8');
    res.send(defaultRobots);
  }

  /**
   * é€Ÿç‡é™åˆ¶é…ç½®
   */
  _setupRateLimiting() {
    const rateLimitConfig = cfg.server?.rateLimit;
    if (rateLimitConfig?.enabled === false) return;
    
    const createLimiter = (options) => rateLimit({
      windowMs: options.windowMs || 15 * 60 * 1000,
      max: options.max || 100,
      message: options.message || 'è¯·æ±‚è¿‡äºé¢‘ç¹',
      standardHeaders: true,
      legacyHeaders: false,
      skip: (req) => this._isLocalConnection(req.ip)
    });
    
    // å…¨å±€é™åˆ¶
    if (rateLimitConfig?.global) {
      this.express.use(createLimiter(rateLimitConfig.global));
    }
    
    // APIé™åˆ¶
    if (rateLimitConfig?.api) {
      this.express.use('/api', createLimiter(rateLimitConfig.api));
    }
  }

  /**
   * è¯·æ±‚ä½“è§£æå™¨é…ç½®
   */
  _setupBodyParsers() {
    const limits = cfg.server?.limits || {};
    
    this.express.use(express.urlencoded({
      extended: false,
      limit: limits.urlencoded || '10mb'
    }));
    
    this.express.use(express.json({
      limit: limits.json || '10mb'
    }));
    
    this.express.use(express.raw({
      limit: limits.raw || '10mb'
    }));
  }

  /**
   * ä¿¡å·å¤„ç†å™¨è®¾ç½®
   */
  _setupSignalHandlers() {
    const closeHandler = async () => await this.closeServer();
    process.on('SIGINT', closeHandler);
    process.on('SIGTERM', closeHandler);
  }

  /**
   * åˆ›å»ºBotä»£ç†å¯¹è±¡
   */
  _createProxy() {
    return new Proxy(this.bots, {
      get: (target, prop) => {
        if (target[prop] !== undefined) return target[prop];
        if (this[prop] !== undefined) return this[prop];
        
        const utilValue = BotUtil[prop];
        if (utilValue !== undefined) {
          return typeof utilValue === 'function' ?
            utilValue.bind(BotUtil) : utilValue;
        }
        
        for (const botId of [this.uin.toString(), ...this.uin]) {
          const bot = target[botId];
          if (bot?.[prop] !== undefined) {
            BotUtil.makeLog("trace", `é‡å®šå‘ Bot.${prop} åˆ° Bot.${botId}.${prop}`);
            return typeof bot[prop] === "function" ?
              bot[prop].bind(bot) : bot[prop];
          }
        }
        
        BotUtil.makeLog("trace", `Bot.${prop} ä¸å­˜åœ¨`);
        return undefined;
      }
    });
  }

  /**
   * ç”ŸæˆAPIå¯†é’¥
   */
  async generateApiKey() {
    const apiKeyConfig = cfg.server?.auth?.apiKey || {};
    
    // å¦‚æœæ˜ç¡®ç¦ç”¨APIå¯†é’¥ï¼Œåˆ™ä¸ç”Ÿæˆ
    if (apiKeyConfig.enabled === false) {
      BotUtil.makeLog('info', 'âš  APIå¯†é’¥è®¤è¯å·²ç¦ç”¨', 'æœåŠ¡å™¨');
      return null;
    }
    
    const apiKeyPath = path.join(process.cwd(),
      apiKeyConfig.file || 'config/server_config/api_key.json');
    
    try {
      if (fsSync.existsSync(apiKeyPath)) {
        const keyData = JSON.parse(await fs.readFile(apiKeyPath, 'utf8'));
        this.apiKey = keyData.key;
        BotUtil.apiKey = this.apiKey;
        BotUtil.makeLog('info', 'âœ“ å·²åŠ è½½APIå¯†é’¥', 'æœåŠ¡å™¨');
        return this.apiKey;
      }
      
      const keyLength = apiKeyConfig.length || 64;
      this.apiKey = BotUtil.randomString(keyLength);
      
      await BotUtil.mkdir(path.dirname(apiKeyPath));
      await fs.writeFile(apiKeyPath, JSON.stringify({
        key: this.apiKey,
        generated: new Date().toISOString(),
        note: 'è¿œç¨‹è®¿é—®APIå¯†é’¥'
      }, null, 2), 'utf8');
      
      if (process.platform !== 'win32') {
        try { await fs.chmod(apiKeyPath, 0o600); } catch { }
      }
      
      BotUtil.apiKey = this.apiKey;
      BotUtil.makeLog('success', `âš¡ ç”Ÿæˆæ–°APIå¯†é’¥ï¼š${this.apiKey}`, 'æœåŠ¡å™¨');
      return this.apiKey;
      
    } catch (error) {
      BotUtil.makeLog('error', `APIå¯†é’¥å¤„ç†å¤±è´¥ï¼š${error.message}`, 'æœåŠ¡å™¨');
      this.apiKey = BotUtil.randomString(64);
      BotUtil.apiKey = this.apiKey;
      return this.apiKey;
    }
  }

  /**
   * è®¤è¯ä¸­é—´ä»¶
   */
  _authMiddleware(req, res, next) {
    req.rid = `${req.ip}:${req.socket.remotePort}`;
    req.sid = `${req.protocol}://${req.hostname}:${req.socket.localPort}${req.originalUrl}`;
    
    const authConfig = cfg.server?.auth || {};
    const whitelist = authConfig.whitelist || [
      '/', '/favicon.ico', '/health', '/status', '/robots.txt'
    ];
    
    const isWhitelisted = whitelist.some(whitelistPath => {
      // ç²¾ç¡®åŒ¹é…
      if (whitelistPath === req.path) {
        BotUtil.makeLog("debug", `ç™½åå•ç²¾ç¡®åŒ¹é…ï¼š${req.path}`, 'è®¤è¯');
        return true;
      }
      
      // é€šé…ç¬¦åŒ¹é… (å¦‚ /api/*)
      if (whitelistPath.endsWith('*')) {
        const prefix = whitelistPath.slice(0, -1);
        const matches = req.path.startsWith(prefix);
        if (matches) {
          BotUtil.makeLog("debug", `ç™½åå•é€šé…ç¬¦åŒ¹é…ï¼š${req.path} matches ${whitelistPath}`, 'è®¤è¯');
        }
        return matches;
      }
      
      if (whitelistPath.startsWith('/api/') && req.path === whitelistPath) {
        BotUtil.makeLog("debug", `ç™½åå•APIè·¯å¾„åŒ¹é…ï¼š${req.path}`, 'è®¤è¯');
        return true;
      }
      
      // ç›®å½•åŒ¹é…ï¼ˆä¸å¸¦é€šé…ç¬¦ä½†ä»¥/ç»“å°¾ï¼‰
      if (!whitelistPath.endsWith('/') && req.path === whitelistPath + '/') {
        BotUtil.makeLog("debug", `ç™½åå•ç›®å½•åŒ¹é…ï¼š${req.path} matches ${whitelistPath}/`, 'è®¤è¯');
        return true;
      }
      
      return false;
    });
    
    // é™æ€æ–‡ä»¶æ£€æŸ¥
    const isStaticFile = /\.(html|css|js|json|png|jpg|jpeg|gif|svg|webp|ico|mp4|webm|mp3|wav|pdf|zip|woff|woff2|ttf|otf)$/i.test(req.path);
    
    // ç™½åå•æˆ–é™æ€æ–‡ä»¶ç›´æ¥æ”¾è¡Œ
    if (isWhitelisted) {
      BotUtil.makeLog("debug", `ç™½åå•è·¯å¾„ï¼Œè·³è¿‡è®¤è¯ï¼š${req.path}`, 'è®¤è¯');
      return next();
    }
    
    if (isStaticFile) {
      BotUtil.makeLog("debug", `é™æ€æ–‡ä»¶ï¼Œè·³è¿‡è®¤è¯ï¼š${req.path}`, 'è®¤è¯');
      return next();
    }
    
    // æœ¬åœ°è¿æ¥è·³è¿‡è®¤è¯
    if (this._isLocalConnection(req.ip)) {
      BotUtil.makeLog("debug", `æœ¬åœ°è¿æ¥ï¼Œè·³è¿‡è®¤è¯ï¼š${req.ip}`, 'è®¤è¯');
      return next();
    }
    
    // æ¥è‡ªæœ¬æœºå‰ç«¯UIï¼ˆ/xrkï¼‰ä¸‹å‘çš„è½»é‡Cookieï¼Œå…è®¸åŒæºAPIæ— å¯†é’¥è®¿é—®
    try {
      const cookies = String(req.headers.cookie || '');
      const hasUiCookie = /(?:^|;\s*)xrk_ui=1(?:;|$)/.test(cookies);
      const origin = req.headers.origin || '';
      const referer = req.headers.referer || '';
      const host = req.headers.host || '';
      const serverUrl = this.getServerUrl();
      const sameOrigin = (origin && serverUrl && origin.startsWith(serverUrl)) ||
                         (referer && serverUrl && referer.startsWith(serverUrl)) ||
                         (!origin && !referer && !!host);
      if (hasUiCookie && sameOrigin) {
        BotUtil.makeLog("debug", `åŒæºUI Cookie è®¤è¯é€šè¿‡ï¼š${req.method} ${req.originalUrl}`, 'è®¤è¯');
        return next();
      }
    } catch {}

    // å¦‚æœAPIå¯†é’¥è®¤è¯è¢«ç¦ç”¨ï¼Œç›´æ¥é€šè¿‡
    if (authConfig.apiKey?.enabled === false) {
      BotUtil.makeLog("debug", `APIå¯†é’¥è®¤è¯å·²ç¦ç”¨ï¼Œè·³è¿‡è®¤è¯ï¼š${req.path}`, 'è®¤è¯');
      return next();
    }
    
    // APIå¯†é’¥è®¤è¯
    if (!this._checkApiAuthorization(req)) {
      res.status(401).json({
        success: false,
        message: 'Unauthorized',
        error: 'æœªæˆæƒ',
        detail: 'æ— æ•ˆæˆ–ç¼ºå¤±çš„APIå¯†é’¥',
        hint: 'è¯·æä¾› X-API-Key å¤´æˆ– api_key å‚æ•°'
      });
      
      BotUtil.makeLog("warn", `è®¤è¯å¤±è´¥ï¼š${req.method} ${req.originalUrl} æ¥è‡ª ${req.ip}`, 'è®¤è¯');
      return;
    }
    
    BotUtil.makeLog("debug", `è®¤è¯æˆåŠŸï¼š${req.method} ${req.originalUrl}`, 'è®¤è¯');
    next();
  }

  /**
   * æ£€æŸ¥APIæˆæƒ
   */
  _checkApiAuthorization(req) {
    if (!req) return false;
    
    // å¦‚æœæ²¡æœ‰APIå¯†é’¥ï¼ˆè®¤è¯è¢«ç¦ç”¨ï¼‰ï¼Œè¿”å›true
    if (!this.apiKey) {
      return true;
    }
    
    const authKey = req.headers?.["x-api-key"] ??
      req.headers?.["authorization"]?.replace('Bearer ', '') ??
      req.query?.api_key ??
      req.body?.api_key;
    
    if (!authKey) {
      BotUtil.makeLog("debug", `APIè®¤è¯å¤±è´¥ï¼šç¼ºå°‘å¯†é’¥`, 'è®¤è¯');
      return false;
    }
    
    try {
      const authKeyBuffer = Buffer.from(String(authKey));
      const apiKeyBuffer = Buffer.from(String(this.apiKey));
      
      if (authKeyBuffer.length !== apiKeyBuffer.length) {
        BotUtil.makeLog("warn", `æœªæˆæƒè®¿é—®æ¥è‡ª ${req.socket?.remoteAddress || req.ip}`, 'è®¤è¯');
        return false;
      }
      
      return crypto.timingSafeEqual(authKeyBuffer, apiKeyBuffer);
      
    } catch (error) {
      BotUtil.makeLog("error", `APIè®¤è¯é”™è¯¯ï¼š${error.message}`, 'è®¤è¯');
      return false;
    }
  }

  checkApiAuthorization(req) {
    return this._checkApiAuthorization(req);
  }

  /**
   * æ£€æŸ¥æ˜¯å¦ä¸ºæœ¬åœ°è¿æ¥
   */
  _isLocalConnection(address) {
    if (!address || typeof address !== 'string') return false;
    
    const ip = address.toLowerCase().trim()
      .replace(/^::ffff:/, '')
      .replace(/%.+$/, '');
    
    return ip === 'localhost' ||
      ip === '127.0.0.1' ||
      ip === '::1' ||
      this._isPrivateIP(ip);
  }

  /**
   * æ£€æŸ¥æ˜¯å¦ä¸ºç§æœ‰IP
   */
  _isPrivateIP(ip) {
    if (!ip) return false;
    
    const patterns = {
      ipv4: [
        /^10\./,
        /^172\.(1[6-9]|2\d|3[01])\./,
        /^192\.168\./,
        /^127\./
      ],
      ipv6: [
        /^fe80:/i,
        /^fc00:/i,
        /^fd00:/i
      ]
    };
    
    const isIPv4 = ip.includes('.');
    const testPatterns = isIPv4 ? patterns.ipv4 : patterns.ipv6;
    
    return testPatterns.some(pattern => pattern.test(ip));
  }

  /**
   * çŠ¶æ€å¤„ç†å™¨
   */
  _statusHandler(req, res) {
    const status = {
      status: 'è¿è¡Œä¸­',
      uptime: process.uptime(),
      memory: process.memoryUsage(),
      cpu: process.cpuUsage(),
      timestamp: Date.now(),
      version: process.version,
      platform: process.platform,
      server: {
        httpPort: this.httpPort,
        httpsPort: this.httpsPort,
        actualPort: this.actualPort,
        actualHttpsPort: this.actualHttpsPort,
        https: cfg.server?.https?.enabled || false,
        proxy: this.proxyEnabled,
        domains: this.proxyEnabled ? Array.from(this.domainConfigs.keys()) : []
      },
      auth: {
        apiKeyEnabled: cfg.server?.auth?.apiKey?.enabled !== false,
        whitelist: cfg.server?.auth?.whitelist || []
      }
    };
    
    res.type('json').send(JSON.stringify(status, null, 2));
  }

  /**
   * å¥åº·æ£€æŸ¥å¤„ç†å™¨
   */
  _healthHandler(req, res) {
    res.json({
      status: 'å¥åº·',
      uptime: process.uptime(),
      timestamp: Date.now()
    });
  }

  /**
   * æ–‡ä»¶å¤„ç†å™¨
   */
  _fileHandler(req, res) {
    const url = req.url.replace(/^\//, "");
    let file = this.fs[url];
    
    if (!file) {
      file = this.fs[404];
      if (!file) {
        return res.status(404).json({ error: 'æœªæ‰¾åˆ°', file: url });
      }
    }
    
    if (typeof file.times === "number") {
      if (file.times > 0) {
        file.times--;
      } else {
        file = this.fs.timeout;
        if (!file) {
          return res.status(410).json({
            error: 'å·²è¿‡æœŸ',
            message: 'æ–‡ä»¶è®¿é—®æ¬¡æ•°å·²è¾¾ä¸Šé™'
          });
        }
      }
    }
    
    if (file.type?.mime) {
      res.setHeader("Content-Type", file.type.mime);
    }
    res.setHeader("Content-Length", file.buffer.length);
    res.setHeader("Cache-Control", "no-cache");
    
    BotUtil.makeLog("debug", `æ–‡ä»¶å‘é€ï¼š${file.name} (${BotUtil.formatFileSize(file.buffer.length)})`, 'æœåŠ¡å™¨');
    
    res.send(file.buffer);
  }

  /**
   * WebSocketè¿æ¥å¤„ç†
   */
  wsConnect(req, socket, head) {
    req.rid = `${req.socket.remoteAddress}:${req.socket.remotePort}-${req.headers["sec-websocket-key"]}`;
    req.sid = `ws://${req.headers.host || `${req.socket.localAddress}:${req.socket.localPort}`}${req.url}`;
    req.query = Object.fromEntries(new URL(req.sid).searchParams.entries());
    
    // WebSocketè®¤è¯ - ä½¿ç”¨ç›¸åŒçš„ç™½åå•å’Œè®¤è¯é€»è¾‘
    const authConfig = cfg.server?.auth || {};
    const whitelist = authConfig.whitelist || [];
    
    // æ£€æŸ¥WebSocketè·¯å¾„æ˜¯å¦åœ¨ç™½åå•ä¸­
    const path = req.url.split("?")[0]; // å»é™¤æŸ¥è¯¢å‚æ•°
    const isWhitelisted = whitelist.some(whitelistPath => {
      if (whitelistPath === path) return true;
      if (whitelistPath.endsWith('*')) {
        return path.startsWith(whitelistPath.slice(0, -1));
      }
      return false;
    });
    
    // å¦‚æœä¸åœ¨ç™½åå•ä¸”ä¸æ˜¯æœ¬åœ°è¿æ¥ï¼Œåˆ™éœ€è¦è®¤è¯
    if (!isWhitelisted && !this._isLocalConnection(req.socket.remoteAddress)) {
      if (authConfig.apiKey?.enabled !== false && !this._checkApiAuthorization(req)) {
        BotUtil.makeLog("error", `WebSocketè®¤è¯å¤±è´¥ï¼š${req.url}`, 'æœåŠ¡å™¨');
        socket.write("HTTP/1.1 401 Unauthorized\r\n\r\n");
        return socket.destroy();
      }
    }
    
    const wsPath = req.url.split("/")[1];
    if (!(wsPath in this.wsf)) {
      socket.write("HTTP/1.1 404 Not Found\r\n\r\n");
      return socket.destroy();
    }
    
    this.wss.handleUpgrade(req, socket, head, conn => {
      BotUtil.makeLog("debug", `WebSocketè¿æ¥å»ºç«‹ï¼š${req.url}`, 'æœåŠ¡å™¨');
      
      conn.on("error", err => BotUtil.makeLog("error", err, 'æœåŠ¡å™¨'));
      conn.on("close", () => BotUtil.makeLog("debug", `WebSocketæ–­å¼€ï¼š${req.url}`, 'æœåŠ¡å™¨'));
      
      conn.on("message", msg => {
        const logMsg = Buffer.isBuffer(msg) && msg.length > 1024 ?
          `[äºŒè¿›åˆ¶æ¶ˆæ¯ï¼Œé•¿åº¦ï¼š${msg.length}]` : BotUtil.String(msg);
        BotUtil.makeLog("trace", `WSæ¶ˆæ¯ï¼š${logMsg}`, 'æœåŠ¡å™¨');
      });
      
      conn.sendMsg = msg => {
        if (!Buffer.isBuffer(msg)) msg = BotUtil.String(msg);
        BotUtil.makeLog("trace", `WSå‘é€ï¼š${msg}`, 'æœåŠ¡å™¨');
        return conn.send(msg);
      };
      
      for (const handler of this.wsf[wsPath]) {
        handler(conn, req, socket, head);
      }
    });
  }

  /**
   * å¤„ç†ç«¯å£å·²å ç”¨é”™è¯¯
   */
  async serverEADDRINUSE(err, isHttps) {
    const serverType = isHttps ? 'HTTPS' : 'HTTP';
    const port = isHttps ? this.httpsPort : this.httpPort;
    
    BotUtil.makeLog("error", `${serverType}ç«¯å£ ${port} å·²è¢«å ç”¨`, 'æœåŠ¡å™¨');
    
    const retryKey = isHttps ? 'https_retry_count' : 'http_retry_count';
    this[retryKey] = (this[retryKey] || 0) + 1;
    
    await BotUtil.sleep(this[retryKey] * 1000);
    
    const server = isHttps ? this.httpsServer : this.server;
    const host = cfg.server?.server?.host || '0.0.0.0';
    
    if (server) {
      server.listen(port, host);
    }
  }

  /**
   * æœåŠ¡å™¨åŠ è½½å®Œæˆ
   */
  async serverLoad(isHttps) {
    const server = isHttps ? this.httpsServer : this.server;
    const port = isHttps ? this.httpsPort : this.httpPort;
    const host = cfg.server?.server?.host || '0.0.0.0';
    
    if (!server) return;
    
    server.listen(port, host);
    
    await BotUtil.promiseEvent(server, "listening", isHttps && "error").catch(() => { });
    
    const serverInfo = server.address();
    if (!serverInfo) {
      BotUtil.makeLog('error', `${isHttps ? 'HTTPS' : 'HTTP'}æœåŠ¡å™¨å¯åŠ¨å¤±è´¥`, 'æœåŠ¡å™¨');
      return;
    }
    
    if (isHttps) {
      this.httpsPort = serverInfo.port;
    } else {
      this.httpPort = serverInfo.port;
    }
    
    const protocol = isHttps ? 'https' : 'http';
    const serverType = isHttps ? 'HTTPS' : 'HTTP';
    
    BotUtil.makeLog("info", `âœ“ ${serverType}æœåŠ¡å™¨ç›‘å¬åœ¨ ${host}:${serverInfo.port}`, 'æœåŠ¡å™¨');
    
    if (!isHttps && !this.proxyEnabled) {
      await this._displayAccessUrls(protocol, serverInfo.port);
    }
  }

  /**
   * å¯åŠ¨ä»£ç†æœåŠ¡å™¨
   */
  async startProxyServers() {
    const proxyConfig = cfg.server?.proxy;
    if (!proxyConfig?.enabled) return;
    
    const httpPort = proxyConfig.httpPort || 80;
    const host = cfg.server?.server?.host || '0.0.0.0';
    
    // å¯åŠ¨HTTPä»£ç†æœåŠ¡å™¨
    this.proxyServer.listen(httpPort, host);
    await BotUtil.promiseEvent(this.proxyServer, "listening").catch(() => { });
    
    BotUtil.makeLog('info', `âœ“ HTTPä»£ç†æœåŠ¡å™¨ç›‘å¬åœ¨ ${host}:${httpPort}`, 'ä»£ç†');
    
    // å¯åŠ¨HTTPSä»£ç†æœåŠ¡å™¨ï¼ˆå¦‚æœæœ‰ï¼‰
    if (this.proxyHttpsServer) {
      const httpsPort = proxyConfig.httpsPort || 443;
      this.proxyHttpsServer.listen(httpsPort, host);
      await BotUtil.promiseEvent(this.proxyHttpsServer, "listening").catch(() => { });
      
      BotUtil.makeLog('info', `âœ“ HTTPSä»£ç†æœåŠ¡å™¨ç›‘å¬åœ¨ ${host}:${httpsPort}`, 'ä»£ç†');
    }
    
    await this._displayProxyInfo();
  }

  /**
   * æ˜¾ç¤ºä»£ç†ä¿¡æ¯
   */
  async _displayProxyInfo() {
    console.log(chalk.cyan('\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—'));
    console.log(chalk.cyan('â•‘') + chalk.yellow.bold('                  åå‘ä»£ç†æœåŠ¡å™¨é…ç½®ä¿¡æ¯                    ') + chalk.cyan('â•‘'));
    console.log(chalk.cyan('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n'));
    
    console.log(chalk.cyan('â–¶ ä»£ç†åŸŸåï¼š'));
    
    const proxyConfig = cfg.server?.proxy;
    const domains = proxyConfig?.domains || [];
    
    for (const domainConfig of domains) {
      const protocol = domainConfig.ssl?.enabled ? 'https' : 'http';
      const port = protocol === 'https' ? 
        (proxyConfig.httpsPort || 443) : 
        (proxyConfig.httpPort || 80);
      const displayPort = (port === 80 && protocol === 'http') || 
                          (port === 443 && protocol === 'https') ? '' : `:${port}`;
      
      console.log(chalk.yellow(`    ${domainConfig.domain}ï¼š`));
      console.log(`      ${chalk.cyan('â€¢')} è®¿é—®åœ°å€ï¼š${chalk.white(`${protocol}://${domainConfig.domain}${displayPort}`)}`);
      
      if (domainConfig.target) {
        console.log(`      ${chalk.cyan('â€¢')} ä»£ç†ç›®æ ‡ï¼š${chalk.gray(domainConfig.target)}`);
      } else {
        console.log(`      ${chalk.cyan('â€¢')} ä»£ç†ç›®æ ‡ï¼š${chalk.gray(`æœ¬åœ°æœåŠ¡ç«¯å£ ${this.actualPort}`)}`);
      }
      
      if (domainConfig.staticRoot) {
        console.log(`      ${chalk.cyan('â€¢')} é™æ€ç›®å½•ï¼š${chalk.gray(domainConfig.staticRoot)}`);
      }
      
      if (domainConfig.rewritePath) {
        console.log(`      ${chalk.cyan('â€¢')} è·¯å¾„é‡å†™ï¼š${chalk.gray(`${domainConfig.rewritePath.from} â†’ ${domainConfig.rewritePath.to}`)}`);
      }
    }
    
    console.log(chalk.yellow('\nâ–¶ æœ¬åœ°æœåŠ¡ï¼š'));
    console.log(`    ${chalk.cyan('â€¢')} HTTPï¼š${chalk.white(`http://localhost:${this.actualPort}`)}`);
    if (this.actualHttpsPort) {
      console.log(`    ${chalk.cyan('â€¢')} HTTPSï¼š${chalk.white(`https://localhost:${this.actualHttpsPort}`)}`);
    }
    
    const authConfig = cfg.server?.auth || {};
    if (authConfig.apiKey?.enabled !== false) {
      console.log(chalk.yellow('\nâ–¶ APIå¯†é’¥ï¼š'));
      console.log(`    ${chalk.cyan('â€¢')} ${chalk.white(this.apiKey)}`);
      console.log(chalk.gray(`    ä½¿ç”¨ X-API-Key è¯·æ±‚å¤´è¿›è¡Œè®¤è¯`));
    }
    
    if (authConfig.whitelist?.length) {
      console.log(chalk.yellow('\nâ–¶ ç™½åå•è·¯å¾„ï¼š'));
      authConfig.whitelist.forEach(path => {
        console.log(`    ${chalk.cyan('â€¢')} ${chalk.white(path)}`);
      });
      console.log('\n');
    }
  }

  /**
   * æ˜¾ç¤ºè®¿é—®åœ°å€
   */
  async _displayAccessUrls(protocol, port) {
    const addresses = [`${protocol}://localhost:${port}`];
    
    const ipInfo = await this.getLocalIpAddress();
    
    console.log(chalk.cyan('\nâ–¶ è®¿é—®åœ°å€ï¼š'));
    
    if (ipInfo.local.length > 0) {
      console.log(chalk.yellow('  æœ¬åœ°ç½‘ç»œï¼š'));
      ipInfo.local.forEach(info => {
        const url = `${protocol}://${info.ip}:${port}`;
        const label = info.primary ? chalk.green(' â˜…') : '';
        const interfaceInfo = chalk.gray(` [${info.interface}]`);
        console.log(`    ${chalk.cyan('â€¢')} ${chalk.white(url)}${interfaceInfo}${label}`);
        addresses.push(url);
      });
    }
    
    if (ipInfo.public && cfg.server?.misc?.detectPublicIP !== false) {
      console.log(chalk.yellow('\n  å…¬ç½‘è®¿é—®ï¼š'));
      const publicUrl = `${protocol}://${ipInfo.public}:${port}`;
      console.log(`    ${chalk.cyan('â€¢')} ${chalk.white(publicUrl)}`);
    }
    
    if (cfg.server?.server?.url) {
      console.log(chalk.yellow('\n  é…ç½®åŸŸåï¼š'));
      const configUrl = cfg.server.server.url.startsWith('http') ? 
        cfg.server.server.url : 
        `${protocol}://${cfg.server.server.url}`;
      console.log(`    ${chalk.cyan('â€¢')} ${chalk.white(`${configUrl}:${port}`)}`);
    }
    
    const authConfig = cfg.server?.auth || {};
    if (authConfig.apiKey?.enabled !== false) {
      console.log(chalk.yellow('\n  APIå¯†é’¥ï¼š'));
      console.log(`    ${chalk.cyan('â€¢')} ${chalk.white(this.apiKey)}`);
      console.log(chalk.gray(`    ä½¿ç”¨ X-API-Key è¯·æ±‚å¤´`));
    }
    
    if (authConfig.whitelist?.length) {
      console.log(chalk.yellow('\n  ç™½åå•è·¯å¾„ï¼š'));
      authConfig.whitelist.forEach(path => {
        console.log(`    ${chalk.cyan('â€¢')} ${chalk.white(path)}`);
      });
    }
  }

  /**
   * åŠ è½½HTTPSæœåŠ¡å™¨
   */
  async httpsLoad() {
    const httpsConfig = cfg.server?.https;
    
    if (!httpsConfig?.enabled) {
      return;
    }
    
    try {
      let httpsOptions = {};
      
      if (httpsConfig?.certificate) {
        const cert = httpsConfig.certificate;
        
        if (!cert.key || !cert.cert) {
          throw new Error("HTTPSå·²å¯ç”¨ä½†æœªé…ç½®è¯ä¹¦");
        }
        
        if (!fsSync.existsSync(cert.key)) {
          throw new Error(`HTTPSå¯†é’¥æ–‡ä»¶ä¸å­˜åœ¨ï¼š${cert.key}`);
        }
        
        if (!fsSync.existsSync(cert.cert)) {
          throw new Error(`HTTPSè¯ä¹¦æ–‡ä»¶ä¸å­˜åœ¨ï¼š${cert.cert}`);
        }
        
        httpsOptions = {
          key: await fs.readFile(cert.key),
          cert: await fs.readFile(cert.cert)
        };
        
        if (cert.ca && fsSync.existsSync(cert.ca)) {
          httpsOptions.ca = await fs.readFile(cert.ca);
        }
      }
      
      if (httpsConfig?.tls?.minVersion) {
        httpsOptions.minVersion = httpsConfig.tls.minVersion;
      }
      
      this.httpsServer = https.createServer(httpsOptions, this.express)
        .on("error", err => this._handleServerError(err, true))
        .on("upgrade", this.wsConnect.bind(this));
      
      await this.serverLoad(true);
      
      BotUtil.makeLog("info", "âœ“ HTTPSæœåŠ¡å™¨å·²å¯åŠ¨", 'æœåŠ¡å™¨');
      
    } catch (err) {
      BotUtil.makeLog("error", `HTTPSæœåŠ¡å™¨é”™è¯¯ï¼š${err.message}`, 'æœåŠ¡å™¨');
    }
  }

  /**
   * è®¾ç½®æœ€ç»ˆå¤„ç†å™¨
   */
  _setupFinalHandlers() {
    // 404å¤„ç†
    this.express.use((req, res) => {
      let defaultRoute = cfg.server?.misc?.defaultRoute || '/';
      
      if (req.domainConfig?.defaultRoute) {
        defaultRoute = req.domainConfig.defaultRoute;
      }
      
      if (req.accepts('html')) {
        const staticRoot = req.staticRoot || path.join(process.cwd(), 'www');
        const custom404Path = path.join(staticRoot, '404.html');
        
        if (fsSync.existsSync(custom404Path)) {
          res.status(404).sendFile(custom404Path);
        } else {
          res.redirect(defaultRoute);
        }
      } else {
        res.status(404).json({
          error: 'æœªæ‰¾åˆ°',
          path: req.path,
          timestamp: Date.now()
        });
      }
    });
    
    // é”™è¯¯å¤„ç†
    this.express.use((err, req, res, next) => {
      BotUtil.makeLog('error', `è¯·æ±‚é”™è¯¯ï¼š${err.message}`, 'æœåŠ¡å™¨');
      
      res.status(err.status || 500).json({
        error: 'å†…éƒ¨æœåŠ¡å™¨é”™è¯¯',
        message: process.env.NODE_ENV === 'production' ?
          'å‘ç”Ÿäº†ä¸€ä¸ªé”™è¯¯' : err.message,
        timestamp: Date.now()
      });
    });
  }

  /**
   * å…³é—­æœåŠ¡å™¨
   */
  async closeServer() {
    BotUtil.makeLog('info', 'â³ æ­£åœ¨å…³é—­æœåŠ¡å™¨...', 'æœåŠ¡å™¨');
    
    const servers = [
      this.server,
      this.httpsServer,
      this.proxyServer,
      this.proxyHttpsServer
    ].filter(Boolean);
    
    await Promise.all(servers.map(server =>
      new Promise(resolve => server.close(resolve))
    ));
    
    await BotUtil.sleep(2000);
    await this.redisExit();
    
    BotUtil.makeLog('info', 'âœ“ æœåŠ¡å™¨å·²å…³é—­', 'æœåŠ¡å™¨');
  }

  /**
   * è·å–æœåŠ¡å™¨URL
   */
  getServerUrl() {
    if (this.proxyEnabled && cfg.server?.proxy?.domains?.[0]) {
      const domain = cfg.server.proxy.domains[0];
      const protocol = domain.ssl?.enabled ? 'https' : 'http';
      return `${protocol}://${domain.domain}`;
    }
    
    const protocol = cfg.server?.https?.enabled ? 'https' : 'http';
    const port = protocol === 'https' ? this.actualHttpsPort : this.actualPort;
    const host = cfg.server?.server?.url || 'localhost';
    
    const needPort = (protocol === 'http' && port !== 80) ||
                     (protocol === 'https' && port !== 443);
    
    return `${protocol}://${host}${needPort ? ':' + port : ''}`;
  }

  /**
   * è·å–æœ¬åœ°IPåœ°å€
   */
  async getLocalIpAddress() {
    const cacheKey = 'local_ip_addresses';
    const cached = this._cache.get(cacheKey);
    if (cached) return cached;
    
    const result = {
      local: [],
      public: null,
      primary: null
    };
    
    try {
      const interfaces = os.networkInterfaces();
      
      for (const [name, ifaces] of Object.entries(interfaces)) {
        if (name.toLowerCase().includes('lo')) continue;
        
        for (const iface of ifaces) {
          if (iface.family !== 'IPv4' || iface.internal) continue;
          
          result.local.push({
            ip: iface.address,
            interface: name,
            mac: iface.mac,
            virtual: this._isVirtualInterface(name, iface.mac)
          });
        }
      }
      
      try {
        result.primary = await this._getIpByUdp();
        const existingItem = result.local.find(item => item.ip === result.primary);
        if (existingItem) {
          existingItem.primary = true;
        }
      } catch { }
      
      if (cfg.server?.misc?.detectPublicIP !== false) {
        result.public = await this._getPublicIP();
      }
      
      this._cache.set(cacheKey, result);
      return result;
      
    } catch (err) {
      BotUtil.makeLog("debug", `è·å–IPåœ°å€å¤±è´¥ï¼š${err.message}`, 'æœåŠ¡å™¨');
      return result;
    }
  }

  /**
   * æ£€æŸ¥æ˜¯å¦ä¸ºè™šæ‹Ÿç½‘å¡
   */
  _isVirtualInterface(name, mac) {
    const virtualPatterns = [
      /^(docker|br-|veth|virbr|vnet)/i,
      /^(vmnet|vmware)/i,
      /^(vboxnet|virtualbox)/i
    ];
    
    return virtualPatterns.some(p => p.test(name));
  }

  /**
   * é€šè¿‡UDPè·å–IP
   */
  async _getIpByUdp() {
    return new Promise((resolve, reject) => {
      const socket = dgram.createSocket('udp4');
      const timeout = setTimeout(() => {
        socket.close();
        reject(new Error('UDPè¶…æ—¶'));
      }, 3000);
      
      try {
        socket.connect(80, '223.5.5.5', () => {
          clearTimeout(timeout);
          const address = socket.address();
          socket.close();
          resolve(address.address);
        });
      } catch (err) {
        clearTimeout(timeout);
        socket.close();
        reject(err);
      }
    });
  }

  /**
   * è·å–å…¬ç½‘IP
   */
  async _getPublicIP() {
    const apis = [
      { url: 'https://api.ipify.org?format=json', field: 'ip' },
      { url: 'https://api.myip.la/json', field: 'ip' }
    ];
    
    for (const api of apis) {
      try {
        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), 3000);
        
        const response = await fetch(api.url, {
          signal: controller.signal,
          headers: { 'User-Agent': 'Mozilla/5.0' }
        });
        
        clearTimeout(timeout);
        
        if (response.ok) {
          const data = await response.json();
          const ip = data[api.field];
          if (ip && this._isValidIP(ip)) return ip;
        }
      } catch {
        continue;
      }
    }
    
    return null;
  }

  /**
   * éªŒè¯IPåœ°å€æ ¼å¼
   */
  _isValidIP(ip) {
    if (!ip) return false;
    
    const ipv4Regex = /^((25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(25[0-5]|2[0-4]\d|[01]?\d\d?)$/;
    return ipv4Regex.test(ip);
  }

  /**
   * ä¸»è¿è¡Œå‡½æ•°
   */
  async run(options = {}) {
    const { port } = options;
    
    const proxyConfig = cfg.server?.proxy;
    this.proxyEnabled = proxyConfig?.enabled === true;
    
    // è®¾ç½®ç«¯å£
    this.actualPort = port || 2537;
    this.actualHttpsPort = this.actualPort + 1;
    
    if (this.proxyEnabled) {
      this.httpPort = proxyConfig.httpPort || 80;
      this.httpsPort = proxyConfig.httpsPort || 443;
    } else {
      this.httpPort = this.actualPort;
      this.httpsPort = this.actualHttpsPort;
    }
    
    console.log(chalk.cyan('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—'));
    console.log(chalk.cyan('â•‘') + chalk.yellow.bold('               è‘µå­æ­£åœ¨åˆå§‹åŒ–httpæœåŠ¡å™¨...                  ') + chalk.cyan('â•‘'));
    console.log(chalk.cyan('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'));
    
    if (this.proxyEnabled) {
      BotUtil.makeLog('info', 'âš¡ åå‘ä»£ç†æ¨¡å¼å·²å¯ç”¨', 'æœåŠ¡å™¨');
      BotUtil.makeLog('info', `æœåŠ¡ç«¯å£ï¼š${this.actualPort} (HTTP), ${this.actualHttpsPort} (HTTPS)`, 'æœåŠ¡å™¨');
      BotUtil.makeLog('info', `ä»£ç†ç«¯å£ï¼š${this.httpPort} (HTTP), ${this.httpsPort} (HTTPS)`, 'æœåŠ¡å™¨');
      
      await this._initProxyApp();
    } else {
      BotUtil.makeLog('info', `ç«¯å£ï¼š${this.httpPort} (HTTP), ${this.httpsPort} (HTTPS)`, 'æœåŠ¡å™¨');
    }
    
    await Packageloader();
    await this.generateApiKey();
    
    // åŠ è½½å·¥ä½œæµ
    await StreamLoader.load();
    await PluginsLoader.load();
    await ApiLoader.load();
    const ConfigLoader = (await import('./commonconfig/loader.js')).default;
    await ConfigLoader.load();
    global.ConfigManager = ConfigLoader;
    // ç¡®ä¿ cfg åœ¨ global ä¸­å¯ç”¨ï¼Œä¾› ConfigBase ä½¿ç”¨
    if (!global.cfg && typeof cfg !== 'undefined') {
      global.cfg = cfg;
    }
    this._initializeMiddlewareAndRoutes();
    
    await ApiLoader.register(this.express, this);
    
    this._setupFinalHandlers();
    
    // å¯åŠ¨ä¸»æœåŠ¡
    const originalHttpPort = this.httpPort;
    const originalHttpsPort = this.httpsPort;
    
    if (this.proxyEnabled) {
      this.httpPort = this.actualPort;
      this.httpsPort = this.actualHttpsPort;
    }
    
    await this.serverLoad(false);
    
    if (cfg.server?.https?.enabled) {
      await this.httpsLoad();
    }
    
    // å¯åŠ¨ä»£ç†æœåŠ¡å™¨
    if (this.proxyEnabled) {
      this.httpPort = originalHttpPort;
      this.httpsPort = originalHttpsPort;
      await this.startProxyServers();
    }
    
    await ListenerLoader.load();
    await ApiLoader.watch(true);
    
    if (Object.keys(this.wsf).length > 0) {
      BotUtil.makeLog("info", `âš¡ WebSocketæœåŠ¡ï¼š${this.getServerUrl().replace(/^http/, "ws")}/ [${Object.keys(this.wsf).join(', ')}]`, 'æœåŠ¡å™¨');
    }
    
    this.emit("online", {
      bot: this,
      timestamp: Date.now(),
      url: this.getServerUrl(),
      uptime: process.uptime(),
      apis: ApiLoader.getApiList(),
      proxyEnabled: this.proxyEnabled
    });
  }

  prepareEvent(data) {
    if (!this.bots[data.self_id]) return;
    
    if (!data.bot) {
      Object.defineProperty(data, "bot", {
        value: this.bots[data.self_id]
      });
    }
    
    if (data.user_id) {
      if (!data.friend) {
        Object.defineProperty(data, "friend", {
          value: data.bot.pickFriend(data.user_id)
        });
      }
      data.sender ||= { user_id: data.user_id };
      data.sender.nickname ||= data.friend?.nickname;
    }
    
    if (data.group_id) {
      if (!data.group) {
        Object.defineProperty(data, "group", {
          value: data.bot.pickGroup(data.group_id)
        });
      }
      data.group_name ||= data.group?.name;
    }
    
    if (data.group && data.user_id) {
      if (!data.member) {
        Object.defineProperty(data, "member", {
          value: data.group.pickMember(data.user_id)
        });
      }
      data.sender.nickname ||= data.member?.nickname;
      data.sender.card ||= data.member?.card;
    }
    
    if (data.bot.adapter?.id) data.adapter_id = data.bot.adapter.id;
    if (data.bot.adapter?.name) data.adapter_name = data.bot.adapter.name;
    
    this._extendEventMethods(data);
  }

  _extendEventMethods(data) {
    for (const target of [data.friend, data.group, data.member]) {
      if (!target || typeof target !== "object") continue;
      
      target.sendFile ??= (file, name) =>
        target.sendMsg(segment.file(file, name));
      target.makeForwardMsg ??= this.makeForwardMsg;
      target.sendForwardMsg ??= msg =>
        this.sendForwardMsg(msg => target.sendMsg(msg), msg);
      target.getInfo ??= () => target.info || target;
    }
    
    if (!data.reply) {
      data.reply = data.group?.sendMsg?.bind(data.group) ||
        data.friend?.sendMsg?.bind(data.friend);
    }
  }

  em(name = "", data = {}) {
    this.prepareEvent(data);
    
    while (name) {
      this.emit(name, data);
      const lastDot = name.lastIndexOf(".");
      if (lastDot === -1) break;
      name = name.slice(0, lastDot);
    }
  }

  getFriendArray() {
    const array = []
    for (const bot_id of this.uin)
      for (const [id, i] of this.bots[bot_id].fl || []) array.push({ ...i, bot_id })
    return array
  }

  getFriendList() {
    const array = []
    for (const bot_id of this.uin) array.push(...(this.bots[bot_id].fl?.keys() || []))
    return array
  }

  getFriendMap() {
    const map = new Map()
    for (const bot_id of this.uin)
      for (const [id, i] of this.bots[bot_id].fl || []) map.set(id, { ...i, bot_id })
    return map
  }
  
  get fl() {
    return this.getFriendMap()
  }

  getGroupArray() {
    const array = []
    for (const bot_id of this.uin)
      for (const [id, i] of this.bots[bot_id].gl || []) array.push({ ...i, bot_id })
    return array
  }

  getGroupList() {
    const array = []
    for (const bot_id of this.uin) array.push(...(this.bots[bot_id].gl?.keys() || []))
    return array
  }

  getGroupMap() {
    const map = new Map()
    for (const bot_id of this.uin)
      for (const [id, i] of this.bots[bot_id].gl || []) map.set(id, { ...i, bot_id })
    return map
  }
  
  get gl() {
    return this.getGroupMap()
  }
  
  get gml() {
    const map = new Map()
    for (const bot_id of this.uin)
      for (const [id, i] of this.bots[bot_id].gml || [])
        map.set(id, Object.assign(new Map(i), { bot_id }))
    return map
  }

  pickFriend(user_id, strict) {
    user_id = Number(user_id) || user_id;
    
    const mainBot = this.bots[this.uin];
    if (mainBot?.fl?.has(user_id)) {
      return mainBot.pickFriend(user_id);
    }
    
    const friend = this.fl.get(user_id);
    if (friend) {
      return this.bots[friend.bot_id].pickFriend(user_id);
    }
    
    if (strict) return false;
    
    BotUtil.makeLog("trace", `ç”¨æˆ· ${user_id} ä¸å­˜åœ¨ï¼Œä½¿ç”¨éšæœºBot ${this.uin.toJSON()}`, 'æœåŠ¡å™¨');
    return this.bots[this.uin].pickFriend(user_id);
  }

  get pickUser() {
    return this.pickFriend;
  }

  pickGroup(group_id, strict) {
    group_id = Number(group_id) || group_id;
    
    const mainBot = this.bots[this.uin];
    if (mainBot?.gl?.has(group_id)) {
      return mainBot.pickGroup(group_id);
    }
    
    const group = this.gl.get(group_id);
    if (group) {
      return this.bots[group.bot_id].pickGroup(group_id);
    }
    
    if (strict) return false;
    
    BotUtil.makeLog("trace", `ç¾¤ç»„ ${group_id} ä¸å­˜åœ¨ï¼Œä½¿ç”¨éšæœºBot ${this.uin.toJSON()}`, 'æœåŠ¡å™¨');
    return this.bots[this.uin].pickGroup(group_id);
  }

  pickMember(group_id, user_id) {
    return this.pickGroup(group_id).pickMember(user_id);
  }

  async sendFriendMsg(bot_id, user_id, ...args) {
    if (!bot_id) {
      return this.pickFriend(user_id).sendMsg(...args);
    }
    
    if (this.uin.includes(bot_id) && this.bots[bot_id]) {
      return this.bots[bot_id].pickFriend(user_id).sendMsg(...args);
    }
    
    return new Promise((resolve, reject) => {
      const listener = data => {
        resolve(data.bot.pickFriend(user_id).sendMsg(...args));
        clearTimeout(timeout);
      };
      
      const timeout = setTimeout(() => {
        reject(Object.assign(Error("ç­‰å¾…Botä¸Šçº¿è¶…æ—¶"),
          { bot_id, user_id, args }));
        this.off(`connect.${bot_id}`, listener);
      }, 300000);
      
      this.once(`connect.${bot_id}`, listener);
    });
  }

  async sendGroupMsg(bot_id, group_id, ...args) {
    if (!bot_id) {
      return this.pickGroup(group_id).sendMsg(...args);
    }
    
    if (this.uin.includes(bot_id) && this.bots[bot_id]) {
      return this.bots[bot_id].pickGroup(group_id).sendMsg(...args);
    }
    
    return new Promise((resolve, reject) => {
      const listener = data => {
        resolve(data.bot.pickGroup(group_id).sendMsg(...args));
        clearTimeout(timeout);
      };
      
      const timeout = setTimeout(() => {
        reject(Object.assign(Error("ç­‰å¾…Botä¸Šçº¿è¶…æ—¶"),
          { bot_id, group_id, args }));
        this.off(`connect.${bot_id}`, listener);
      }, 300000);
      
      this.once(`connect.${bot_id}`, listener);
    });
  }

  async sendMasterMsg(msg, sleep = 5000) {
    const masterQQs = cfg.masterQQ;
    if (!masterQQs?.length) {
      throw new Error("æœªé…ç½®ä¸»äººQQ");
    }
    
    const results = {};
    
    for (let i = 0; i < masterQQs.length; i++) {
      const user_id = masterQQs[i];
      
      try {
        const friend = this.pickFriend(user_id);
        if (friend?.sendMsg) {
          results[user_id] = await friend.sendMsg(msg);
          BotUtil.makeLog("debug", `å·²å‘é€æ¶ˆæ¯ç»™ä¸»äºº ${user_id}`, 'æœåŠ¡å™¨');
        } else {
          results[user_id] = { error: "æ²¡æœ‰å¯ç”¨çš„Bot" };
          BotUtil.makeLog("warn", `æ— æ³•å‘ä¸»äºº ${user_id} å‘é€æ¶ˆæ¯`, 'æœåŠ¡å™¨');
        }
        
        if (sleep && i < masterQQs.length - 1) {
          await BotUtil.sleep(sleep);
        }
      } catch (err) {
        results[user_id] = { error: err.message };
        BotUtil.makeLog("error", `å‘ä¸»äºº ${user_id} å‘é€æ¶ˆæ¯å¤±è´¥ï¼š${err.message}`, 'æœåŠ¡å™¨');
      }
    }
    
    return results;
  }

  makeForwardMsg(msg) {
    return { type: "node", data: msg };
  }
  
  makeForwardArray(msg = [], node = {}) {
    return this.makeForwardMsg((Array.isArray(msg) ? msg : [msg]).map(message => ({ ...node, message })));
  }

  async sendForwardMsg(send, msg) {
    const messages = Array.isArray(msg) ? msg : [msg];
    return Promise.all(messages.map(({ message }) => send(message)));
  }

  async redisExit() {
    if (!(typeof redis === 'object' && redis.process)) return false;
    
    const process = redis.process;
    delete redis.process;
    
    await BotUtil.sleep(5000, redis.save().catch(() => { }));
    return process.kill();
  }

  async fileToUrl(file, opts = {}) {
    return await BotUtil.fileToUrl(file, opts);
  }
}
```


--------------------------------------------------------------------------------
## æ–‡ä»¶: ./plugins/api/device.js
--------------------------------------------------------------------------------

```javascript
import WebSocket from 'ws';
import BotUtil from '../../lib/common/util.js';
import StreamLoader from '../../lib/aistream/loader.js';
import fs from 'fs';
import path from 'path';

// ==================== å¯¼å…¥é…ç½® ====================
import {
    AI_CONFIG,
    VOLCENGINE_TTS_CONFIG,
    VOLCENGINE_ASR_CONFIG,
    SYSTEM_CONFIG,
    EMOTION_KEYWORDS,
    SUPPORTED_EMOTIONS
} from '../../components/config/deviceConfig.js';

// ==================== å¯¼å…¥å·¥å…·å‡½æ•° ====================
import {
    initializeDirectories,
    validateDeviceRegistration,
    generateCommandId,
    hasCapability,
    getAudioFileList
} from '../../components/util/deviceUtil.js';

// ==================== å¯¼å…¥ASRå’ŒTTSå·¥å‚ ====================
import ASRFactory from '../../components/asr/ASRFactory.js';
import TTSFactory from '../../components/tts/TTSFactory.js';

// ==================== å…¨å±€å­˜å‚¨ ====================
const devices = new Map();
const deviceWebSockets = new Map();
const deviceLogs = new Map();
const deviceCommands = new Map();
const commandCallbacks = new Map();
const deviceStats = new Map();
const asrClients = new Map();
const ttsClients = new Map();
const asrSessions = new Map();

// ==================== è®¾å¤‡ç®¡ç†å™¨ç±» ====================
class DeviceManager {
    constructor() {
        this.cleanupInterval = null;
        this.AUDIO_SAVE_DIR = SYSTEM_CONFIG.audioSaveDir;
        this.initializeDirectories();
    }

    /**
     * åˆå§‹åŒ–ç›®å½•
     */
    initializeDirectories() {
        initializeDirectories([this.AUDIO_SAVE_DIR]);
    }

    /**
     * è·å–ASRå®¢æˆ·ç«¯ï¼ˆæ‡’åŠ è½½ï¼‰
     * @param {string} deviceId - è®¾å¤‡ID
     * @returns {Object} ASRå®¢æˆ·ç«¯
     * @private
     */
    _getASRClient(deviceId) {
        let client = asrClients.get(deviceId);
        if (!client) {
            client = ASRFactory.createClient(deviceId, VOLCENGINE_ASR_CONFIG, Bot);
            asrClients.set(deviceId, client);
        }
        return client;
    }

    /**
     * è·å–TTSå®¢æˆ·ç«¯ï¼ˆæ‡’åŠ è½½ï¼‰
     * @param {string} deviceId - è®¾å¤‡ID
     * @returns {Object} TTSå®¢æˆ·ç«¯
     * @private
     */
    _getTTSClient(deviceId) {
        let client = ttsClients.get(deviceId);
        if (!client) {
            client = TTSFactory.createClient(deviceId, VOLCENGINE_TTS_CONFIG, Bot);
            ttsClients.set(deviceId, client);
        }
        return client;
    }

    // ==================== ASRä¼šè¯å¤„ç† ====================

    /**
     * å¤„ç†ASRä¼šè¯å¼€å§‹
     * @param {string} deviceId - è®¾å¤‡ID
     * @param {Object} data - ä¼šè¯æ•°æ®
     * @returns {Promise<Object>} å¤„ç†ç»“æœ
     */
    async handleASRSessionStart(deviceId, data) {
        try {
            const { session_id, sample_rate, bits, channels, session_number } = data;

            BotUtil.makeLog('info',
                `âš¡ [ASRä¼šè¯#${session_number}] å¼€å§‹: ${session_id}`,
                deviceId
            );

            if (!VOLCENGINE_ASR_CONFIG.enabled) {
                return { success: false, error: 'ASRæœªå¯ç”¨' };
            }

            asrSessions.set(session_id, {
                deviceId,
                sample_rate,
                bits,
                channels,
                sessionNumber: session_number,
                startTime: Date.now(),
                lastChunkTime: Date.now(),
                totalChunks: 0,
                totalBytes: 0,
                audioBuffers: [],
                asrStarted: false,
                endingChunks: 0,
                earlyEndSent: false,
                finalText: null,
                finalDuration: 0,
                finalTextSetAt: null
            });

            const client = this._getASRClient(deviceId);
            try {
                await client.beginUtterance(session_id, {
                    sample_rate,
                    bits,
                    channels
                });
                asrSessions.get(session_id).asrStarted = true;
            } catch (e) {
                BotUtil.makeLog('error',
                    `âŒ [ASR] å¯åŠ¨utteranceå¤±è´¥: ${e.message}`,
                    deviceId
                );
                return { success: false, error: e.message };
            }

            return { success: true, session_id };

        } catch (e) {
            BotUtil.makeLog('error',
                `âŒ [ASRä¼šè¯] å¯åŠ¨å¤±è´¥: ${e.message}`,
                deviceId
            );
            return { success: false, error: e.message };
        }
    }

    /**
     * å¤„ç†ASRéŸ³é¢‘å—
     * @param {string} deviceId - è®¾å¤‡ID
     * @param {Object} data - éŸ³é¢‘æ•°æ®
     * @returns {Promise<Object>} å¤„ç†ç»“æœ
     */
    async handleASRAudioChunk(deviceId, data) {
        try {
            const { session_id, chunk_index, data: audioHex, vad_state } = data;

            const session = asrSessions.get(session_id);
            if (!session) {
                return { success: false, error: 'ä¼šè¯ä¸å­˜åœ¨' };
            }

            const audioBuf = Buffer.from(audioHex, 'hex');

            session.totalChunks++;
            session.totalBytes += audioBuf.length;
            session.lastChunkTime = Date.now();
            session.audioBuffers.push(audioBuf);

            if (session.asrStarted && (vad_state === 'active' || vad_state === 'ending')) {
                const client = this._getASRClient(deviceId);
                if (client.connected && client.currentUtterance && !client.currentUtterance.ending) {
                    client.sendAudio(audioBuf);

                    if (vad_state === 'ending') {
                        session.endingChunks = (session.endingChunks || 0) + 1;

                        if (session.endingChunks >= 2 && !session.earlyEndSent) {
                            session.earlyEndSent = true;

                            BotUtil.makeLog('info',
                                `âš¡ [ASR] æ£€æµ‹åˆ°endingÃ—${session.endingChunks}ï¼Œæå‰ç»“æŸ`,
                                deviceId
                            );

                            setTimeout(async () => {
                                try {
                                    await client.endUtterance();
                                } catch (e) {
                                    BotUtil.makeLog('error',
                                        `âŒ [ASR] æå‰ç»“æŸå¤±è´¥: ${e.message}`,
                                        deviceId
                                    );
                                }
                            }, 50);
                        }
                    } else {
                        session.endingChunks = 0;
                        session.earlyEndSent = false;
                    }
                }
            }

            return { success: true, received: chunk_index };

        } catch (e) {
            BotUtil.makeLog('error',
                `âŒ [ASR] å¤„ç†éŸ³é¢‘å—å¤±è´¥: ${e.message}`,
                deviceId
            );
            return { success: false, error: e.message };
        }
    }

    /**
     * å¤„ç†ASRä¼šè¯åœæ­¢
     * @param {string} deviceId - è®¾å¤‡ID
     * @param {Object} data - ä¼šè¯æ•°æ®
     * @returns {Promise<Object>} å¤„ç†ç»“æœ
     */
    async handleASRSessionStop(deviceId, data) {
        try {
            const { session_id, duration, session_number } = data;

            BotUtil.makeLog('info',
                `âœ“ [ASRä¼šè¯#${session_number}] åœæ­¢: ${session_id} (æ—¶é•¿=${duration}s)`,
                deviceId
            );

            const session = asrSessions.get(session_id);
            if (!session) {
                return { success: true };
            }

            // é¿å…é‡å¤å¤„ç†åŒä¸€ä¼šè¯åœæ­¢
            if (session.stopped) {
                return { success: true };
            }
            session.stopped = true;

            if (session.asrStarted) {
                const client = this._getASRClient(deviceId);

                if (!session.earlyEndSent) {
                    try {
                        await client.endUtterance();
                        BotUtil.makeLog('info',
                            `âœ“ [ASRä¼šè¯#${session_number}] Utteranceå·²ç»“æŸ`,
                            deviceId
                        );
                    } catch (e) {
                        BotUtil.makeLog('warn',
                            `âš ï¸ [ASR] ç»“æŸutteranceå¤±è´¥: ${e.message}`,
                            deviceId
                        );
                    }
                }
            }

            const maxWaitMs = VOLCENGINE_ASR_CONFIG.asrFinalTextWaitMs;
            const checkIntervalMs = 50;
            let waitCount = 0;
            const maxChecks = Math.ceil(maxWaitMs / checkIntervalMs);

            BotUtil.makeLog('info', `â³ [ASR] ç­‰å¾…æœ€ç»ˆç»“æœ...`, deviceId);

            while (!session.finalText && waitCount < maxChecks) {
                await new Promise(r => setTimeout(r, checkIntervalMs));
                waitCount++;
            }

            if (session.finalText) {
                session.waitCompleted = true;
                const waitedMs = waitCount * checkIntervalMs;
                BotUtil.makeLog('info',
                    `âœ… [ASRæœ€ç»ˆ] "${session.finalText}" (ç­‰å¾…${waitedMs}ms)`,
                    deviceId
                );

                // å°†æœ€ç»ˆè¯†åˆ«ç»“æœæ¨é€ç»™å‰ç«¯è®¾å¤‡ï¼ˆwebclientï¼‰ç”¨äºUIå±•ç¤º
                try {
                    const ws = deviceWebSockets.get(deviceId);
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({
                            type: 'asr_final',
                            device_id: deviceId,
                            session_id,
                            text: session.finalText
                        }));
                    }
                } catch {}
            } else {
                if (!session.waitCompleted) {
                    BotUtil.makeLog('warn',
                        `âš ï¸ [ASR] ç­‰å¾…æœ€ç»ˆç»“æœè¶…æ—¶(${maxWaitMs}ms)`,
                        deviceId
                    );
                }
            }

            const finalText = session.finalText;

            if (AI_CONFIG.enabled && finalText && finalText.trim()) {
                await this._processAIResponse(deviceId, finalText);
            } else if (AI_CONFIG.enabled && !finalText) {
                BotUtil.makeLog('warn',
                    'âš ï¸ [AI] æœªè·å–åˆ°ASRæœ€ç»ˆæ–‡æœ¬ï¼Œè·³è¿‡AIå¤„ç†',
                    deviceId
                );
            }

            asrSessions.delete(session_id);
            return { success: true };

        } catch (e) {
            BotUtil.makeLog('error',
                `âŒ [ASRä¼šè¯] åœæ­¢å¤±è´¥: ${e.message}`,
                deviceId
            );
            return { success: false, error: e.message };
        }
    }

    // ==================== AIå¤„ç† ====================

    /**
     * å¤„ç†AIå“åº”
     * @param {string} deviceId - è®¾å¤‡ID
     * @param {string} question - ç”¨æˆ·é—®é¢˜
     * @returns {Promise<void>}
     * @private
     */
    async _processAIResponse(deviceId, question) {
        try {
            const startTime = Date.now();

            BotUtil.makeLog('info',
                `âš¡ [AI] å¼€å§‹å¤„ç†: ${question.substring(0, 50)}${question.length > 50 ? '...' : ''}`,
                deviceId
            );

            const deviceStream = StreamLoader.getStream('device');

            if (!deviceStream) {
                BotUtil.makeLog('error', 'âŒ [AI] è®¾å¤‡å·¥ä½œæµæœªåŠ è½½', deviceId);
                return;
            }

            const deviceInfo = devices.get(deviceId);
            const deviceBot = Bot[deviceId];

            if (!deviceBot) {
                BotUtil.makeLog('error', 'âŒ [AI] è®¾å¤‡Botæœªæ‰¾åˆ°', deviceId);
                return;
            }

            const aiResult = await deviceStream.execute(
                deviceId,
                question,
                AI_CONFIG,
                deviceInfo || {},
                AI_CONFIG.persona
            );

            if (!aiResult) {
                BotUtil.makeLog('warn', 'âš ï¸ [AI] å·¥ä½œæµè¿”å›ç©ºç»“æœ', deviceId);
                return;
            }

            const aiTime = Date.now() - startTime;
            BotUtil.makeLog('info',
                `âš¡ [AIæ€§èƒ½] å¤„ç†è€—æ—¶: ${aiTime}ms`,
                deviceId
            );

            BotUtil.makeLog('info',
                `âœ… [AI] å›å¤: ${aiResult.text || '(ä»…è¡¨æƒ…)'}`,
                deviceId
            );

            if (aiResult.emotion) {
                try {
                    // å°†å·¥ä½œæµè§£æå‡ºçš„ä¸­æ–‡è¡¨æƒ…æ˜ å°„ä¸ºè®¾å¤‡æ”¯æŒçš„è‹±æ–‡è¡¨æƒ…ä»£ç 
                    let emotionCode = EMOTION_KEYWORDS[aiResult.emotion] || aiResult.emotion;
                    if (!SUPPORTED_EMOTIONS.includes(emotionCode)) {
                        throw new Error(`æœªçŸ¥è¡¨æƒ…: ${aiResult.emotion}`);
                    }
                    await deviceBot.emotion(emotionCode);
                    BotUtil.makeLog('info',
                        `âœ“ [è®¾å¤‡] è¡¨æƒ…: ${emotionCode}`,
                        deviceId
                    );
                } catch (e) {
                    BotUtil.makeLog('error',
                        `âŒ [è®¾å¤‡] è¡¨æƒ…æ˜¾ç¤ºå¤±è´¥: ${e.message}`,
                        deviceId
                    );
                }
                await new Promise(r => setTimeout(r, 500));
            }

            if (aiResult.text && VOLCENGINE_TTS_CONFIG.enabled) {
                try {
                    const ttsClient = this._getTTSClient(deviceId);
                    const success = await ttsClient.synthesize(aiResult.text);

                    if (success) {
                        BotUtil.makeLog('info',
                            `ğŸ”Š [TTS] è¯­éŸ³åˆæˆå·²å¯åŠ¨`,
                            deviceId
                        );
                    } else {
                        BotUtil.makeLog('error',
                            `âŒ [TTS] è¯­éŸ³åˆæˆå¤±è´¥`,
                            deviceId
                        );
                    }
                } catch (e) {
                    BotUtil.makeLog('error',
                        `âŒ [TTS] è¯­éŸ³åˆæˆå¼‚å¸¸: ${e.message}`,
                        deviceId
                    );
                }
            }

            if (aiResult.text) {
                try {
                    await deviceBot.display(aiResult.text, {
                        x: 0,
                        y: 0,
                        font_size: 16,
                        wrap: true,
                        spacing: 2
                    });
                    BotUtil.makeLog('info',
                        `âœ“ [è®¾å¤‡] æ–‡å­—: ${aiResult.text}`,
                        deviceId
                    );
                } catch (e) {
                    BotUtil.makeLog('error',
                        `âŒ [è®¾å¤‡] æ–‡å­—æ˜¾ç¤ºå¤±è´¥: ${e.message}`,
                        deviceId
                    );
                }
            }

        } catch (e) {
            BotUtil.makeLog('error',
                `âŒ [AI] å¤„ç†å¤±è´¥: ${e.message}`,
                deviceId
            );
        }
    }

    // ==================== è®¾å¤‡ç®¡ç† ====================

    /**
     * åˆå§‹åŒ–è®¾å¤‡ç»Ÿè®¡
     * @param {string} deviceId - è®¾å¤‡ID
     * @returns {Object} ç»Ÿè®¡å¯¹è±¡
     */
    initDeviceStats(deviceId) {
        const stats = {
            device_id: deviceId,
            connected_at: Date.now(),
            total_messages: 0,
            total_commands: 0,
            total_errors: 0,
            last_heartbeat: Date.now()
        };
        deviceStats.set(deviceId, stats);
        return stats;
    }

    /**
     * æ›´æ–°è®¾å¤‡ç»Ÿè®¡
     * @param {string} deviceId - è®¾å¤‡ID
     * @param {string} type - ç»Ÿè®¡ç±»å‹
     */
    updateDeviceStats(deviceId, type) {
        const stats = deviceStats.get(deviceId);
        if (!stats) return;

        if (type === 'message') stats.total_messages++;
        if (type === 'command') stats.total_commands++;
        if (type === 'error') stats.total_errors++;
        if (type === 'heartbeat') stats.last_heartbeat = Date.now();
    }

    /**
     * æ·»åŠ è®¾å¤‡æ—¥å¿—
     * @param {string} deviceId - è®¾å¤‡ID
     * @param {string} level - æ—¥å¿—çº§åˆ«
     * @param {string} message - æ—¥å¿—æ¶ˆæ¯
     * @param {Object} data - é™„åŠ æ•°æ®
     * @returns {Object} æ—¥å¿—æ¡ç›®
     */
    addDeviceLog(deviceId, level, message, data = {}) {
        message = String(message).substring(0, 500);

        const entry = {
            timestamp: Date.now(),
            level,
            message,
            data
        };

        const logs = deviceLogs.get(deviceId) || [];
        logs.unshift(entry);

        if (logs.length > SYSTEM_CONFIG.maxLogsPerDevice) {
            logs.length = SYSTEM_CONFIG.maxLogsPerDevice;
        }

        deviceLogs.set(deviceId, logs);

        const device = devices.get(deviceId);
        if (device?.stats && level === 'error') {
            device.stats.errors++;
            this.updateDeviceStats(deviceId, 'error');
        }

        if (level !== 'debug' || SYSTEM_CONFIG.enableDetailedLogs) {
            BotUtil.makeLog(level,
                `[${device?.device_name || deviceId}] ${message}`,
                device?.device_name || deviceId
            );
        }

        return entry;
    }

    /**
     * è·å–è®¾å¤‡æ—¥å¿—
     * @param {string} deviceId - è®¾å¤‡ID
     * @param {Object} filter - è¿‡æ»¤æ¡ä»¶
     * @returns {Array} æ—¥å¿—åˆ—è¡¨
     */
    getDeviceLogs(deviceId, filter = {}) {
        let logs = deviceLogs.get(deviceId) || [];

        if (filter.level) {
            logs = logs.filter(l => l.level === filter.level);
        }

        if (filter.since) {
            const timestamp = new Date(filter.since).getTime();
            logs = logs.filter(l => l.timestamp >= timestamp);
        }

        if (filter.limit) {
            logs = logs.slice(0, filter.limit);
        }

        return logs;
    }

    /**
     * æ³¨å†Œè®¾å¤‡
     * @param {Object} deviceData - è®¾å¤‡æ•°æ®
     * @param {Object} Bot - Botå®ä¾‹
     * @param {WebSocket} ws - WebSocketè¿æ¥
     * @returns {Promise<Object>} è®¾å¤‡å¯¹è±¡
     */
    async registerDevice(deviceData, Bot, ws) {
        const {
            device_id,
            device_type,
            device_name,
            capabilities = [],
            metadata = {},
            ip_address,
            firmware_version
        } = deviceData;

        const validation = validateDeviceRegistration(deviceData);
        if (!validation.valid) {
            throw new Error(validation.error);
        }

        const existedDevice = devices.get(device_id);

        const device = {
            device_id,
            device_type,
            device_name: device_name || `${device_type}_${device_id}`,
            capabilities,
            metadata,
            ip_address,
            firmware_version,
            online: true,
            last_seen: Date.now(),
            registered_at: existedDevice?.registered_at || Date.now(),
            stats: existedDevice?.stats || {
                messages_sent: 0,
                messages_received: 0,
                commands_executed: 0,
                errors: 0,
                reconnects: existedDevice ? existedDevice.stats.reconnects + 1 : 0
            }
        };

        devices.set(device_id, device);

        if (!deviceLogs.has(device_id)) {
            deviceLogs.set(device_id, []);
        }

        if (!deviceStats.has(device_id)) {
            this.initDeviceStats(device_id);
        }

        if (ws) {
            this.setupWebSocket(device_id, ws);
        }

        if (!Bot.uin.includes(device_id)) {
            Bot.uin.push(device_id);
        }

        this.createDeviceBot(device_id, device, ws);

        BotUtil.makeLog('info',
            `ğŸŸ¢ [è®¾å¤‡ä¸Šçº¿] ${device.device_name} (${device_id}) - IP: ${ip_address}`,
            device.device_name
        );

        Bot.em('device.online', {
            post_type: 'device',
            event_type: 'online',
            device_id,
            device_type,
            device_name: device.device_name,
            capabilities,
            self_id: device_id,
            time: Math.floor(Date.now() / 1000)
        });

        return device;
    }

    /**
     * è®¾ç½®WebSocketè¿æ¥
     * @param {string} deviceId - è®¾å¤‡ID
     * @param {WebSocket} ws - WebSocketå®ä¾‹
     */
    setupWebSocket(deviceId, ws) {
        const oldWs = deviceWebSockets.get(deviceId);
        if (oldWs && oldWs !== ws) {
            clearInterval(oldWs.heartbeatTimer);
            try {
                if (oldWs.readyState === 1) {
                    oldWs.close();
                } else {
                    oldWs.terminate();
                }
            } catch (e) {
                // å¿½ç•¥é”™è¯¯
            }
        }

        ws.device_id = deviceId;
        ws.isAlive = true;
        ws.lastPong = Date.now();
        ws.messageQueue = [];

        ws.heartbeatTimer = setInterval(() => {
            if (!ws.isAlive) {
                this.handleDeviceDisconnect(deviceId, ws);
                return;
            }

            ws.isAlive = false;

            if (ws.readyState === WebSocket.OPEN) {
                try {
                    ws.send(JSON.stringify({
                        type: 'heartbeat_request',
                        timestamp: Date.now()
                    }));
                } catch (e) {
                    // å¿½ç•¥é”™è¯¯
                }
            }
        }, SYSTEM_CONFIG.heartbeatInterval * 1000);

        ws.on('pong', () => {
            ws.isAlive = true;
            ws.lastPong = Date.now();
            this.updateDeviceStats(deviceId, 'heartbeat');
        });

        ws.on('error', (error) => {
            BotUtil.makeLog('error',
                `âŒ [WebSocketé”™è¯¯] ${error.message}`,
                deviceId
            );
        });

        deviceWebSockets.set(deviceId, ws);
    }

    /**
     * å¤„ç†è®¾å¤‡æ–­å¼€è¿æ¥
     * @param {string} deviceId - è®¾å¤‡ID
     * @param {WebSocket} ws - WebSocketå®ä¾‹
     */
    handleDeviceDisconnect(deviceId, ws) {
        clearInterval(ws.heartbeatTimer);

        const device = devices.get(deviceId);
        if (device) {
            device.online = false;

            BotUtil.makeLog('info',
                `ğŸ”´ [è®¾å¤‡ç¦»çº¿] ${device.device_name} (${deviceId})`,
                device.device_name
            );

            Bot.em('device.offline', {
                post_type: 'device',
                event_type: 'offline',
                device_id: deviceId,
                device_type: device.device_type,
                device_name: device.device_name,
                self_id: deviceId,
                time: Math.floor(Date.now() / 1000)
            });
        }

        deviceWebSockets.delete(deviceId);
    }

    /**
     * åˆ›å»ºè®¾å¤‡Botå®ä¾‹
     * @param {string} deviceId - è®¾å¤‡ID
     * @param {Object} deviceInfo - è®¾å¤‡ä¿¡æ¯
     * @param {WebSocket} ws - WebSocketå®ä¾‹
     * @returns {Object} Botå®ä¾‹
     */
    createDeviceBot(deviceId, deviceInfo, ws) {
        Bot[deviceId] = {
            adapter: this,
            ws,
            uin: deviceId,
            nickname: deviceInfo.device_name,
            avatar: null,
            info: deviceInfo,
            device_type: deviceInfo.device_type,
            capabilities: deviceInfo.capabilities || [],
            metadata: deviceInfo.metadata || {},
            online: true,
            last_seen: Date.now(),
            stats: {
                messages_sent: 0,
                messages_received: 0,
                commands_executed: 0,
                errors: 0,
                reconnects: 0
            },

            addLog: (level, message, data = {}) =>
                this.addDeviceLog(deviceId, level, message, data),

            getLogs: (filter = {}) => this.getDeviceLogs(deviceId, filter),

            clearLogs: () => deviceLogs.set(deviceId, []),

            sendMsg: async (msg) => {
                for (const [keyword, emotion] of Object.entries(EMOTION_KEYWORDS)) {
                    if (msg.includes(keyword)) {
                        return await this.sendCommand(
                            deviceId,
                            'display_emotion',
                            { emotion },
                            1
                        );
                    }
                }

                return await this.sendCommand(
                    deviceId,
                    'display',
                    {
                        text: msg,
                        x: 0,
                        y: 0,
                        font_size: 16,
                        wrap: true,
                        spacing: 2
                    },
                    1
                );
            },

            sendCommand: async (cmd, params = {}, priority = 0) =>
                await this.sendCommand(deviceId, cmd, params, priority),

            sendAudioChunk: (hex) => {
                const ws = deviceWebSockets.get(deviceId);
                if (ws && ws.readyState === WebSocket.OPEN && typeof hex === 'string' && hex.length > 0) {
                    const cmd = {
                        command: 'play_tts_audio',
                        parameters: { audio_data: hex },
                        priority: 1,
                        timestamp: Date.now()
                    };
                    try {
                        ws.send(JSON.stringify({ type: 'command', command: cmd }));
                    } catch (e) {}
                }
            },

            display: async (text, options = {}) =>
                await this.sendCommand(
                    deviceId,
                    'display',
                    {
                        text,
                        x: options.x || 0,
                        y: options.y || 0,
                        font_size: options.font_size || 16,
                        wrap: options.wrap !== false,
                        spacing: options.spacing || 2
                    },
                    1
                ),

            emotion: async (emotionName) => {
                if (!SUPPORTED_EMOTIONS.includes(emotionName)) {
                    throw new Error(`æœªçŸ¥è¡¨æƒ…: ${emotionName}`);
                }
                return await this.sendCommand(
                    deviceId,
                    'display_emotion',
                    { emotion: emotionName },
                    1
                );
            },

            clear: async () =>
                await this.sendCommand(deviceId, 'display_clear', {}, 1),

            camera: {
                startStream: async (options = {}) =>
                    await this.sendCommand(deviceId, 'camera_start_stream', {
                        fps: options.fps || 10,
                        quality: options.quality || 12,
                        resolution: options.resolution || 'VGA'
                    }, 1),
                stopStream: async () =>
                    await this.sendCommand(deviceId, 'camera_stop_stream', {}, 1),
                capture: async () =>
                    await this.sendCommand(deviceId, 'camera_capture', {}, 1),
            },

            microphone: {
                getStatus: async () =>
                    await this.sendCommand(deviceId, 'microphone_status', {}, 0),
                start: async () =>
                    await this.sendCommand(deviceId, 'microphone_start', {}, 1),
                stop: async () =>
                    await this.sendCommand(deviceId, 'microphone_stop', {}, 1),
            },

            reboot: async () =>
                await this.sendCommand(deviceId, 'reboot', {}, 99),

            hasCapability: (cap) => hasCapability(deviceInfo, cap),

            getStatus: () => {
                const device = devices.get(deviceId);
                return {
                    device_id: deviceId,
                    device_name: deviceInfo.device_name,
                    device_type: deviceInfo.device_type,
                    online: device?.online || false,
                    last_seen: device?.last_seen,
                    capabilities: deviceInfo.capabilities,
                    metadata: deviceInfo.metadata,
                    stats: device?.stats || Bot[deviceId].stats
                };
            },

            getStats: () =>
                deviceStats.get(deviceId) || this.initDeviceStats(deviceId)
        };

        return Bot[deviceId];
    }

    /**
     * å‘é€å‘½ä»¤åˆ°è®¾å¤‡
     * @param {string} deviceId - è®¾å¤‡ID
     * @param {string} command - å‘½ä»¤åç§°
     * @param {Object} parameters - å‘½ä»¤å‚æ•°
     * @param {number} priority - ä¼˜å…ˆçº§
     * @returns {Promise<Object>} å‘½ä»¤ç»“æœ
     */
    async sendCommand(deviceId, command, parameters = {}, priority = 0) {
        const device = devices.get(deviceId);
        if (!device) {
            throw new Error('è®¾å¤‡æœªæ‰¾åˆ°');
        }

        const cmd = {
            id: generateCommandId(),
            command,
            parameters,
            priority,
            timestamp: Date.now()
        };

        this.updateDeviceStats(deviceId, 'command');

        const ws = deviceWebSockets.get(deviceId);

        if (ws && ws.readyState === WebSocket.OPEN) {
            return new Promise((resolve) => {
                const timeout = setTimeout(() => {
                    commandCallbacks.delete(cmd.id);
                    resolve({ success: true, command_id: cmd.id, timeout: true });
                }, SYSTEM_CONFIG.commandTimeout);

                commandCallbacks.set(cmd.id, (result) => {
                    clearTimeout(timeout);
                    resolve({ success: true, command_id: cmd.id, result });
                });

                try {
                    ws.send(JSON.stringify({ type: 'command', command: cmd }));
                    device.stats.commands_executed++;
                } catch (e) {
                    clearTimeout(timeout);
                    commandCallbacks.delete(cmd.id);
                    resolve({ success: false, command_id: cmd.id, error: e.message });
                }
            });
        }

        const queue = deviceCommands.get(deviceId) || [];
        if (priority > 0) {
            queue.unshift(cmd);
        } else {
            queue.push(cmd);
        }

        if (queue.length > SYSTEM_CONFIG.messageQueueSize) {
            queue.length = SYSTEM_CONFIG.messageQueueSize;
        }

        deviceCommands.set(deviceId, queue);
        device.stats.commands_executed++;

        return { success: true, command_id: cmd.id, queued: queue.length };
    }

    /**
     * å¤„ç†è®¾å¤‡äº‹ä»¶
     * @param {string} deviceId - è®¾å¤‡ID
     * @param {string} eventType - äº‹ä»¶ç±»å‹
     * @param {Object} eventData - äº‹ä»¶æ•°æ®
     * @param {Object} Bot - Botå®ä¾‹
     * @returns {Promise<Object>} å¤„ç†ç»“æœ
     */
    async processDeviceEvent(deviceId, eventType, eventData = {}, Bot) {
        try {
            if (!devices.has(deviceId)) {
                if (eventType === 'register') {
                    return await this.registerDevice(
                        { device_id: deviceId, ...eventData },
                        Bot
                    );
                }
                return { success: false, error: 'è®¾å¤‡æœªæ³¨å†Œ' };
            }

            const device = devices.get(deviceId);
            device.last_seen = Date.now();
            device.online = true;
            device.stats.messages_received++;

            this.updateDeviceStats(deviceId, 'message');

            switch (eventType) {
                case 'log': {
                    const { level = 'info', message, data: logData } = eventData;
                    this.addDeviceLog(deviceId, level, message, logData);
                    break;
                }

                case 'command_result': {
                    const { command_id, result } = eventData;
                    const callback = commandCallbacks.get(command_id);
                    if (callback) {
                        callback(result);
                        commandCallbacks.delete(command_id);
                    }
                    break;
                }

                case 'asr_session_start':
                    return await this.handleASRSessionStart(deviceId, eventData);

                case 'asr_audio_chunk':
                    return await this.handleASRAudioChunk(deviceId, eventData);

                case 'asr_session_stop':
                    return await this.handleASRSessionStop(deviceId, eventData);

                default:
                    Bot.em(`device.${eventType}`, {
                        post_type: 'device',
                        event_type: eventType,
                        device_id: deviceId,
                        device_type: device.device_type,
                        device_name: device.device_name,
                        event_data: eventData,
                        self_id: deviceId,
                        time: Math.floor(Date.now() / 1000)
                    });
            }

            return { success: true };

        } catch (e) {
            this.updateDeviceStats(deviceId, 'error');
            return { success: false, error: e.message };
        }
    }

    /**
     * å¤„ç†WebSocketæ¶ˆæ¯
     * @param {WebSocket} ws - WebSocketå®ä¾‹
     * @param {Object} data - æ¶ˆæ¯æ•°æ®
     * @param {Object} Bot - Botå®ä¾‹
     * @returns {Promise<void>}
     */
    async processWebSocketMessage(ws, data, Bot) {
        try {
            const { type, device_id, ...payload } = data;
            const deviceId = device_id || ws.device_id || 'unknown';

            if (type !== 'heartbeat' && type !== 'asr_audio_chunk') {
                BotUtil.makeLog('info',
                    `ğŸ“¨ [WebSocket] æ”¶åˆ°æ¶ˆæ¯: type="${type}", device_id="${deviceId}"`,
                    deviceId
                );
            }

            if (!type) {
                BotUtil.makeLog('error',
                    `âŒ [WebSocket] æ¶ˆæ¯æ ¼å¼é”™è¯¯ï¼Œç¼ºå°‘typeå­—æ®µ`,
                    deviceId
                );
                ws.send(JSON.stringify({
                    type: 'error',
                    message: 'æ¶ˆæ¯æ ¼å¼é”™è¯¯ï¼šç¼ºå°‘typeå­—æ®µ'
                }));
                return;
            }

            switch (type) {
                case 'register': {
                    BotUtil.makeLog('info', `ğŸ”Œ [WebSocket] è®¾å¤‡æ³¨å†Œè¯·æ±‚`, deviceId);
                    const device = await this.registerDevice(
                        { device_id: deviceId, ...payload },
                        Bot,
                        ws
                    );
                    ws.send(JSON.stringify({
                        type: 'register_response',
                        success: true,
                        device
                    }));
                    break;
                }

                case 'event':
                case 'data': {
                    const eventType = payload.data_type || payload.event_type || type;
                    const eventData = payload.data || payload.event_data || payload;
                    await this.processDeviceEvent(deviceId, eventType, eventData, Bot);
                    break;
                }

                case 'asr_session_start':
                case 'asr_audio_chunk':
                case 'asr_session_stop':
                    await this.processDeviceEvent(deviceId, type, payload, Bot);
                    break;

                case 'log': {
                    const { level = 'info', message, data: logData } = payload;
                    this.addDeviceLog(deviceId, level, message, logData);
                    break;
                }

                case 'heartbeat': {
                    ws.isAlive = true;
                    ws.lastPong = Date.now();

                    const device = devices.get(deviceId);
                    if (device) {
                        device.last_seen = Date.now();
                        device.online = true;
                        if (payload.status) {
                            device.status = payload.status;
                        }
                    }

                    this.updateDeviceStats(deviceId, 'heartbeat');

                    const queued = deviceCommands.get(deviceId) || [];
                    const toSend = queued.splice(0, 3);

                    ws.send(JSON.stringify({
                        type: 'heartbeat_response',
                        commands: toSend,
                        timestamp: Date.now()
                    }));
                    break;
                }

                case 'command_result':
                    await this.processDeviceEvent(deviceId, type, payload, Bot);
                    break;

                default:
                    ws.send(JSON.stringify({
                        type: 'error',
                        message: `æœªçŸ¥æ¶ˆæ¯ç±»å‹: ${type}`
                    }));
            }
        } catch (e) {
            BotUtil.makeLog('error',
                `âŒ [WebSocket] å¤„ç†æ¶ˆæ¯å¤±è´¥: ${e.message}`,
                ws.device_id
            );
            try {
                ws.send(JSON.stringify({
                    type: 'error',
                    message: e.message
                }));
            } catch (sendErr) {
                // å¿½ç•¥å‘é€é”™è¯¯
            }
        }
    }

    /**
     * æ£€æŸ¥ç¦»çº¿è®¾å¤‡
     * @param {Object} Bot - Botå®ä¾‹
     */
    checkOfflineDevices(Bot) {
        const timeout = SYSTEM_CONFIG.heartbeatTimeout * 1000;
        const now = Date.now();

        for (const [id, device] of devices) {
            if (device.online && now - device.last_seen > timeout) {
                const ws = deviceWebSockets.get(id);

                if (ws) {
                    this.handleDeviceDisconnect(id, ws);
                } else {
                    device.online = false;

                    BotUtil.makeLog('info',
                        `ğŸ”´ [è®¾å¤‡ç¦»çº¿] ${device.device_name} (${id})`,
                        device.device_name
                    );

                    Bot.em('device.offline', {
                        post_type: 'device',
                        event_type: 'offline',
                        device_id: id,
                        device_type: device.device_type,
                        device_name: device.device_name,
                        self_id: id,
                        time: Math.floor(Date.now() / 1000)
                    });
                }
            }
        }
    }

    /**
     * è·å–è®¾å¤‡åˆ—è¡¨
     * @returns {Array} è®¾å¤‡åˆ—è¡¨
     */
    getDeviceList() {
        return Array.from(devices.values()).map(d => ({
            device_id: d.device_id,
            device_name: d.device_name,
            device_type: d.device_type,
            online: d.online,
            last_seen: d.last_seen,
            capabilities: d.capabilities,
            stats: d.stats
        }));
    }

    /**
     * è·å–è®¾å¤‡ä¿¡æ¯
     * @param {string} deviceId - è®¾å¤‡ID
     * @returns {Object|null} è®¾å¤‡ä¿¡æ¯
     */
    getDevice(deviceId) {
        const device = devices.get(deviceId);
        if (!device) return null;

        return {
            ...device,
            device_stats: deviceStats.get(deviceId)
        };
    }
}

// ==================== åˆ›å»ºè®¾å¤‡ç®¡ç†å™¨å®ä¾‹ ====================
const deviceManager = new DeviceManager();

// ==================== å¯¼å‡ºæ¨¡å— ====================
export default {
    name: 'device',
    dsc: 'è®¾å¤‡ç®¡ç†API v30.0 - è·¯å¾„ä¿®å¤ç‰ˆ',
    priority: 90,

    routes: [
        {
            method: 'POST',
            path: '/api/device/register',
            handler: async (req, res, Bot) => {
                try {
                    const device = await deviceManager.registerDevice(
                        {
                            ...req.body,
                            ip_address: req.ip || req.socket.remoteAddress
                        },
                        Bot
                    );
                    res.json({ success: true, device_id: device.device_id });
                } catch (e) {
                    res.status(400).json({ success: false, message: e.message });
                }
            }
        },

        {
            method: 'POST',
            path: '/api/device/:deviceId/ai',
            handler: async (req, res, Bot) => {
                try {
                    const deviceId = req.params.deviceId;
                    const { text } = req.body || {};
                    if (!text || !String(text).trim()) {
                        return res.status(400).json({ success: false, message: 'ç¼ºå°‘æ–‡æœ¬å†…å®¹' });
                    }
                    const device = deviceManager.getDevice(deviceId);
                    if (!device) {
                        return res.status(404).json({ success: false, message: 'è®¾å¤‡æœªæ‰¾åˆ°' });
                    }
                    if (!AI_CONFIG.enabled) {
                        return res.status(400).json({ success: false, message: 'AIæœªå¯ç”¨' });
                    }
                    await deviceManager._processAIResponse(deviceId, String(text));
                    return res.json({ success: true });
                } catch (e) {
                    return res.status(500).json({ success: false, message: e.message });
                }
            }
        },

        {
            method: 'GET',
            path: '/api/devices',
            handler: async (req, res) => {
                const list = deviceManager.getDeviceList();
                res.json({ success: true, devices: list, count: list.length });
            }
        },

        {
            method: 'GET',
            path: '/api/device/:deviceId',
            handler: async (req, res) => {
                const device = deviceManager.getDevice(req.params.deviceId);
                if (device) {
                    res.json({ success: true, device });
                } else {
                    res.status(404).json({ success: false, message: 'è®¾å¤‡æœªæ‰¾åˆ°' });
                }
            }
        },

        {
            method: 'GET',
            path: '/api/device/:deviceId/asr/sessions',
            handler: async (req, res) => {
                const sessions = Array.from(asrSessions.entries())
                    .filter(([_, s]) => s.deviceId === req.params.deviceId)
                    .map(([sid, s]) => ({
                        session_id: sid,
                        device_id: s.deviceId,
                        session_number: s.sessionNumber,
                        total_chunks: s.totalChunks,
                        total_bytes: s.totalBytes,
                        started_at: s.startTime,
                        elapsed: ((Date.now() - s.startTime) / 1000).toFixed(1),
                    }));

                res.json({ success: true, sessions, count: sessions.length });
            }
        },

        {
            method: 'GET',
            path: '/api/device/:deviceId/asr/recordings',
            handler: async (req, res) => {
                try {
                    const recordings = await getAudioFileList(
                        deviceManager.AUDIO_SAVE_DIR,
                        req.params.deviceId
                    );

                    res.json({
                        success: true,
                        recordings,
                        count: recordings.length,
                        total_size: recordings.reduce((s, r) => s + r.size, 0)
                    });
                } catch (e) {
                    res.status(500).json({ success: false, message: e.message });
                }
            }
        },

        {
            method: 'GET',
            path: '/api/asr/recording/:filename',
            handler: async (req, res) => {
                try {
                    const filename = req.params.filename;

                    if (!filename.endsWith('.wav') || filename.includes('..')) {
                        return res.status(400).json({
                            success: false,
                            message: 'æ— æ•ˆçš„æ–‡ä»¶å'
                        });
                    }

                    const filepath = path.join(deviceManager.AUDIO_SAVE_DIR, filename);

                    if (!fs.existsSync(filepath)) {
                        return res.status(404).json({
                            success: false,
                            message: 'æ–‡ä»¶ä¸å­˜åœ¨'
                        });
                    }

                    res.setHeader('Content-Type', 'audio/wav');
                    res.setHeader(
                        'Content-Disposition',
                        `attachment; filename="${filename}"`
                    );

                    fs.createReadStream(filepath).pipe(res);
                } catch (e) {
                    res.status(500).json({ success: false, message: e.message });
                }
            }
        },
    ],

    ws: {
        device: [
            (ws, req, Bot) => {
                BotUtil.makeLog('info',
                    `ğŸ”Œ [WebSocket] æ–°è¿æ¥: ${req.socket.remoteAddress}`,
                    'DeviceManager'
                );

                ws.on('message', msg => {
                    try {
                        const data = JSON.parse(msg);
                        deviceManager.processWebSocketMessage(ws, data, Bot);
                    } catch (e) {
                        BotUtil.makeLog('error',
                            `âŒ [WebSocket] æ¶ˆæ¯è§£æå¤±è´¥: ${e.message}`,
                            ws.device_id
                        );
                    }
                });

                ws.on('close', () => {
                    if (ws.device_id) {
                        deviceManager.handleDeviceDisconnect(ws.device_id, ws);
                    } else {
                        BotUtil.makeLog('info',
                            `âœ“ [WebSocket] è¿æ¥å…³é—­: ${req.socket.remoteAddress}`,
                            'DeviceManager'
                        );
                    }
                });

                ws.on('error', (e) => {
                    BotUtil.makeLog('error',
                        `âŒ [WebSocket] é”™è¯¯: ${e.message}`,
                        ws.device_id || 'unknown'
                    );
                });
            }
        ]
    },

    init(app, Bot) {
        StreamLoader.configureEmbedding({
            enabled: false
        });

        deviceManager.cleanupInterval = setInterval(() => {
            deviceManager.checkOfflineDevices(Bot);
        }, 30000);

        setInterval(() => {
            const now = Date.now();
            for (const [id, _] of commandCallbacks) {
                const timestamp = parseInt(id.split('_')[0]);
                if (now - timestamp > 60000) {
                    commandCallbacks.delete(id);
                }
            }
        }, 60000);

        setInterval(() => {
            const now = Date.now();
            for (const [sessionId, session] of asrSessions) {
                if (now - session.lastChunkTime > 5 * 60 * 1000) {
                    try {
                        const client = asrClients.get(session.deviceId);
                        if (client) {
                            client.endUtterance().catch(() => {});
                        }
                    } catch (e) {
                        // å¿½ç•¥é”™è¯¯
                    }
                    asrSessions.delete(sessionId);
                }
            }
        }, 5 * 60 * 1000);

        BotUtil.makeLog('info', 'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', 'DeviceManager');
        BotUtil.makeLog('info', 'âš¡ [è®¾å¤‡ç®¡ç†å™¨] v30.0 åˆå§‹åŒ–å®Œæˆ - è·¯å¾„ä¿®å¤ç‰ˆ', 'DeviceManager');

        if (VOLCENGINE_ASR_CONFIG.enabled) {
            BotUtil.makeLog('info',
                `âœ“ [ç«å±±ASR] å·²å¯ç”¨ï¼ˆæä¾›å•†: ${VOLCENGINE_ASR_CONFIG.provider}ï¼‰`,
                'DeviceManager'
            );
        }

        if (VOLCENGINE_TTS_CONFIG.enabled) {
            BotUtil.makeLog('info',
                `âœ“ [ç«å±±TTS] å·²å¯ç”¨ï¼ˆæä¾›å•†: ${VOLCENGINE_TTS_CONFIG.provider}ï¼Œè¯­éŸ³: ${VOLCENGINE_TTS_CONFIG.voiceType}ï¼‰`,
                'DeviceManager'
            );
        }

        if (AI_CONFIG.enabled) {
            BotUtil.makeLog('info',
                `âœ“ [è®¾å¤‡AI] å·²å¯ç”¨ï¼ˆæ¨¡å‹: ${AI_CONFIG.chatModel}ï¼‰`,
                'DeviceManager'
            );
        }

        // è®¢é˜…ASRç»“æœäº‹ä»¶ï¼šæ›´æ–°ä¼šè¯finalTextå¹¶è½¬å‘ä¸­é—´ç»“æœåˆ°å‰ç«¯
        try {
            Bot.on('device', (e) => {
                try {
                    if (!e || e.event_type !== 'asr_result') return;
                    const deviceId = e.device_id;
                    const sessionId = e.session_id;
                    const text = e.text || '';
                    const isFinal = !!e.is_final;
                    const duration = e.duration || 0;
                    const session = asrSessions.get(sessionId);
                    if (session && session.deviceId === deviceId) {
                        if (isFinal) {
                            session.finalText = text;
                            session.finalDuration = duration;
                            session.finalTextSetAt = Date.now();
                            // ç«‹å³å°†æœ€ç»ˆç»“æœæ¨é€ç»™å‰ç«¯ï¼Œé¿å…ç­‰å¾…è¶…æ—¶
                            const ws = deviceWebSockets.get(deviceId);
                            if (ws && ws.readyState === WebSocket.OPEN) {
                                ws.send(JSON.stringify({
                                    type: 'asr_final',
                                    device_id: deviceId,
                                    session_id: sessionId,
                                    text
                                }));
                            }
                        } else if (text) {
                            // ä¸­é—´ç»“æœå®æ—¶è½¬å‘åˆ°webclient
                            const ws = deviceWebSockets.get(deviceId);
                            if (ws && ws.readyState === WebSocket.OPEN) {
                                ws.send(JSON.stringify({
                                    type: 'asr_interim',
                                    device_id: deviceId,
                                    session_id: sessionId,
                                    text
                                }));
                            }
                        }
                    }
                } catch {}
            });
        } catch {}

        BotUtil.makeLog('info', 'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', 'DeviceManager');
    },

    destroy() {
        if (deviceManager.cleanupInterval) {
            clearInterval(deviceManager.cleanupInterval);
        }

        for (const [id, ws] of deviceWebSockets) {
            try {
                clearInterval(ws.heartbeatTimer);
                if (ws.readyState === 1) {
                    ws.close();
                } else {
                    ws.terminate();
                }
            } catch (e) {
                // å¿½ç•¥é”™è¯¯
            }
        }

        for (const [deviceId, client] of asrClients) {
            try {
                client.destroy();
            } catch (e) {
                // å¿½ç•¥é”™è¯¯
            }
        }

        for (const [deviceId, client] of ttsClients) {
            try {
                client.destroy();
            } catch (e) {
                // å¿½ç•¥é”™è¯¯
            }
        }

        asrSessions.clear();
    }
};
```

